<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>MPS的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="MPS的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="MPS的个人博客">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MPS的个人博客">
  
    <link rel="alternate" href="/atom.xml" title="MPS的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MPS的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-使用SpringBoot编写一个https网站" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/06/使用SpringBoot编写一个https网站/" class="article-date">
  <time datetime="2020-11-06T14:26:11.000Z" itemprop="datePublished">2020-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/06/使用SpringBoot编写一个https网站/">使用SpringBoot编写一个https网站</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>本周的任务：使用springboot编写一个helloworld网站，并且部署到服务器上。然后配置ssl正式，建立https站点。</em></p>
<br>

<p>先看第一个任务，编写helloWeb并且部署。</p>
<p>步骤：</p>
<ol>
<li>下载并且安装IDEA旗舰版</li>
<li>查看springboot官方文档，根据教程新建hello项目</li>
<li>修改hello项目开放的端口，把项目打包成jar包</li>
<li>配置服务器端的java环境，让项目在服务器上运行</li>
</ol>
<br>

<h3 id="下载并且安装IDEA旗舰版"><a href="#下载并且安装IDEA旗舰版" class="headerlink" title="下载并且安装IDEA旗舰版"></a>下载并且安装IDEA旗舰版</h3><p>由于目前有学生身份，所以认证成功之后就能够免费试用IDEA旗舰版了。</p>
<p>访问Jet Barin官网，下载IDEA，登录一下学生账号之后，就可以试用IDEA编写代码了~</p>
<br>

<h3 id="查看springboot官方文档，根据教程新建hello项目"><a href="#查看springboot官方文档，根据教程新建hello项目" class="headerlink" title="查看springboot官方文档，根据教程新建hello项目"></a>查看springboot官方文档，根据教程新建hello项目</h3><p>进入springboot官网，找到QuickstartGuide，根据教程的内容打开spring initializr。</p>
<p>根据IDEA的提示，选择start.spring.io创建web项目，决定项目名，添加spring web依赖，选择springboot版本（这里我选了2.3.5），等待IDEA下载对应的配置文件之后，项目就自动生成了。</p>
<p>复制文档中的实例代码，结合原来的项目名（hello）进行一些修改，使用IDEA尝试运行springboot项目。出现app运行字样之后，使用浏览器访问localhost:8080/hello，出现Hello World!字样~</p>
<p>另外，使用浏览器访问localhost:8080/hello?name=mps，会出现Hello mps!字样。</p>
<p>可以修改src/resources/application.properties文件，添加<code>server.port=10066</code>语句，修改服务器监听的端口。</p>
<br>

<h3 id="修改hello项目开放的端口，把项目打包成jar包"><a href="#修改hello项目开放的端口，把项目打包成jar包" class="headerlink" title="修改hello项目开放的端口，把项目打包成jar包"></a>修改hello项目开放的端口，把项目打包成jar包</h3><p>根据IDEA自带的maven选项，可以把项目打包成jar包。</p>
<p>打开maven选项卡&gt;hello&gt;Lifecycle&gt;package，可以自动完成打包操作。</p>
<p>打包完成之后可以在项目的target目录看到刚刚打包出来的jar包。</p>
<p>在本地使用window terminal定位到jar包的位置，使用java -jar命令之后，使用浏览器访问localhost:10066/hello，网站正常运行，说明jar包没有问题。</p>
<br>

<h3 id="配置服务器端的java环境，让项目在服务器上运行"><a href="#配置服务器端的java环境，让项目在服务器上运行" class="headerlink" title="配置服务器端的java环境，让项目在服务器上运行"></a>配置服务器端的java环境，让项目在服务器上运行</h3><p>下面使用Xshell控制阿里云的服务器，配置java环境。</p>
<p>具体步骤：</p>
<ol>
<li>在Xshell使用rz命令，传输jdk和前面写好的jar包</li>
<li>tar命令解压jdk的tar包，安装jdk-8u261</li>
<li>使用vim命令，配置java环境变量</li>
<li>运行jar包（可以使用nohup在后台运行）</li>
</ol>
<h4 id="使用Xshell传输jdk和jar包"><a href="#使用Xshell传输jdk和jar包" class="headerlink" title="使用Xshell传输jdk和jar包"></a>使用Xshell传输jdk和jar包</h4><p>这里已经提前再本地下载了jdk1.8.0_261-liunx-x64的tar包了，可以自行访问官网下载。</p>
<p>我使用Xshell对购买的阿里服务器进行操作，下面对于服务器的操作将使用Xshell完成。</p>
<p>服务器安装lrzsz用于传输jdk以便服务器安装。</p>
<p>$ yum install lrzsz -y</p>
<p>安装完成之后，cd到需要存放文件的目录，再使用rz命令会Xshell会弹出文件传输窗口。</p>
<p>$ cd</p>
<p>$ rz</p>
<p>弹窗出现之后，可以选择本地下载的jdk1.8-linux-x64.tar以及前面打包好的jar包，传输到服务器。</p>
<p>另外，学长推荐使用Xftp传输速度更快，下次有机会可以试试。</p>
<h4 id="服务器端解压包，安装jdk-8u261"><a href="#服务器端解压包，安装jdk-8u261" class="headerlink" title="服务器端解压包，安装jdk-8u261"></a>服务器端解压包，安装jdk-8u261</h4><p>使用tar命令，解压刚刚传输的jdk包，到/usr/local/java目录。java目录可以使用mkdir新建。</p>
<p>$ mkdir /usr/local/java</p>
<p>$ tar -zxvf jdk-8u261-linux-x64.tar.gz -C /usr/local/java/</p>
<h4 id="使用vim命令，配置java环境变量"><a href="#使用vim命令，配置java环境变量" class="headerlink" title="使用vim命令，配置java环境变量"></a>使用vim命令，配置java环境变量</h4><p>使用vim命令可以修改环境变量配置文件。</p>
<p>$ vim /etc/profile</p>
<p>在末尾添加如下字段：</p>
<p>export JAVA_HOME=/usr/local/java/jdk1.8.0_261</p>
<p>export PATH=$JAVA_HOME/bin:$PATH</p>
<p>使用source命令使环境变量生效。</p>
<p>$ source /etc/profile</p>
<p>随后，查看java版本。</p>
<p>$ java -version</p>
<p>可以正常看到java的版本，说明java环境配置成功。</p>
<h4 id="运行jar包"><a href="#运行jar包" class="headerlink" title="运行jar包"></a>运行jar包</h4><p>注意，运行jar包之前，需要确保服务器的相关端口是打开的。</p>
<p>可以打开阿里云的控制台，对于服务器所在的实例，看到比如添加安全组的设置选项；</p>
<p>在安全组中，用户可以自行设置需要开放的端口。</p>
<p>这里我已经把端口提前弄好了，就不一一赘述。</p>
<p>现在可以使用java命令，在服务器运行前面传输的jar包了。</p>
<p>$ java -jar &lt;jar包名&gt;</p>
<p>在本地打开浏览器，输入xxx.xxx.xxx.xxx:10066/hello，成功访问hello网站。</p>
<p>说明项目部署成功！</p>
<br>

<p>开始配置ssl之前，需要购买一个域名。</p>
<p>进入阿里云页面，进入产品选项卡，搜索域名注册。</p>
<p>在万网寻找合适的后缀以及关键字，找到心仪的域名，加入清单。</p>
<p>结算清单，完善个人信息模板，产品支付，域名购买成功。</p>
<p>花了5块钱买了一个域名，yysy.xyz感觉还行。</p>
<br>

<p>购买域名之后，还要等待一下审核。</p>
<p>再把helloWeb解析到前面购买的域名上。</p>
<p>打开阿里云的云解析DNS控制台，点击购买的域名，添加记录，选择对应参数即可解析。</p>
<p>现在可以访问<a href="http://www.yysy.xyz:10066/hello，访问hello网站了。" target="_blank" rel="noopener">www.yysy.xyz:10066/hello，访问hello网站了。</a></p>
<br>

<p>下面再看第二个任务，配置ssl证书，令项目可以在https协议下运行。实现用户的安全访问。</p>
<p>步骤：</p>
<ol>
<li>申请ssl证书</li>
<li>配置ssl证书</li>
</ol>
<br>

<h3 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h3><p>要配置ssl证书，首先需要先申请一个证书。</p>
<p>进入阿里云控制台&gt;SSL证书管理控制台，点击购买证书服务（先别慌）；</p>
<p>选择单个域名、DV域名级SSL、免费版、一年，可以看到费用直接归零，于是可以白嫖了。</p>
<p>白嫖ssl证书之后，还要进行证书申请，填写个人信息。</p>
<p>由于我的域名是阿里云买的，所以可以自动DNS验证，验证也是自动完成，证书很快就签发成功了。</p>
<br>

<h3 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h3><p>SSL证书签发之后，开始配置证书。</p>
<br>

<p><em>发现问题：</em></p>
<p><em>查看阿里云的SSL证书配置文档，发现SSL证书部署在Nginx、Tomcat、Apache服务器上；</em></p>
<p><em>而目前的helloWeb是直接是机器终端的java命令跑起来的，没有包装在服务器内；</em></p>
<p><em>没有报错，是因为SpringBoot内置的一个Tomcat。</em></p>
<p><em>既然这个Tomcat是内置的，就很难修改它的配置，部署SSL证书。</em></p>
<br>

<p>这里还是规范一点，先给阿里云的机子安装下Tomcat，使用外部的Tomcat服务器，运行项目。</p>
<p>本地访问Apache Tomcat，下载9.0.39。另外，把helloWeb打包成war包。</p>
<p>后面把两个包传输到阿里云的机子上，为了方便文件传输，建议下载Xftp传输文件。</p>
<h4 id="传输tomcat后，tar解压tomcat包到-usr-local-mytomcat，然后重命名为tomcat。"><a href="#传输tomcat后，tar解压tomcat包到-usr-local-mytomcat，然后重命名为tomcat。" class="headerlink" title="传输tomcat后，tar解压tomcat包到/usr/local/mytomcat，然后重命名为tomcat。"></a>传输tomcat后，tar解压tomcat包到/usr/local/mytomcat，然后重命名为tomcat。</h4><p>$ mkdir /usr/local/mytomcat</p>
<p>$ tar -zxvf apache-tomcat-9.0.39.tar.gz -C /usr/local/mytomcat</p>
<p>$ cd /usr/local/mytomcat</p>
<p>$ mv apache-tomcat-9.0.39 tomcat</p>
<p>运行tomcat/bin/startup.sh，出现Tomcat started字样说明安装成功。</p>
<h4 id="现在使用IDEA把原来的项目打包成war包并且传输："><a href="#现在使用IDEA把原来的项目打包成war包并且传输：" class="headerlink" title="现在使用IDEA把原来的项目打包成war包并且传输："></a>现在使用IDEA把原来的项目打包成war包并且传输：</h4><p>点击File&gt;Project Struct&gt;Artifacts，根据自己的需要修改名字，右击项目选择Put into Output Root，点击OK；</p>
<p>点击Bulid&gt;Build Artifacts&gt;hello&gt;Build，打包之后可以在out目录看到war包；</p>
<p>把war包用Xftp传输到阿里云机子的Tomcat/webapps/下，启动Tomcat</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/06/使用SpringBoot编写一个https网站/" data-id="ckh7svs6l000220ujtfx31dss" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ssl证书/">ssl证书</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/05/大数据架构作业-简答题4/" class="article-date">
  <time datetime="2020-11-05T11:57:57.000Z" itemprop="datePublished">2020-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/05/大数据架构作业-简答题4/">大数据架构作业-简答题4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>没想到第四份作业这么快截止…还好题目全都是能在ppt上找到的…</em></p>
<br>

<blockquote>
<p>第一问：简述什么是大数据系统，在建立大数据系统的时候需要考虑权衡哪些需求。</p>
</blockquote>
<p>大数据系统是整合了数据采集和预处理、存储和管理、处理和分析、可视化呈现等大数据处理 功能的高性能、可伸缩、高可用、高容错、安全易用的软硬件系统。可以用于帮助用户发现大数据中潜在有价值的信息和知识，把握业务现实，预测业务走向。</p>
<p>大数据系统的需求特征：</p>
<ol>
<li>数据分析需求，数据分析分为实时数据分析和批量数据分析；</li>
<li>处理方法需求，处理方法分为预测分析、科学分析、查询报告和混杂分析；</li>
<li>数据反馈频率需求，数据反馈分为按需反馈、持续反馈、实时反馈和时间序列；</li>
<li>数据类型需求，数据类型可以分为元数据类型，基本数据类型，历史数据类型和事务缓存数据类型；</li>
<li>数据内容格式需求，数据内容格式可以分为结构化，非结构化和半结构化；</li>
<li>数据来源需求，数据来源分为网站媒体，机器生成，人工产生，内部数据源，交易数据，生物特征数据等等；</li>
<li>数据客户需求，数据客户可以分为普通用户，商业处理，企业应用和数据存储库；</li>
<li>硬件需求，硬件上有廉价硬件和高性能硬件的区分。</li>
</ol>
<p>根据不同的需求特征，具体系统需要具体的权衡取舍。</p>
<br>

<blockquote>
<p>第二问：简述几类典型的大数据系统架构，详细说明Lambda架构和Kappa架构的特点和适用场合。</p>
</blockquote>
<p>常见的大数据系统架构：传统BI架构、批处理架构、流式处理架构、Lambda架构、Kappa架构。</p>
<p>Lambda架构下，数据通过两天路径并行写到流和批处理系统，程序员需要分别针对批和流两条处理路径提供相应的数据计算逻辑，最终通过服务层整合计算结果视图，进行岁外服务的输出。但是该架构下，程序员需要围挡处批处理层和速度层两套系统，并且容易个业务计算逻辑需要在两层实现和运维，数据的查询以及系统的运维比较复杂。适用于：同时存在事实和离线需求的应用情景。</p>
<p>Kappa架构下，通过流处理系统全程处理事实数据和历史数据，数据作为事件流引入到分布式统一日志中，事件流作为实时数据库进入速度层做流式处理，同时事件流在长期存储中保存，必要的时候重播事件流有流计算引擎重新计算历史数据。Kappa架构解决了Lambda架构里的冗余部分，架构简洁，但是事实难度相对较高（尤其是数据重播部分）。适用于：同时存在事实和离线需求的应用情景。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/05/大数据架构作业-简答题4/" data-id="ckh7svs7d000k20ujda6j9h2x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/作业/">作业</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据架构/">大数据架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/04/大数据架构作业-简答题3/" class="article-date">
  <time datetime="2020-11-04T06:45:47.000Z" itemprop="datePublished">2020-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/04/大数据架构作业-简答题3/">大数据架构作业-简答题3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>大数据架构第三次作业，依然记录一下。</em></p>
<br>

<h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><blockquote>
<p>假设一个企业网需要建设一个后端的缓存集群，用于缓存用户数据加速用户访问速度，因此希望<strong>每个特定的用户最好每次都访问一台固定的服务器节点</strong>，方法是将n台服务器节点编号为0~(n-1)，通过[用户账户 % n]得到访问的服务器编号。但是，如果集群中某台服务器宕机了，则n就变成了n-1，于是取余计算就很可能得不到正确的服务器编号，导致用户请求定位到错误的服务器编号，造成大量的缓存失效。</p>
<p>请设计一种方案来改善这种情况，使得<strong>集群中部分服务器失效后不会造成大面积的缓存失效</strong>；（2）原有的访问大部分还是保持在同一台服务器节点上；（3）负载尽量均衡。</p>
</blockquote>
<p>这里我的思路是，使用<strong>一致性哈希</strong>进行数据分片。</p>
<p>首先，将n个服务器节点，根据对应的编号计算相应的hash值，映射到一个首尾相接的hash环上；然后，再将用户，按照用户账户计算hash值，映射到同一个hash环上；这样，当用户发起访问请求的时候时，根据用户账户在hash环的位置，将用户的请求交给环上顺时针数到的第一个服务器节点。</p>
<p>为了实现要求(3)，需要根据用户账户的hash映射情况，设计合理的hash算法，把n个服务器以对于用户相对均匀地映射到hash环上。</p>
<p>为了实现要求(2)和要求(1)，当一个服务器宕机之后，需要及时在宕机节点的位置，设置一个新的虚拟分身节点。虚拟分身节点对应的物理节点不应该取宕机服务器附近的节点，避免出现数据倾斜和节点雪崩。</p>
<br>

<br>

<h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><blockquote>
<p>简要说明分布式系统中的副本建立策略以及各种策略存在的问题。</p>
</blockquote>
<p>建立副本的策略及其存在问题</p>
<ol>
<li>单主复制，有且仅有一个master副本，其它都是备用的slave副本，维护master副本的节点作为中心节点，负责维护数据更新、并发控制、协调副本的一致性。</li>
</ol>
<ul>
<li>单主复制的问题。可用性问题，master宕机之后，slave竞选、服务切换到新的master都需要时间，这段时间内系统拥塞，无法提供服务；一致性问题，master宕机之后，通过slave竞选出新的master，此时新旧master之间存在尚未同步的数据，导致数据不一致。</li>
</ul>
<ol start="2">
<li>多主复制，所有副本都是master，副本之间户为主从。</li>
</ol>
<ul>
<li>多主复制的问题，在并发操作时，存在数据不一致性问题。</li>
</ul>
<ol start="3">
<li>无主复制，不区分master和slave副本，客户端向多个副本同时发送请求。</li>
</ol>
<ul>
<li>无主复制的问题，尽管客户端可以进行数据补偿，但是依然存在数据不一致性问题。</li>
</ul>
<br>

<br>

<h2 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h2><blockquote>
<p>分布式系统中是否能够在保证副本强一致性的前提下，同时可以获得高可用和容错性。请简要阐述CAP定理和BASE理论的内容和作用。</p>
</blockquote>
<p><strong>CAP定理</strong>：<strong>一个分布式系统不可能同时满足一致性、可用和分区容错性，最多只能满足其中两项。</strong>一致性，所有数据副本的数据都是一致的；可用性，所有请求都能获取正确的响应；分区容错性，即使发生了网络分区，系统也能对外提供满足一致性和可用性的服务。</p>
<p>CAP定理指出了，在分布式系统的设计中，由于分区容错性不能舍弃，因此只能在一致性和可用性之间做出妥协，不能同时兼得三大特性，该定理给出了简明并且可以理解的证明。</p>
<p><strong>BASE原理</strong>：弱化一致性，追求分区容错性和可用性。基本可用，要求系统能够基本运行，一直提供服务，在出现不可预知故障的时候， 允许损失部分可用性，如响应延时或者服务降级；软状态，允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可 用性，即允许不同节点的副本之间存在暂时的不一致情况；最终一致性，要求数据不能一直处于软状态，必须在一段时间后达到一致，保证所 有副本中的数据一致性。</p>
<p>BASE理论的作用，保证最终一致性，对可用性做出让步，代表了追求可用性和分区容错性的分布式系统设计哲学。这种设计模式，对可用性要求比较高但一致性要求不是特别高的应用场景下，提供了高效的理论指导。</p>
<br>

<br>

<h2 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h2><blockquote>
<p>学习Basic Paxos算法，针对5个节点的集群，模仿算法执行过程。假设集群需要完成来自客户端的如下命令，针对该命令模仿说明算法达成一致性的过程。</p>
<p>Put(“x”, 3)</p>
<p>要求仿真出如下场景：（1）节点故障（3）并发操作请求（4）网络分区。</p>
</blockquote>
<p>假设场景：目前有五个节点，分别为node1、node2、node3、node4、node5；其中节点1、2和3和节点4和5进行了网络分区；同一时刻有两个客户端对集群发出并发请求Put(“x”, 3)；目前node3出现了故障，无法响应客户端的请求。</p>
<p>假设node1首先接收到client1的请求，node4首先接收到client2的请求，而且node1比node4更早收到请求。如下图所示</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/a95fbf4d53abf8c7c4c453ff77d8cccd.png" alt="发送请求.png"></p>
<p>node1和node4接收到请求之后成为提案者，开始Basic Paxos算法的准备阶段。node1开始向各个节点发送prepare请求，K值为1。由于各个节点此前还没有进行过同步操作，所以各个节点的MaxN都小于1，则各个节点都会回应pok。但是，由于node3节点故障，无法响应node1的请求，所以node3没有响应。node4节点上的情景和node1相类似，不再重复说明。如下图所示</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/088f1789610696a20ba27c290c5c6c05.png" alt="Prepare.png"></p>
<p>各节点返回pok之后，算法开始第二阶段接收阶段。node1收到了超过半数的pok，开始向各节点发送accept请求，accept(1, Put(“x”, 3))。但是，由于其他节点已经接收了node4的Prepare(2)请求，所以不会再接收提案编号小于2的accept请求，因此其它节点不会响应node1的请求。另一方面，node4发送的accept(2, Put(“x”, 3))，则会被除了目前故障的node3以外的其他节点接收。如下图所示</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/cb9b0ad7e65cfebdba2c659972542141" alt="img"></p>
<p>完成了如上两个阶段之后，所有非故障节点会主动同步提案2到本地，完成Put(“x”, 3)的一致性修改。</p>
<br>

<br>

<h2 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h2><blockquote>
<p>简述分布式系统中建立逻辑时钟的两种方法。</p>
</blockquote>
<p><strong>Lamport时间戳原理规则</strong>：</p>
<ol>
<li><p>每个节点本地都有一个时间戳，初始值为0。</p>
</li>
<li><p>若事件在节点内发生，本地时间戳加1。</p>
</li>
<li><p>若是发送事件，本地时间戳加1并在消息中带上该时间戳。</p>
</li>
<li><p>若是接收事件，本地时间戳 = Max(本地时间戳，消息中的时间戳)+1。</p>
</li>
</ol>
<p><strong>Lamport时间戳具体操作</strong>：</p>
<ol>
<li>假设事件a和b分别发生在节点5和节点3上，时间戳为L(a)和L(b)。</li>
<li>如果L(a) &lt; L(b)，则a发生在b之前，记作 a-&gt;b。</li>
<li>如果L(a) = L(b)，则按事件发生的节点编号排序，3&lt;5，故 b-&gt;a。</li>
</ol>
<br>

<p><strong>向量时钟具体操作:</strong></p>
<ol>
<li>事件a、b分别在节点P、Q上发生，Vector clock分别为Ta、Tb，如果 Tb[Q] &gt; Ta[Q]并且 Tb[P] &gt;= Ta[P]，则a发生于b之前，记作 a -&gt; b。</li>
<li>如果 Tb[Q] &gt; Ta[Q] 并且 Tb[P] &lt; Ta[P]，则认为a、b同时发生，记作 a &lt;-&gt; b。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/04/大数据架构作业-简答题3/" data-id="ckh7svs78000f20ujw9xb117k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/作业/">作业</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据架构/">大数据架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习内网穿透" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/08/学习内网穿透/" class="article-date">
  <time datetime="2020-10-08T02:12:54.000Z" itemprop="datePublished">2020-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/08/学习内网穿透/">学习内网穿透</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="需要设备"><a href="#需要设备" class="headerlink" title="需要设备"></a>需要设备</h2><ol>
<li>学校分发的虚拟机</li>
<li>一个云服务器</li>
</ol>
<br>

<h2 id="熟悉云服务器"><a href="#熟悉云服务器" class="headerlink" title="熟悉云服务器"></a>熟悉云服务器</h2><p>学生优惠购买了一个实例<br>设置实例密码<br>使用<strong>vnc</strong>链接服务器，发现<strong>login incorrect</strong>，原来是实例密码跟服务器密码不一样，要自己设置一个…<br>通过阿里云的控制台修改服务器密码，重启机子，然后就可以链接啦~<br>后面了解到可以使用<strong>Xshell</strong>代替<strong>workbench</strong>链接到自己的服务器，这个教程很多随便百度都能找到<br><strong>ps:</strong> 通过下文问题一了解到，阿里云服务器通过在控制台设置安全组开启端口。</p>
<br>

<br>

<h2 id="下面正式学习frp"><a href="#下面正式学习frp" class="headerlink" title="下面正式学习frp"></a>下面正式学习frp</h2><h4 id="frp学习参考文章："><a href="#frp学习参考文章：" class="headerlink" title="frp学习参考文章："></a>frp学习参考文章：</h4><ol>
<li><a href="https://sspai.com/post/52523" target="_blank" rel="noopener">https://sspai.com/post/52523</a> =  –”少数派”的博客</li>
<li><a href="https://gofrp.org/" target="_blank" rel="noopener">https://gofrp.org/</a>  –<strong>frp</strong>的官方文档</li>
</ol>
<br>

<h4 id="安装go环境："><a href="#安装go环境：" class="headerlink" title="安装go环境："></a>安装go环境：</h4><p>直接下载<strong>go</strong>对应的版本：<a href="https://golang.org/dl/go1.15.2.linux-amd64.tar.gz" target="_blank" rel="noopener">https://golang.org/dl/go1.15.2.linux-amd64.tar.gz</a><br>也可以使用<strong>wget</strong>命令直接在终端下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.15.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong> 如果想通过<strong>wget</strong>命令下载，貌似需要提前安装git和<strong>gcc</strong>，参考文章1<br>然后参考文章2的提示，通过<code>tar</code>和<code>export</code>命令，完成<strong>go</strong>的安装<br>参考的文章：</p>
<ol>
<li><a href="https://www.jianshu.com/p/21dc1bcf382e" target="_blank" rel="noopener">https://www.jianshu.com/p/21dc1bcf382e</a></li>
<li><a href="https://golang.org/doc/install#requirements" target="_blank" rel="noopener">https://golang.org/doc/install#requirements</a></li>
</ol>
<br>

<h4 id="下载frp"><a href="#下载frp" class="headerlink" title="下载frp"></a>下载frp</h4><p>使用<strong>wget</strong>命令下载<strong>frp</strong>的最新版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.34.0/frp_0.34.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong> 下载的版本错了可以使用rm命令删除，详见博客1<br><strong>pps:</strong> <strong>wget</strong>命令好像跟<strong>yum</strong>命令不一样，配置软件源没有什么用，想配置的可以参考一下博客2<br>参考的博客：</p>
<ol>
<li><a href="https://blog.csdn.net/sqbzo/article/details/8990404" target="_blank" rel="noopener">https://blog.csdn.net/sqbzo/article/details/8990404</a></li>
<li><a href="https://www.jianshu.com/p/541c737bc947" target="_blank" rel="noopener">https://www.jianshu.com/p/541c737bc947</a></li>
</ol>
<br>

<h4 id="启动frps-配置frps端"><a href="#启动frps-配置frps端" class="headerlink" title="启动frps(配置frps端)"></a>启动frps(配置frps端)</h4><p>内网穿透是把自己的终端穿透到有公网ip的服务器上的技术，这里我们先配置<strong>VPS</strong>（有公网ip的服务器），也就是<strong>frps</strong>端，这里我使用了阿里的服务器<br>先使用<strong>tar</strong>命令解压刚下载的frp：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.34.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后cd进该目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.34.0_linux_amd64</span><br></pre></td></tr></table></figure>

<p>检查文件发现目录内除了<strong>fprs</strong>文件还有<strong>frpc</strong>文件，使用rm命令将<strong>frpc</strong>文件一一删除<br>然后修改<strong>frps.ini</strong>文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim frps.ini</span><br></pre></td></tr></table></figure>

<p>文件格式大致如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">vhost_http_port = 10080</span><br><span class="line">vhost_https_port = 100443</span><br><span class="line">dashboard_port = 7500</span><br><span class="line">token = ******</span><br><span class="line">dashboard_user = ms</span><br><span class="line">dashboard_pwd = ********</span><br></pre></td></tr></table></figure>

<p>编辑完成之后保存:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p>然后启动<strong>frps：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>

<p>出现<strong>start</strong>字样，说明<strong>frps</strong>服务启动成功</p>
<br>

<h4 id="问题一：x-x-x-xxx-7500无法连接至控制页面"><a href="#问题一：x-x-x-xxx-7500无法连接至控制页面" class="headerlink" title="问题一：x.x.x.xxx:7500无法连接至控制页面"></a>问题一：x.x.x.xxx:7500无法连接至控制页面</h4><p>运行<strong>frps</strong>之后，使用浏览器访问对应的地址无响应…<br>根据博客2，发现原来是防火墙没有开放服务器指定的端口！<br>查看端口是否开放: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=7500/tcp --zone=public</span><br></pre></td></tr></table></figure>

<p>如果端口开放了就返回<strong>yes</strong>，反则返回<strong>no</strong><br>但是，我返回的是<strong>FirewallD is not running</strong>…<br>百度找到博客3，发现原来服务器没有打开防火墙！<br>根据blog3打开防火墙：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system start firewalld</span><br></pre></td></tr></table></figure>

<p>打开7500端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=7500/tcp</span><br></pre></td></tr></table></figure>

<p>这次再使用<strong>firewall-cmd</strong>命令看端口是否开放，返回的结果居然是<strong>no</strong>…<br>再次百度，根据博客1，发现阿里的服务器需要<strong>另外设置安全组</strong>才能开放相关的端口！<br>根据博客1设置安全组，开放2000到20000的端口<br>重启服务器之后，再次打开防火墙，开放7500端口<br>再次使用<strong>firewall-cmd</strong>检查，这次终于返回yes了<br>访问<strong>x.x.x.xxx:7500</strong>，输入用户密码，成功访问<strong>frp</strong>管理网页！<br>后话：后面配置<strong>frpc</strong>的时候居然要关闭防火墙，所以前面根据博客3和博客2关于防火墙和端口的修改其实没有什么必要，直接使用阿里云的控制平台开放端口才是正解！<br>参考的博客：</p>
<ol>
<li><a href="https://blog.csdn.net/weferxe/article/details/104777838" target="_blank" rel="noopener">https://blog.csdn.net/weferxe/article/details/104777838</a>  –设置阿里云安全组</li>
<li><a href="https://koolshare.cn/forum.php?mod=viewthread&amp;tid=137536&amp;page=1&amp;extra=" target="_blank" rel="noopener">https://koolshare.cn/forum.php?mod=viewthread&amp;tid=137536&amp;page=1&amp;extra=</a>  –开放端口的命令</li>
<li><a href="https://www.cnblogs.com/rxbook/p/8110143.html" target="_blank" rel="noopener">https://www.cnblogs.com/rxbook/p/8110143.html</a>  –控制<strong>linux</strong>的防火墙</li>
</ol>
<br>

<h4 id="使用nohup挂起frps进程"><a href="#使用nohup挂起frps进程" class="headerlink" title="使用nohup挂起frps进程"></a>使用nohup挂起frps进程</h4><p>目前关闭<strong>shell</strong>窗口之后，现在的<strong>frps</strong>进程就会结束<br>为了让<strong>frps</strong>和<strong>frpc</strong>两端一直穿透，需要把<strong>frps</strong>进程挂到后台<br>参考博客1，使用<strong>nohup</strong>命令把进程移动到后台:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure>

<p>同理，后面<strong>frpc</strong>端也要使用nohup挂起进程<br>参考的博客：</p>
<p>同理，后面frpc端也要使用nohup挂起进程<br>参考的博客：</p>
<ol>
<li><a href="https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/</a> –这篇博客还介绍了后台进程的关闭等事项</li>
</ol>
<br>

<h4 id="启动frpc-配置frpc端"><a href="#启动frpc-配置frpc端" class="headerlink" title="启动frpc(配置frpc端)"></a>启动frpc(配置frpc端)</h4><p>上面配置好了<strong>frps</strong>端，下面再配置<strong>frpc</strong>端之后就能实现穿透了！<br>这里我使用学校机房分发的一台虚拟机，作为<strong>frpc</strong>端，同样需要实现安装golang和<strong>frp</strong><br>下载完<strong>frp</strong>的安装包之后，和<strong>frps</strong>端类似，tar解压，然后删除f<strong>rps</strong>文件<br>使用vim命令修改frpc.ini:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure>

<p>文件的格式大致如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line">token = ******</span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = x.x.x.x</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 这里的<strong>local_port</strong>是指frpc机子上<strong>web</strong>进程使用的端口; custom_domains是<strong>frps</strong>端的<strong>ip地址</strong>或者域名，由于我还没买域名，所以这里就填了自己的ip<br>保存之后启动进程: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></table></figure>

<p>进程正常启动，和<strong>frps</strong>端类似，使用nohup把进程挂起，<strong>frpc</strong>端配置就完成了！</p>
<br>

<h4 id="编写一个最简单的web"><a href="#编写一个最简单的web" class="headerlink" title="编写一个最简单的web"></a>编写一个最简单的web</h4><p>现在<strong>frpc</strong>端已经配置完成，还需要写一个web测试一下，<strong>web</strong>服务能否被正常访问<br>远程控制学校分配的虚拟机，使用<strong>python</strong>的flask框架编写一个简单的应用</p>
<br>

<p>安装<strong>python3</strong>和<strong>pip3</strong><br>安装<strong>python3</strong>直接<strong>yum</strong>即可，安装<strong>pip3</strong>可以参照一下文章1<br>使用<strong>pip</strong>安装<strong>flask</strong>： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i [清华源] flask</span><br></pre></td></tr></table></figure>

<p>使用清华源安装<strong>flask</strong>快一点，详细参照文章2<br>完成上面的安装之后就可以开始编写<strong>web</strong>了！<br>参考文章：</p>
<ol>
<li><a href="https://blog.csdn.net/jamieblue1/article/details/89208151" target="_blank" rel="noopener">https://blog.csdn.net/jamieblue1/article/details/89208151</a>  –安装pip</li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a>  –清华</li>
</ol>
<br>

<h4 id="编写app-py"><a href="#编写app-py" class="headerlink" title="编写app.py"></a>编写app.py</h4><p>临时创建一个文件夹<strong>test_flask</strong>，存放app.py<br>根据<strong>flask</strong>的官方文档，文章1，编写一个只返回<strong>‘frp sucess!!!’</strong>的简单应用<br><strong>vim app.py:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'frp sucess!!!'</span></span><br></pre></td></tr></table></figure>

<p>然后保存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p>启动web:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=app.py</span><br><span class="line">python3 -m flask run</span><br></pre></td></tr></table></figure>

<p>然后使用自己的机子访问<strong>x.x.x.x:10080</strong>，显示<strong>‘frp sucess!!!’</strong>，说明内网穿透成功！</p>
<p>参考文章：</p>
<ol>
<li><a href="https://dormousehole.readthedocs.io/en/latest/quickstart.html#id2" target="_blank" rel="noopener">https://dormousehole.readthedocs.io/en/latest/quickstart.html#id2</a></li>
</ol>
<br>

<br>

<p>结语：<br>内网穿透技术可以很好地解决<strong>VPS</strong>配置不足的问题，由于学校机房分配了3台虚拟机，我才想借机利用一下，才学习了<strong>frp</strong>。但是在学习的中途我越发觉得这个技术对于学生来说，能够提供很大的便利，于是把学习的过程记录下来，希望能够帮助到其他人。<br>以后想学习一下<strong>nignx</strong>，尝试一下能否把多个域名映射到一台<strong>VPS</strong>的不同端口，进而穿透到不同的机子，提供多个服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/08/学习内网穿透/" data-id="ckh7svs7e000m20uje1i6d0ig" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/frp/">frp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内网穿透/">内网穿透</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-WSLinux之Ubuntu-安装rpm包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/27/WSLinux之Ubuntu-安装rpm包/" class="article-date">
  <time datetime="2020-09-27T02:28:09.000Z" itemprop="datePublished">2020-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/27/WSLinux之Ubuntu-安装rpm包/">WSLinux之Ubuntu安装rpm包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在看<strong>《springboot实战》</strong>。</p>
<p>看到<strong>springbootCLI</strong>的时候，想要在<strong>windos</strong>子系统的<strong>Ubuntu</strong>上学习一下，所以想要安装<strong>java</strong>。</p>
<p>从同学那里要到了rpm包之后，发现<strong>Ubuntu</strong>居然不能直接安装<strong>rpm</strong>包！</p>
<p>查看社区发现<strong>Ubuntu</strong>是基于<strong>Debian</strong>的系统，不同于<strong>CentOS, RHEL or Fedora</strong>。</p>
<p><strong>Ubuntu</strong>不能直接使用<strong>rpm</strong>命令，而是要通过<strong>alien命令</strong>。</p>
<br>

<h2 id="安装alien可分为三个步骤："><a href="#安装alien可分为三个步骤：" class="headerlink" title="安装alien可分为三个步骤："></a>安装alien可分为三个步骤：</h2><h3 id="一、添加Universe-distribution-component（渣翻：universe组成元件，用于连接universe仓库）"><a href="#一、添加Universe-distribution-component（渣翻：universe组成元件，用于连接universe仓库）" class="headerlink" title="一、添加Universe distribution component（渣翻：universe组成元件，用于连接universe仓库）"></a>一、添加Universe distribution component（渣翻：universe组成元件，用于连接universe仓库）</h3><p>仓库提供软件安装的地址。除了<strong>universe</strong>以外，<strong>Ubuntu</strong>还有<strong>Main</strong>、<strong>Restricted</strong>、Multiverse等仓库。</p>
<p><strong>Universe</strong>仓库提供由社区主导，并且完全开源的软件。这里的alien安装就需要<strong>Universe</strong>仓库。</p>
<p>添加远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br></pre></td></tr></table></figure>

<p>另外，在命令里添加-r选项，可以移除仓库。</p>
<p><strong>注意，如果网络速度太慢可能会导致部分安装错误，最后无法安装alien！所以安装之前先考虑一下网络，有可能需要科学上网。</strong></p>
<br>

<h3 id="二、更新apt的cache"><a href="#二、更新apt的cache" class="headerlink" title="二、更新apt的cache"></a>二、更新apt的cache</h3><p>更新了仓库之后，还要更新<strong>apt</strong>的<strong>cache</strong>才能查找到需要的软件。apt的<strong>cache</strong>用于提供软件安装的地址，如果不更新就自然就找不到对应的包。另外，系统新装的时候也需要更新一下apt。</p>
<p>更新apt：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p><strong>update</strong>命令并不会直接<strong>apt</strong>安装所有软件。如果需要进一步更新软件需要使用upgrade命令。</p>
<br>

<h3 id="三、安装alien包"><a href="#三、安装alien包" class="headerlink" title="三、安装alien包"></a>三、安装alien包</h3><p><strong>alien</strong>用于安装rpm包，具体的安装方法有两种，第四点会一一介绍。</p>
<p>安装<strong>alien</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install alien</span><br></pre></td></tr></table></figure>

<br>

<h3 id="四、安装rpm包"><a href="#四、安装rpm包" class="headerlink" title="四、安装rpm包"></a>四、安装rpm包</h3><p>安装了<strong>alien</strong>之后就可以愉快地安装rpm包。但是这里在说一下，安装<strong>rpm</strong>包有两种方式。</p>
<ol>
<li>把<strong>rpm</strong>转换成deb包再安装</li>
</ol>
<p><strong>alien</strong>命令可以把rpm包变成<strong>deb</strong>包，再安装。这种方法比较推荐。</p>
<p>把当前目录<strong>cd</strong>到<strong>rpm</strong>包所在的目录下，按一下命令执行即可安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo alien packagename.rpm</span><br><span class="line"></span><br><span class="line">sudo dpkg -i packagename.deb</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>直接安装<strong>rpm</strong>包</li>
</ol>
<p>alien也可直接<strong>rpm</strong>包。但是需要注意，这个方法不是<strong>native</strong>（原生）的所以可能会出现一点问题。</p>
<p>直接安装<strong>rpm</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo alien -i packagename.rpm</span><br></pre></td></tr></table></figure>

<br>

<br>

<p>好了，到这里本次分享已经结束。希望能够帮助你。</p>
<br>

<p>参考文章：</p>
<ol>
<li><a href="https://phoenixnap.com/kb/install-rpm-packages-on-ubuntu" target="_blank" rel="noopener">https://phoenixnap.com/kb/install-rpm-packages-on-ubuntu</a></li>
<li><a href="https://help.ubuntu.com/community/Repositories/Ubuntu" target="_blank" rel="noopener">https://help.ubuntu.com/community/Repositories/Ubuntu</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/27/WSLinux之Ubuntu-安装rpm包/" data-id="ckh7svs6z000a20ujsgxvkgln" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WSL/">WSL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/搬运/">搬运</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/26/大数据架构作业-简答题2/" class="article-date">
  <time datetime="2020-09-26T12:05:46.000Z" itemprop="datePublished">2020-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/26/大数据架构作业-简答题2/">大数据架构作业-简答题2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>大数据架构第二次作业出来了，这次照旧记录一下。</em></p>
<br>

<h2 id="容器化技术的核心原理"><a href="#容器化技术的核心原理" class="headerlink" title="容器化技术的核心原理"></a>容器化技术的核心原理</h2><blockquote>
<p><strong>题目：</strong>请从网络下载<strong>virtualbox</strong>软件并安装，然后在<strong>virtualbox</strong>中创建一台或多台虚拟机，尝试在虚拟机中安装<strong>CentOS</strong>或者<strong>Ubuntu</strong>等<strong>Linux</strong>操作系统。在<strong>Linux</strong>操作系统中，测试实现容器的核心技术：<strong>namespace</strong>和<strong>cgroups</strong>两项内核功能，最后在答案部分陈述实验过程、遇到的问题和解决思路、技术原理和实验体会等。</p>
</blockquote>
<br>

<h3 id="使用virtualbox创建Ubuntu虚拟机"><a href="#使用virtualbox创建Ubuntu虚拟机" class="headerlink" title="使用virtualbox创建Ubuntu虚拟机"></a>使用virtualbox创建Ubuntu虚拟机</h3><p>首先在官网下载并安装<strong>virtualbox</strong>，到<strong>Ubuntu</strong>官网：<a href="https://cn.ubuntu.com/download，下载20.04版本的**Ubuntu.ios**文件。然后参考博客安装**Ubuntu**系统。" target="_blank" rel="noopener">https://cn.ubuntu.com/download，下载20.04版本的**Ubuntu.ios**文件。然后参考博客安装**Ubuntu**系统。</a></p>
<p>安装的速度比较慢，有可能是因为机子的配置不够。安装系统提示仍需<strong>8h</strong>的时候，我直接睡觉了…</p>
<p>虚拟机的创建过程很简单，只要根据基本的操作，看看系统安装的步骤很快就可以完成。</p>
<p>考虑到现在<strong>Win10</strong>可以安装<strong>Ubuntu</strong>子系统，其实没有必要非得装一个虚拟机去体验<strong>Linux</strong>。不过以后如果有机会，可以尝试用一下<strong>vbox</strong>安装<strong>windows-xp</strong>，玩一下不兼容的老游戏。</p>
<p>参考博客：<a href="https://blog.csdn.net/u012732259/article/details/70172704" target="_blank" rel="noopener">https://blog.csdn.net/u012732259/article/details/70172704</a></p>
<br>

<p>学习Linux中的容器</p>
<p>容器实现的原理：namespace（实现资源隔离）、cgroups（实现资源控制）（两者是Linux内核功能）</p>
<p>容器是拥有单独命名空间的进程。</p>
<p>Namespace（命名空间）</p>
<p>Namespace定义了一个封闭的作用域范围，约定。Namespace本质是一种资源隔离方案。</p>
<p>处于同一命名空间的进程，只能看到该名字空间下的资源，如主机名、网络、进程、用户、文件系统等。</p>
<p>不同名字空间的进程彼此不可见，互不影响。</p>
<p>每个进程拥有七个命名空间犹豫隔离不同类型的资源：PID Namespace（pid）、CGroup Namespace（cgroup）、IPC Namespace（ipc）、Mount Namespace（mnt）、Network Namespace（net）、User Namespace（user）、UTS Namespace（uts）。</p>
<p>关于namespace的特性可以参考这篇博客：<a href="https://zhengyinyong.com/post/introduction-to-linux-namespace/" target="_blank" rel="noopener">https://zhengyinyong.com/post/introduction-to-linux-namespace/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/26/大数据架构作业-简答题2/" data-id="ckh7svs73000b20ujq5k0215y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/作业/">作业</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据架构/">大数据架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-入门JavaSE-进阶篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/23/入门JavaSE-进阶篇/" class="article-date">
  <time datetime="2020-09-23T10:36:08.000Z" itemprop="datePublished">2020-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/23/入门JavaSE-进阶篇/">入门JavaSE-进阶篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>趁热打铁，开始看进阶篇，快速入门。</p>
<h2 id="javase入门-进阶"><a href="#javase入门-进阶" class="headerlink" title="javase入门 进阶"></a>javase入门 进阶</h2><p><a href="https://www.imooc.com/learn/110" target="_blank" rel="noopener">https://www.imooc.com/learn/110</a><br><br><br><br></p>
<h2 id="C1-异常与异常处理"><a href="#C1-异常与异常处理" class="headerlink" title="C1-异常与异常处理"></a>C1-异常与异常处理</h2><h3 id="异常简介"><a href="#异常简介" class="headerlink" title="异常简介"></a>异常简介</h3><p>有错误出现，阻止当前方法或作用域<br><code>Throwable</code>所有异常的父类, 有两个子类</p>
<ol>
<li>Error 虚拟机错误，线程死锁</li>
<li>Exception runtime异常（非检查异常），检查异常</li>
</ol>
<br>

<br>

<h3 id="处理异常-捕获异常"><a href="#处理异常-捕获异常" class="headerlink" title="处理异常(捕获异常)"></a>处理异常(捕获异常)</h3><p><code>try-catch</code>以及<code>try-catch-finally</code>，<code>catch</code>语句捕获异常进行处理，可以有多个<code>catch</code>语句块，先<code>catch</code>异常子类再<code>catch</code>异常的父类，<code>finally</code>是异常处理完之后再执行的语句块。<br>ps：打印异常可以用 <code>e.printStackTrace();</code><br>pps: 原来输入法可以切换中英文标点, 不需要整个输入法切换成英文!</p>
<br>

<h3 id="异常抛出以及自定义异常"><a href="#异常抛出以及自定义异常" class="headerlink" title="异常抛出以及自定义异常"></a>异常抛出以及自定义异常</h3><h4 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h4><p><code>throws</code> 声明僬侥抛出何种类型的异常(声明)<br><code>throw</code> 将产生的异常抛出(动作)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出异常方法示例:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名(参数列表) <span class="keyword">throws</span> 异常列表 &#123;</span><br><span class="line">		<span class="comment">//调用会抛出异常的方法或者throw new Exception();</span></span><br><span class="line">		<span class="comment">//处理没有预先规定的异常种类</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>ps: 异常的处理是多样化的, 捕获异常(try-catch)和抛出异常(throws)只是两种方式,抛出异常一般处理<br><br></p>
<h4 id="自定义的异常"><a href="#自定义的异常" class="headerlink" title="自定义的异常"></a>自定义的异常</h4><p>自定义异常: 自定义一个自己编写的异常种类<br>语法: <code>public class MyException extends Exception {}</code><br>ps: 注意要编写构造方法, 另外父类必须为Exception或者其它子类<br>pps: Exception构造方法输入参数作为报错的名称</p>
<p>ps: 异常的处理是多样化的, 捕获异常(try-catch)和抛出异常(throws)只是两种方式,抛出异常一般处理自定义的异常<br>自定义异常<br>自定义一个自己编写的异常种类<br>语法: public class MyException extends Exception {}<br>ps: 注意要编写构造方法, 另外父类必须为Exception或者其它子类<br>pps: Exception构造方法输入参数作为报错的名称</p>
<br>

<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>目的: 用于推测出最初发生异常的位置<br>示例: 自定义一个异常(喝大了), 一个方法(test1)抛出自定义的异常, 另一个方法(test2)调用这个会抛出异常的方法(test1),捕获异常(喝大了)从而再抛出一个异常(运行时异常), 最后在其它方法调用后一个方法, 则形成了一个异常链(由喝大了引发的运行时异常)<br>ps: throw抛出异常之前必须先throws声明异常<br>pps: 异常使用initCase方法, 引用原始异常</p>
<br>

<h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><ol>
<li>运行时异常, 采用逻辑规避, 用try-catch辅助处理</li>
<li>多重catch块后面, 可以catch(Exception)处理可能遗漏的异常</li>
<li>try-catch,处理潜在的异常</li>
<li>积极根据业务需求和异常类型处理异常, 不要简单打印异常</li>
<li>尽量用finally语句释放占用的资源</li>
</ol>
<br>

<br>

<br>

<h2 id="C2-Java中的字符串"><a href="#C2-Java中的字符串" class="headerlink" title="C2-Java中的字符串"></a>C2-Java中的字符串</h2><h3 id="字符串什么"><a href="#字符串什么" class="headerlink" title="字符串什么"></a>字符串什么</h3><p><code>String</code>对象位于<code>java.lang</code>包中, 默认情况下该包自动导入所有的程序<br>创建<code>String</code>对象方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"imooc"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String();</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"imooc"</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="字符串的不变性"><a href="#字符串的不变性" class="headerlink" title="字符串的不变性"></a>字符串的不变性</h3><p><code>String</code>对象创建后不能修改, 只能直接改变指向的内存, 相当于整个变量对应的内容换掉<br>如果需要可以改变的字符串,可以使用<code>StringBuffer</code>或者<code>StringBuilder</code><br>每次<code>new</code>一个<code>String</code>就是一个新的对象, 所以<code>==</code>的结果为<code>flase</code>, 比较两个字符串内容是否相同时, 应该使用<code>equals()</code>方法, 注意区分<code>==</code>和<code>equals()</code></p>
<br>

<h3 id="String类常用的方法"><a href="#String类常用的方法" class="headerlink" title="String类常用的方法"></a><code>String</code>类常用的方法</h3><p><code>String</code>类提供了很多处理字符串的方法, 获取长度,截取字符串,字符串转换为大小写,字符串分割等等<br>可以参照菜鸟教程的<code>Java中String类</code>的说明:<br><a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-string.html</a><br>ps: <code>equals()</code>, <code>indexOf()</code>, <code>substring()</code>, <code>charAt()</code>用的比较多<br>pps: <code>==</code>判断两个对象内存的地址是否相同, <code>equals()</code>比较两个对象的内容是否相等<br>关于<code>getBytes()</code>方法, 由于汉字有两个字节而且会溢出, 所以转换后得到的字节数是两个负数, <code>asc码</code>则转化为一个数</p>
<br>

<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a><code>StringBuilder</code>类</h3><p>修改字符串时不会额外创建一个对象, <code>StringBuffer</code>是线程安全的, <code>StringBuilder</code>则没有但性能更高, 一般课表字符串对象优先考虑<code>StringBuilder</code><br>定义: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str1 = <span class="keyword">new</span> StringBuilder();  <span class="comment">// 参数""可选</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="StringBuilder类的常用方法"><a href="#StringBuilder类的常用方法" class="headerlink" title="StringBuilder类的常用方法"></a><code>StringBuilder类</code>的常用方法</h3><p><code>append()</code>, <code>inset()</code>方法比较常用<br>同样, 可以参照菜鸟教程:<br><a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-stringbuffer.html</a></p>
<br>

<br>

<br>

<h2 id="C3-Java中的常用类"><a href="#C3-Java中的常用类" class="headerlink" title="C3-Java中的常用类"></a>C3-Java中的常用类</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>为了让基本数据类型(<code>int</code> <code>double</code> <code>float</code>等)具备<strong>对象的特性</strong>, 如属性方法等, Java提供的<strong>类</strong>, (变量由一个数值变成对象)<br><br></p>
<h4 id="包装类主要提供两大方法"><a href="#包装类主要提供两大方法" class="headerlink" title="包装类主要提供两大方法:"></a>包装类主要提供两大方法:</h4><ol>
<li>将本类型和其它基本类型进行转换</li>
<li>将字符串和本类型即包装类互相转换</li>
</ol>
<br>

<br>

<h3 id="基本类型和包装类之间的转换"><a href="#基本类型和包装类之间的转换" class="headerlink" title="基本类型和包装类之间的转换"></a>基本类型和包装类之间的转换</h3><p>装箱: 把<strong>基本类型</strong>转换为包装类, 有<strong>手动装箱</strong>(<code>包装类 x = new 包装类(i)</code>)和<strong>自动装箱</strong>(<code>包装类 x = i</code>)<br>拆箱: 把<strong>包装类对象</strong>转换为<strong>基本类型</strong>, 也有手动(<code>int x = j.intValue()</code>)和自动(<code>int x = j</code>)  ps: <code>.intValue()</code>转为整数, <code>.doubleValue()</code>转为双精度<br>pps: 自动转换只能在一种基本类型和与之对应的包装类之间进行转换</p>
<br>

<h3 id="基本类型和字符串之间的转换"><a href="#基本类型和字符串之间的转换" class="headerlink" title="基本类型和字符串之间的转换"></a>基本类型和字符串之间的转换</h3><h4 id="基本类型转换为字符串"><a href="#基本类型转换为字符串" class="headerlink" title="基本类型转换为字符串:"></a>基本类型转换为字符串:</h4><ol>
<li>使用包装类的toString()方法</li>
<li>使用String类的valueOf()方法</li>
<li>用空字符串加上基本类型, 隐式转换为字符串</li>
</ol>
<br>

<h4 id="将字符串转换为基本类型"><a href="#将字符串转换为基本类型" class="headerlink" title="将字符串转换为基本类型:"></a>将字符串转换为基本类型:</h4><ol>
<li>调用包装类的<code>ParseXxx</code>静态方法  (比如: <code>int a = Integer.parseInt(str);</code>)</li>
<li>调用包装类的<code>valueOf()</code>方法转换为对应的包装类, 再自动拆箱  (比如: <code>int a = Integer.valueOf(str);</code>)</li>
</ol>
<br>

<br>

<h3 id="使用Date和SimpleDateFormat类表示时间"><a href="#使用Date和SimpleDateFormat类表示时间" class="headerlink" title="使用Date和SimpleDateFormat类表示时间"></a>使用<code>Date</code>和<code>SimpleDateFormat</code>类表示时间</h3><p><code>Date类</code>在<code>java.util</code>包中, 用于获取当前时间, <strong>默认无参构造方法初始化</strong><br><code>SimpleDateFormat类</code>在<code>java.text</code>包中, 可以将日期转换为指定格式的文本<br>示例:</p>
<ol>
<li><h4 id="使用format-转换日期的显示格式"><a href="#使用format-转换日期的显示格式" class="headerlink" title="使用format()转换日期的显示格式"></a>使用<code>format()</code>转换日期的显示格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String today = sdf.format(d);</span><br><span class="line">System.out.println(today);</span><br></pre></td></tr></table></figure>

<p><code>&quot;yyyy-MM-dd HH:mm:ss&quot;</code>指定日期格式, 读取时期, 把日期转化为指定的格式</p>
<p>“yyyy-MM-dd HH:mm:ss”指定日期格式, 读取时期, 把日期转化为指定的格式</p>
</li>
<li><h4 id="使用parse-方法将文本转换为日期"><a href="#使用parse-方法将文本转换为日期" class="headerlink" title="使用parse()方法将文本转换为日期"></a>使用<code>parse()</code>方法将文本转换为日期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String day = <span class="string">"2020年8月28日 11:48:16"</span></span><br><span class="line">SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">Date date = df.parse(day);</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure>

<p><code>parse</code>根据指定的格式<strong>反过来读取字符串, 从而获得日期</strong></p>
<p>ps: 调用<code>SimpleDateFormat</code>对象的<code>parse()</code>方法可能会出现<strong>转换异常</strong>, <code>ParseException</code>, 因此<strong>需要异常处理</strong><br>使用<code>Date类</code>需要导入<code>java.util</code>包, 使用<code>SimpleDateFormat类</code>需要导入<code>java.text</code>包</p>
<p>parse根据指定的格式反过来读取字符串, 从而获得日期<br>ps:<br>调用SimpleDateFormat对象的parse()方法可能会出现转换异常, ParseException, 因此需要异常处理<br>使用Date类需要导入java.util包, 使用SimpleDateFormat类需要导入java.text包</p>
<p><br><br></p>
</li>
</ol>
<h3 id="Calendar类的应用"><a href="#Calendar类的应用" class="headerlink" title="Calendar类的应用"></a><code>Calendar类</code>的应用</h3><p><code>Date类</code>只要用于获取当前时间, <strong>推荐使用<code>Calendar类</code>进行时间和日期的处理</strong><br><code>java.util.Calendar类</code>是一个<strong>抽象类</strong>, 可调用<code>getInstance()</code>静态方法获取<code>Calendar对象</code>, 如 <code>Calendar c = Calenar.getInstance();</code><br><br></p>
<h4 id="常用方法和属性"><a href="#常用方法和属性" class="headerlink" title="常用方法和属性:"></a>常用方法和属性:</h4><ol>
<li><code>Calendar类</code>有<code>YEAR</code>,<code>MONTH</code>,<code>DAY_OF_MONTH</code>等静态常量, </li>
<li>调用<code>getInstance()</code>获取一个实例, </li>
<li>调用<code>get()</code>方法获取日期信息, <code>getTime()</code>方法获取<code>Date对象</code>, </li>
<li>通过<code>getTimeInMillis()</code>方法获取<code>Calendar</code>时间值(以毫秒为单位)</li>
</ol>
<br>

<h3 id="使用Math类操作数据"><a href="#使用Math类操作数据" class="headerlink" title="使用Math类操作数据"></a>使用Math类操作数据</h3><p><code>java.lang.Math类</code>包含基本数学运算的方法, 因为所有方法都是<strong>静态方法</strong>, 所以可以直接按 ``类名.方法名` 使用<br><br></p>
<h4 id="可以参照一下菜鸟教程的相关介绍"><a href="#可以参照一下菜鸟教程的相关介绍" class="headerlink" title="可以参照一下菜鸟教程的相关介绍:"></a>可以参照一下菜鸟教程的相关介绍:</h4><p><a href="https://www.runoob.com/java/java-number.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-number.html</a></p>
<br>

<br>

<br>

<h2 id="C4-Java中的集合框架-上"><a href="#C4-Java中的集合框架-上" class="headerlink" title="C4  Java中的集合框架(上)"></a>C4  Java中的集合框架(上)</h2><h3 id="集合框架概述"><a href="#集合框架概述" class="headerlink" title="集合框架概述"></a>集合框架概述</h3><p><strong>容器的概念:</strong>  把若干种属性(数目, 种类不一定)存储起来, 就是集合, 是一种工具类存储共同属性种类的对象</p>
<h4 id="容器的作用"><a href="#容器的作用" class="headerlink" title="容器的作用:"></a>容器的作用:</h4><ol>
<li>在类的内部, 对组织数据</li>
<li>简单快速的都说大量条目</li>
<li>一个序列, 方便插入取出某些属性</li>
<li>有的集合提供了映射关系(类似py的字典), 方便了查询</li>
</ol>
<br>

<h3 id="java提供集合的接口"><a href="#java提供集合的接口" class="headerlink" title="java提供集合的接口"></a>java提供集合的接口</h3><ol>
<li><code>Collection</code>: <code>List</code> -<code>ArrayList</code>, <code>Set</code> -<code>HashSet</code>, <code>Queue</code> -<code>LinkedList</code>  (存储的元素是对象)</li>
<li><code>Map</code>: <code>HashMap</code> (存储的元素是键值对, <code>Entry</code>)</li>
</ol>
<br>

<br>

<h3 id="Collection接口-子接口和实现类-看看前面复习一下什么是接口"><a href="#Collection接口-子接口和实现类-看看前面复习一下什么是接口" class="headerlink" title="Collection接口, 子接口和实现类 (看看前面复习一下什么是接口)"></a>Collection接口, 子接口和实现类 (看看前面复习一下什么是接口)</h3><p>Collection集合中, 讲一下List子接口和Set子接口<br><br><br></p>
<h3 id="List接口："><a href="#List接口：" class="headerlink" title="List接口："></a>List接口：</h3><p>List接口的实现类-<code>ArrayList类</code>(类似python列表)<br><code>ArrayList</code>是<strong>数组</strong>序列, 接口和实现类的关系可以参照: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List test = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>

<br>

<h4 id="下面说明一下List增删改查用到的方法"><a href="#下面说明一下List增删改查用到的方法" class="headerlink" title="下面说明一下List增删改查用到的方法:"></a>下面说明一下List增删改查用到的方法:</h4><h4 id="为列表添加对象"><a href="#为列表添加对象" class="headerlink" title="+ 为列表添加对象:"></a>+ 为列表添加对象:</h4><p><code>&lt;ls&gt;.add()</code>方法可以把一个对象添加到List中,<br><code>&lt;ls&gt;.get()</code>方法可以根据索引从List中取出对象,<br>※ 使用add方法, 把对象存入集合时, 默认会变成Object类型.<br>※ 所以get方法取出对象时, 需要类型转化, 在前面加 (强转类型)<br><code>&lt;ls&gt;.add(index, element)</code>方法可以把对象添加到指定的位置<br>※ 如果index大于ls的长度, 会报错IndexOutOfBoundException<br><code>&lt;ls&gt;.addAll()</code>方法可以把一个List添加到ls中,<br><code>Arrays.asList()</code>方法可以把一个数组转化为一个List.<br><code>&lt;ls&gt;.addAll(index, List)</code> 可以指定List插入的位置</p>
<br>

<h4 id="为列表修改对象"><a href="#为列表修改对象" class="headerlink" title="+ 为列表修改对象:"></a>+ 为列表修改对象:</h4><h5 id="遍历列表的三个方法"><a href="#遍历列表的三个方法" class="headerlink" title="遍历列表的三个方法:"></a>遍历列表的三个方法:</h5><ol>
<li><p><code>&lt;ls&gt;.size()</code>方法可以取得List的长度, 用于遍历List;</p>
</li>
<li><p>通过迭代器遍历List, 使用<code>Iterator</code>接口, <code>Iterator it = &lt;ls&gt;.iterator()</code> 获取迭代器, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用while循环遍历List迭代器中的对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;&lt;Class&gt; temp = (Class) it.next();&#125;</span><br></pre></td></tr></table></figure>

<p>※ 集合都具有iterator方法, 迭代器依赖集合存在</p>
</li>
<li><p>使用<code>forEach</code>方法遍历List, 由于在没有指定泛型时, 对象存放在集合中, 会变成Object, 所以应该用 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object obj: &lt;ls&gt;) &#123;<span class="comment">// 记得使用类型强转&#125;.</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="修改List的元素"><a href="#修改List的元素" class="headerlink" title="修改List的元素"></a>修改List的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ls&gt;.set(index, element);  <span class="comment">// 把相应位置的对象修改成新的对象</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="为列表删除对象"><a href="#为列表删除对象" class="headerlink" title="+ 为列表删除对象:"></a>+ 为列表删除对象:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ls&gt;.remove(index);  <span class="comment">// 删除相应索引位置的元素, 不能超出长度范围</span></span><br><span class="line">&lt;ls&gt;.remove(element);  <span class="comment">// 删除指定的对象</span></span><br><span class="line">&lt;ls&gt;.removeAll(Collection ls)  <span class="comment">// 删除指定集合的所有元素, 类似求差</span></span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="使用泛型-Generic-为列表处理不是对象的变量-比如字符串等等"><a href="#使用泛型-Generic-为列表处理不是对象的变量-比如字符串等等" class="headerlink" title="使用泛型(Generic), 为列表处理不是对象的变量(比如字符串等等):"></a>使用泛型(Generic), 为列表处理不是对象的变量(比如字符串等等):</h3><p><code>&lt;ls&gt;.add(OtherClass)</code> 不会报错, 但是后面使用<code>forEach</code>打印的时候, 使用了<strong>强制类型转换</strong>, <code>String</code>不能转化为<code>Course</code>, 所以还是会报错. <strong>为了能够避免向集合加入其它类型的对象, 就要使用到泛型.</strong><br>※ 集合中的元素, 可以使用<strong>任意类型</strong>的对象(对象的引用), 把放入的对象当做<code>Object</code>处理; <strong>泛型</strong>则是规定了某个<strong>集合只可以存放特定类型</strong>的对象及其子类型的对象, 可以<strong>直接指定类型</strong>获取集合元素.<br><br></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Class&gt; ls;  <span class="comment">// 使用&lt;Class&gt;指定泛型类型, 界定符一般要使用private</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.ls = <span class="keyword">new</span> ArrayList&lt;Class&gt;();  <span class="comment">// 初始化的时候仍然需要指明泛型</span></span><br></pre></td></tr></table></figure>

<p>※ 此时<code>get()</code>方法或者遍历ls时, 不需要强制转换类型了<br>※ 指定泛型之后的集合, 还能存储泛型的<strong>子类型</strong>的对象实例, 即可以<code>&lt;ls&gt;.add(new 
ChildClass());</code><br>※ <strong>泛型只能使用引用类型</strong>, 不能使用基本类型(int,char …), 如果有必要也只能用包装类, 指定泛型为包装类之后<code>&lt;ls&gt;.add(temp)</code> 会对<u>基本类型temp变量</u>进行<strong>隐式</strong>类型转换 (比如 int 变成 Interger).<br><br></p>
<h4 id="Set接口："><a href="#Set接口：" class="headerlink" title="Set接口："></a>Set接口：</h4><p><code>Set</code>接口实现类–<code>HashSet类</code>(类似数学里面的集合)<br>※ Set<strong>无序</strong>并且<strong>不可重复</strong><br>※ Set接口同样提供<code>add()</code>, <code>remove()</code>, <code>removeAll()</code>, <code>size()</code>等方法.<br>※ 但是由于Set无序, 所以<u>不提供<code>set()</code>方法和<code>get()</code>方法</u>, 如果想要调用Set内部的元素, 可以使用<code>foreach</code>和<code>Iterator</code>的方式遍历Set, 不过要注意Set是无序的, 多次遍历的顺序会改变.<br>※ Set也可以使用泛型, 使用方法同Collection<br>※ Set中可以添加空对象null<br><br></p>
<br>

<br>

<h2 id="C5-Java中的集合框架-中"><a href="#C5-Java中的集合框架-中" class="headerlink" title="C5  Java中的集合框架(中)"></a>C5  Java中的集合框架(中)</h2><h3 id="Map-amp-HashMap"><a href="#Map-amp-HashMap" class="headerlink" title="Map &amp; HashMap"></a>Map &amp; HashMap</h3><p><code>Map接口</code>提供了映射关系(键值对), 键值对以<code>Entry类</code>存在, <code>key</code>不可重复, <code>Map</code>支持泛型 比如: <code>Map&lt;typeOfK, typeOfV&gt;</code><br><code>HashMap类</code>是<code>Map</code>的一个实现类, <code>HashMap</code>中的<code>Entry对象（单个键值对）</code>无序排列, 基于哈希表实现, <code>Key</code>和<code>value</code>值可以为null, 不过Key为null时不能重复.<br><br></p>
<h3 id="Map-的增删改查"><a href="#Map-的增删改查" class="headerlink" title="Map 的增删改查:"></a>Map 的增删改查:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;.get(Key);  <span class="comment">// 返回Key的索引结果, 没有找到Key则放回null</span></span><br><span class="line">&lt;map&gt;.put(Key, value);  <span class="comment">// 添加映射, 注意要符合原来定义的泛型</span></span><br><span class="line">&lt;map&gt;.size();  <span class="comment">// 返回map的容量</span></span><br><span class="line">&lt;map&gt;.keySet();  <span class="comment">// 返回map中所有key的Set集合</span></span><br></pre></td></tr></table></figure>

<p>※ keySet方法返回Set对象(有序)之后, 可以进一步用来遍历等操作<br>※ keyList()等方法的用法类似<br><br><br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;.remove(key);  <span class="comment">// 删除Map中的映射</span></span><br><span class="line">&lt;map&gt;.entrySet();  <span class="comment">// 返回所有键值对的Set集合</span></span><br></pre></td></tr></table></figure>

<p>※ 使用entrySet()返回的对象需要制定泛型, 比如: <code>Set&lt;Entry&lt;String, Student&gt;&gt; entrySet = students.entrySet();</code><br>※ 当一个类类型定义过泛型之后, 每次调用该类都要注意是否有写该类的泛型<br>※ <code>Entry</code>对象, 使用<code>getKey()</code>方法获取键, 使用<code>getValue()</code>方法获取值, 一个entry就是一个键值对<br><br></p>
<br>

<br>

<h2 id="C6-Java中的集合框架-下"><a href="#C6-Java中的集合框架-下" class="headerlink" title="C6  Java中的集合框架(下)"></a>C6  Java中的集合框架(下)</h2><h3 id="检测某个对象是否包含在序列内"><a href="#检测某个对象是否包含在序列内" class="headerlink" title="检测某个对象是否包含在序列内"></a>检测某个对象是否包含在序列内</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ls&gt;.contains(obj);  <span class="comment">// 检测一个List内是否包含对象obj, 存储的内容相同不代表对象相同</span></span><br></pre></td></tr></table></figure>

<p>※ <code>List</code>对象的<code>contains()</code>方法 相当于遍历序列, 把序列中的每一个元素使用一次<code>equals(obj)</code>, 进行判断, <code>equals方法</code>可以参照前面第二季的笔记<br>※ 可以通过重写(<code>@override</code>)<code>equals()</code>改变<code>contains()</code>的判断逻辑, 比如说比较两个对象的<code>name属性</code>是否相等, 从而找到序列中有相同name属性的元素<br>※ 使用<code>&lt;ls&gt;.containsAll(Collection&lt;?&gt; c)</code>可以实现检测一个序列内是否包含多个对象<br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;set&gt;.contains(obj);  <span class="comment">// 检测一个Set内是否包含对象obj</span></span><br></pre></td></tr></table></figure>

<p>※ 注意<code>Set</code>对象的<code>contains</code>方法, 会先调用<code>hashCode</code>方法。<strong>在判断两个对象的哈希码是否相同的情况下,  再调用equals方法判断两个对象的值是否相等</strong>.<br>※ 同样可以通过重写的<code>hashCode方法</code>和<code>equals方法</code>, 自定义的Set对象的contains方法.<br>※ <code>IDE</code>可以提供<code>hashCode</code>和<code>equals</code>方法的<em>重写模板</em><br><br></p>
<h3 id="获取序列中元素的位置"><a href="#获取序列中元素的位置" class="headerlink" title="获取序列中元素的位置"></a>获取序列中元素的位置</h3><p>使用<code>indexOf方法</code>，<em>获取序列中某元素的索引位置</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;collection&gt;.indexOf(sth1)</span><br></pre></td></tr></table></figure>

<h5 id="indexOf方法实现机制："><a href="#indexOf方法实现机制：" class="headerlink" title="indexOf方法实现机制："></a>indexOf方法实现机制：</h5><ol>
<li>遍历序列内部的元素，调用equals方法；</li>
<li>如果出现了相同的元素，就放回序列中首个对应元素的索引。</li>
<li>如果无匹配结果，则返回-1。<br>ps: 使用lastIndexOf方法，获取序列中某个元素最后一次出现的索引位置。</li>
</ol>
<br>

<h3 id="判断某个映射是否包含在Map内"><a href="#判断某个映射是否包含在Map内" class="headerlink" title="判断某个映射是否包含在Map内"></a>判断某个映射是否包含在Map内</h3><p>在<code>Map</code>中，使用<code>containsKey</code>方法，判断<code>Map</code>是否包含某个<code>Key</code>；使用<code>containsValue</code>方法判断是否包含某个<code>Value</code>值。返回<code>true</code> or <code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;.containsKey(Key)</span><br><span class="line">&lt;map&gt;.containsValue(Value)</span><br></pre></td></tr></table></figure>

<p>※ <code>containsValue</code>方法的实现机制类似于<code>set</code>对象中的<code>contains</code>方法，先调用<code>hashCode</code>方法再调用<code>equals</code>方法。所以一般也需要重写这两个方法。<br><br></p>
<h3 id="给List对象排序"><a href="#给List对象排序" class="headerlink" title="给List对象排序"></a>给List对象排序</h3><p><code>Collections工具类</code>（相当于Arrays工具类，提供特定功能的方法，需要<code>import</code>）<br><strong>使用sort方法，对<code>List&lt;Intiger, String&gt;</code>进行排序：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(ls)  <span class="comment">//默认升序排序，判断依据：整数的大小、字符串的靠前的字符的asc码。</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）："><a href="#给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）：" class="headerlink" title="给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）："></a>给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）：</h3><p>首先，直接使用<code>collections.sort(OtherObj)</code>会报错，因为<code>sort</code>方法只能给<code>Comparable</code>接口的实现类进行排序，而<code>OtherObj</code>不是<code>comparable</code>接口的实现类。</p>
<h4 id="Collections类提供的两个接口："><a href="#Collections类提供的两个接口：" class="headerlink" title="Collections类提供的两个接口："></a>Collections类提供的两个接口：</h4><ol>
<li>Comparable接口—-提供默认比较规则，实现类要实现compareTo方法，返回值的正负表示两个值的比较结果。</li>
<li>Comparator接口—-提供临时比较规则，实现类要实现compare方法。<br>所以想要给存储其它元素的<code>List</code>对象排序，需要给该对象提供<code>comparable</code>接口，重写对应的<code>compareTo</code>方法。<br>ps：重写<code>compareTo</code>方法时，_可以调用默认的<code>compareTo</code>方法，减少工作量_。（善用this指针）<br>※ 给存放<strong>数字字符串的List对象</strong>排序的时候（如：”45688”, “7856”），要注意排序依据还是靠前字符的asc码大小，因此”7856”会排在前面。<br>另外，<code>Collections</code>工具类提供了<code>sort</code>的重载方法。使用<code>Collection.sort(List, Comparator&lt;T&gt; c)</code>，按照<code>Comparator</code>的实现类定义的<code>compare</code>方法进行排序。注意这个实现类很可能是需要自己编写的。（回顾第二季多态中接口实现类的编写）</li>
</ol>
<br>

<br>

<h3 id="回顾本章："><a href="#回顾本章：" class="headerlink" title="回顾本章："></a>回顾本章：</h3><ol>
<li>集合分为Collection和Map接口</li>
<li>Collection代表序列，其子接口有List和Set<br>List的经典实现类是<code>ArrayList</code><br>Set的经典实现类是<code>HashSet</code></li>
<li>Map代表存储键值对的集合，键值对又叫做<code>Entry&lt;Key, Value&gt;</code><br>Map的子接口有<code>HashMap</code></li>
<li>Collections工具类的sort方法用于给序列排序，介绍了两个接口Comparable和Comparator</li>
</ol>
<br>

<br>

<h3 id="扑克牌小程序思路（洗牌发牌）"><a href="#扑克牌小程序思路（洗牌发牌）" class="headerlink" title="扑克牌小程序思路（洗牌发牌）"></a>扑克牌小程序思路（洗牌发牌）</h3><h5 id="功能描述："><a href="#功能描述：" class="headerlink" title="功能描述："></a>功能描述：</h5><ol>
<li>创建扑克牌—-List</li>
<li>玩家需要有手牌（扑克牌的集合）—-编写玩家类，属性：id、name、cardList</li>
<li>洗牌（打乱顺序）—-Collections.shuffle</li>
<li>发牌—-get(), add()</li>
<li>游戏（比较大小）—-sort(), compare()   </li>
</ol>
<br>

<br>

<br>

<h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>至此，本次java入门课程的笔记到此结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/23/入门JavaSE-进阶篇/" data-id="ckh7svs6x000820ujoea3y79e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习笔记/">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-为Windows-Terminal配置Ubuntu系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/为Windows-Terminal配置Ubuntu系统/" class="article-date">
  <time datetime="2020-09-21T12:19:20.000Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/为Windows-Terminal配置Ubuntu系统/">为Windows Terminal配置Ubuntu系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>最近掘金上看了一篇文章，简单介绍了安装WindowsTerminal以及LinuxUbuntu之后，进行基本配置改善shell外观。我原来也用过windows的ubuntu子系统，抱着改善一下shell外观的念头，大概跟着做了一下，遇到了一些问题，记录一下。</em></p>
<blockquote>
<p>文章链接：<a href="https://juejin.im/post/6865596788490338311" target="_blank" rel="noopener">https://juejin.im/post/6865596788490338311</a></p>
</blockquote>
<br>

<p>第一步，安装WindowsTerminal和Ubuntu是没有问题的。打开控制面板里面的Linux子系统功能也没有问题。另外说一下，我安装的是Ubuntu20.04，毕竟技术学新不学旧嘛。</p>
<p>微软商店安装完上面两个应用之后，打开WindowsTerminal，就可以选择Ubuntu窗口了。于是下一步，给ubuntu的软件源换上镜像源。</p>
<br>

<h2 id="关于linux的vi文本编辑器的使用方法"><a href="#关于linux的vi文本编辑器的使用方法" class="headerlink" title="关于linux的vi文本编辑器的使用方法"></a>关于linux的vi文本编辑器的使用方法</h2><p>在linux下可以使用vi或者vim，进行文本编辑。大名鼎鼎的vim自然不用说，vim和vi的基本操作基本一致，但是前者的特殊操作多得多而且非常复杂，我选择这次先学习一下vi。</p>
<p>找到了一篇指导博客，整理了Linux的文件编辑命令。<br>博客地址：<a href="https://blog.csdn.net/u013142781/article/details/50735470" target="_blank" rel="noopener">https://blog.csdn.net/u013142781/article/details/50735470</a></p>
<br>

<p>关于上面这篇博客简单概括一下。</p>
<p>vi编辑器有3种编辑模式：命令行模式、文本输入模式、末行模式。</p>
<p>使用vi命令打开文本之后，默认进入命令行模式。</p>
<p>命令行模式下，输入文本命令（i、l、a等等）会跳转至对应的文本输入模式，此时就可以开始文本编辑了。</p>
<p>文本输入模式下，按Esc回到命令行模式。</p>
<p>命令行模式下按：进入末行模式，使用不同的结束命令，完成对应的操作，退出vi。</p>
<br>

<p>举一个例子</p>
<p><em>比如说我要修改wsl的Ubuntu软件源。</em><br>首先，我要用vi打开软件源所在的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>然后，我要输入指定软件源的语句，于是按下i进入文本输入模式<br><code>i</code><br>接着，在合适的位置把复制的文本粘贴进去<br><code>Linux按右键粘贴</code><br>如果想要删除多行，可以在末行模式使用命令<br><code>：m, n de</code><br>即可删除m到n行的文本<br>最后，写入文件并且退出<br><code>:wq!</code></p>
<p>然后，我要输入指定软件源的语句，于是按下i进入文本输入模式<br>i<br>接着，在合适的位置把复制的文本粘贴进去<br>Linux按右键粘贴<br>如果想要删除多行，可以在末行模式使用命令<br>：m, n de<br>即可删除m到n行的文本<br>最后，写入文件并且退出<br>:wq!</p>
<br>

<p>关于软件源，这里列一下清华源（Ubuntu 20.04）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 预发布软件源，不建议启用</span><br><span class="line"><span class="meta">#</span> deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>关于这个软件源，我后面发现安装东西的时候出了些问题。</p>
<p><strong>这里备一份默认的软件源！</strong></p>
<p>另外，有一个恢复原来的源的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -ra /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>

<p>另另外，Ubuntu每个版本都有一个代号。比如20.04（LTS）版本的代号是Focal Fossa（专注的马达加斯加长尾狸猫）。代号可以用来区分Ubuntu的源的版本。有命令可以查看当前Ubuntu的代号（Description）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<p>github上找到的默认软件源：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.canonical.com/ubuntu focal partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu focal partner</span><br></pre></td></tr></table></figure>

<br>

<p>添加了软件源之后，开始安装shell终端，很简单 sudo apt install zsh 即可。</p>
<p>然后这里我遇到了一个小问题，系统提示找不到zsh这个包。搜索了一下，发现新装的Ubuntu需要更新下apt的repository cache。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>然后再安装即可~</p>
<p>参考文章：<a href="https://itsfoss.com/unable-to-locate-package-error-ubuntu/" target="_blank" rel="noopener">https://itsfoss.com/unable-to-locate-package-error-ubuntu/</a></p>
<br>

<h2 id="安装oh-my-zsh时，又遇到了一些问题。"><a href="#安装oh-my-zsh时，又遇到了一些问题。" class="headerlink" title="安装oh-my-zsh时，又遇到了一些问题。"></a><strong>安装oh-my-zsh时，又遇到了一些问题。</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</span><br></pre></td></tr></table></figure>

<p><strong>这里直接报错：github：443端口拒绝访问</strong></p>
<p>一开始，我以为是这个地址有问题。上github的ohMyZsh项目上看了一下，发现命令没有问题。<br>然后发现原来curl的地址被墙了……</p>
<p>但是我明明是开着梯子的，为啥就没法curl下来？？</p>
<p>原来shell窗口需要自己设置代理，根据另外一篇博客，终于解决了我的问题。<br>shell设置代理参考文章：<a href="https://zhuanlan.zhihu.com/p/115450863" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/115450863</a></p>
<br>

<p>简单来说就一个命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export https_proxy=socks5://127.0.0.1:10808 http_proxy=socks5://127.0.0.1:10808 all_proxy=socks5://127.0.0.1:10808</span><br></pre></td></tr></table></figure>

<p><strong>注意，这里的端口是自己的梯子开放的端口。</strong></p>
<br>

<p>在第一次配置代理的时候，我发现curl的时候被梯子拒绝了。发现是因为没有指明sock5协议。</p>
<p>由于我的梯子没有开放http协议的设置，我没办法设置http的端口。所以10808是我sock5协议开放的端口，需要事先说明协议。</p>
<p>注意，这里的端口是自己的梯子开放的端口。<br>在第一次配置代理的时候，我发现curl的时候被梯子拒绝了。后来发现，是因为没有指明sock5协议。由于我的梯子没有开放http协议的设置，我没办法设置http的端口。所以10808是我sock5协议开放的端口，需要事先说明协议。</p>
<p>另外如果想要恢复成原来的代理状态，可以参考</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unset https_proxy</span><br><span class="line">unset http_proxy</span><br><span class="line">unset all_proxy</span><br><span class="line">env|grep -I proxy</span><br></pre></td></tr></table></figure>

<p>最后一行是干什么我没弄清楚。</p>
<p>最后一行是干什么我没弄清楚。</p>
<br>

<p>安装了oh-my-zsh之后，shell界面终于有了飞跃，画面看上去简介了不少。<br>根据我们的指导文章，我们还要看一看<u>其它zsh主题</u>，把终端的颜值再弄上去一个层次。在 <code>/home/username</code> 目录下使用<code>vi ~/.zshrc</code> 发现<code>OhMyZsh</code>的<code>Plugins</code>只有<code>git</code>，没法选择主题。于是开始在TerminalSplash上看看热门主题。<br>地址：<a href="https://terminalsplash.com/" target="_blank" rel="noopener">https://terminalsplash.com/</a></p>
<br>

<p>terminalsplash上看到一个<strong>miku</strong>的主题，怦然心动。开始琢磨怎么把<del>纸片人老婆</del>miku弄到shell终端上。<br>根据Windows Terminal Miku项目github的readme，得知需要把profiles文件夹里的文件覆盖到windowsterminal的data文件内。<br>于是，我开始<strong>寻找Windowsterminal的文件夹位置</strong>。</p>
<br>

<p>传统的文件检索太慢，所以我使用了一个软件叫<strong>Eveything</strong>，很快找到了多个相关的文件夹。有的文件夹无法访问，需要修改一下文件目录的所有者。具体操作可以参照这篇：<a href="http://www.xitongcheng.com/jiaocheng/win10_article_11880.html。" target="_blank" rel="noopener">http://www.xitongcheng.com/jiaocheng/win10_article_11880.html。</a><br>经过一番排查，终于在<strong>packetges目录下</strong>找到的需要的文件。</p>
<br>

<p>但是，把profile文件复制到对应文件之后发现shell窗口<strong>没有任何变化</strong>。<br>通过查看其它介绍windowsterminal的文章，发现原来修改shell终端的外观，<strong>需要修改windowsterminal/LocalState/settings.json</strong>。于是通过复制miku主题的json相关代码到setting.json，并且在根目录复制对应文件之后，成功修改了shell的外观！<br>其它windowsterminal参考文章：<a href="https://my.oschina.net/u/4269669/blog/4437681" target="_blank" rel="noopener">https://my.oschina.net/u/4269669/blog/4437681</a></p>
<br>

<p>至此，终于安装好了wsl服务，并且修改了shell的外观。对于这个miku主题我还是很满意的。感谢原文章的作者提供的指引~</p>
<br>

<p>参考的github项目：</p>
<ol>
<li>oh-my-zsh:<br><a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh</a></li>
<li>windows-terminal-miku:<br><a href="https://github.com/DamourYouKnow/windows-terminal-miku" target="_blank" rel="noopener">https://github.com/DamourYouKnow/windows-terminal-miku</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/21/为Windows-Terminal配置Ubuntu系统/" data-id="ckh7svs6v000720ujlrhouvi9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WSL/">WSL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/搬运/">搬运</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/16/大数据架构作业-简答题1/" class="article-date">
  <time datetime="2020-09-16T08:10:58.000Z" itemprop="datePublished">2020-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/16/大数据架构作业-简答题1/">大数据架构作业--简答题1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>写在前面：最近选了大数据架构技术的课，开始学习云计算以及大数据平台的架构。于是记录一下课堂布置的一道作业题。</em></p>
<blockquote>
<p>作业题目：简要回答云计算的三类服务产品及各自的特点，调研各类云计算服务厂商及其产品, 给出产品列表, 说明各类产品的云服务类别,功能,特性,应用场景等。</p>
</blockquote>
<p>​     </p>
<h2 id="云计算的三类服务产品及各自的特点："><a href="#云计算的三类服务产品及各自的特点：" class="headerlink" title="云计算的三类服务产品及各自的特点："></a>云计算的三类服务产品及各自的特点：</h2><blockquote>
<p><strong>云计算按照服务类型可以分为三类：<code>Iaas</code>, <code>Paas</code>, <code>Saas</code>。</strong><br><code>Iaas</code> ：将基础设施作为服务，将硬件设备等基础资源封装成服务供用户使用。<br><code>Paas</code>：将平台作为服务，提供用户应用程序的运行环境。<br><code>Saas</code>：将软件作为服务，只提供某些专门用途的服务供应用调用。</p>
</blockquote>
<p>​     </p>
<h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><h3 id="一、弹性计算（Iaas）："><a href="#一、弹性计算（Iaas）：" class="headerlink" title="一、弹性计算（Iaas）："></a>一、弹性计算（Iaas）：</h3><ol>
<li>云服务器 ECS- 一种弹性可伸缩的计算服务</li>
<li>(高性能计算HPC)超级计算集群（Super Computing Cluster，SCC）- 使用高速RDMA网络互联的CPU以及GPU等异构加速设备，面向高性能计算、人工智能/机器学习、科学/工程计算、数据分析、音视频处理等应用，提供极致计算性能和并行效率的计算集群服务。</li>
<li>容器服务ACS- 提供高性能可伸缩的容器应用管理能力，支持企业级容器化应用的全生命周期管理。整合阿里云虚拟化、存储、网络和安全能力，打造云端最佳容器化应用运行环境。</li>
</ol>
<h3 id="二、存储服务（Iaas）："><a href="#二、存储服务（Iaas）：" class="headerlink" title="二、存储服务（Iaas）："></a>二、存储服务（Iaas）：</h3><ol>
<li>对象存储 OSS- 海量、安全、低成本、高可靠的云存储服务，提供99.9999999999%(12个9)的数据持久性。</li>
<li>块存储- 为云服务器ECS提供的低时延、持久性、高可靠的数据块级随机存储。块存储支持在可用区内自动复制您的数据，防止意外硬件故障导致的数据不可用，保护您的业务免于组件故障的威胁。</li>
</ol>
<h3 id="三、CDN与边缘服务（saas）："><a href="#三、CDN与边缘服务（saas）：" class="headerlink" title="三、CDN与边缘服务（saas）："></a>三、CDN与边缘服务（saas）：</h3><ol>
<li>CDN- 将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。</li>
<li>边缘节点服务（Edge Node Service, ENS）- 基于运营商边缘节点和网络构建，一站式提供“融合、开放、联动、弹性”的分布式算力资源，帮助用户业务下沉至运营商侧边缘，有效降低计算时延和成本。</li>
</ol>
<h3 id="四、数据库服务（Paas）："><a href="#四、数据库服务（Paas）：" class="headerlink" title="四、数据库服务（Paas）："></a>四、数据库服务（Paas）：</h3><p>云数据库专属集群MyBase- MyBase是阿里云专为企业级用户定制优化的解决方案，支持MySQL、PostgreSQL、SQL Server、Redis数据库。具有云资源独享、支持资源超分配，自主可运维、开放部分数据库和OS权限等特点。</p>
<p>​     </p>
<p>​     </p>
<h2 id="腾讯云产品"><a href="#腾讯云产品" class="headerlink" title="腾讯云产品"></a>腾讯云产品</h2><h3 id="一、腾讯云CVM服务器（Iaas）："><a href="#一、腾讯云CVM服务器（Iaas）：" class="headerlink" title="一、腾讯云CVM服务器（Iaas）："></a>一、腾讯云CVM服务器（Iaas）：</h3><p>为用户提供通用和标准的云虚拟机服务，同时依据不同的业务需求还提供GPU服务器，FPGA服务器，专用宿主机，黑石物理服务器等。</p>
<h3 id="二、腾讯云存储（Iaas）："><a href="#二、腾讯云存储（Iaas）：" class="headerlink" title="二、腾讯云存储（Iaas）："></a>二、腾讯云存储（Iaas）：</h3><p>包括对象存储、文件存储、归档存储、存储网关以及私有云存储服务。若企业要实现将文件存储到云端，那么就可以选择文件存储；如果企业的文件包括大量的视频和图片，就可以选择对象存储；而如果企业有将文档进行归档的需求，就可以选择归档存储，对需要实现本地和云端混合存储的企业，存储网关会是一个很好的选择，此外企业还可以根据需求选择私有云存储。</p>
<h3 id="三、腾讯云数据库（Paas）："><a href="#三、腾讯云数据库（Paas）：" class="headerlink" title="三、腾讯云数据库（Paas）："></a>三、腾讯云数据库（Paas）：</h3><p>提供<code>mysql</code> ，<code>sqlserver</code>  <code>mariaDB</code>， <code>postgresql</code> 等不同的数据库产品和数据库平台服务。</p>
<h2 id="亚马逊AWS"><a href="#亚马逊AWS" class="headerlink" title="亚马逊AWS"></a>亚马逊AWS</h2><p><em>主要类别：虚拟机服务、容器服务、非服务器服务、边缘和混合服务、成本和容器管理服务</em></p>
<h3 id="一、虚拟机服务：（Iaas）"><a href="#一、虚拟机服务：（Iaas）" class="headerlink" title="一、虚拟机服务：（Iaas）"></a>一、虚拟机服务：（Iaas）</h3><ol>
<li>Amazon Elastic Compute Cloud(EC2)- 一种Web服务, 可在云中提供安全并且可以调节大小的计算容量(虚拟服务器).</li>
<li>Amazon Lightsail- 易于使用的云平台，用于构建应用程序或网站</li>
</ol>
<h3 id="二、容器服务：（Iaas）"><a href="#二、容器服务：（Iaas）" class="headerlink" title="二、容器服务：（Iaas）"></a>二、容器服务：（Iaas）</h3><ol>
<li>Amazon Elastic Container Service (ECS)- 运行和管理Docker容器，运行容器的高度安全、可靠且可扩展的方式</li>
<li>Amazon Elastic Container Registry (ECR)- 存储和检索Docker镜像，轻松存储、管理和部署容器映像</li>
<li>Amazon Elastic Kubernetes Service (EKS)- 在AWS上运行托管的 Kubernetes，完全托管的 Kubernetes 服务</li>
</ol>
<h3 id="三、非服务器服务：（Iaas）"><a href="#三、非服务器服务：（Iaas）" class="headerlink" title="三、非服务器服务：（Iaas）"></a>三、非服务器服务：（Iaas）</h3><ol>
<li>AWS Lambda- 运行代码，无需预置或管理服务器，无需考虑服务器即可运行代码仅按消耗的计算时间付费</li>
<li>AWS Fargate- 无需管理服务器或集群即可运行容器，适用于容器的无服务器计算</li>
</ol>
<h3 id="四、边缘和混合服务："><a href="#四、边缘和混合服务：" class="headerlink" title="四、边缘和混合服务："></a>四、边缘和混合服务：</h3><ol>
<li>AWS Outposts- 完全托管的服务 可将AWS基础设施、AWS服务、API和工具扩展到几乎任何数据中心、共处空间或本地设施，以实现真正一致的混合体验，运行本地 AWS基础设施和服务以获得真正一致的混合体验</li>
<li>AWS Snow 系列- Snow系列由AWS Snowcone和AWS Snowball组成，可以提供各种具备内置计算功能的物理设备和容量点，用于收集和处理耐用环境或连接断开的边缘环境中的数据</li>
<li>AWS Wavelength- 构建能够为移动设备和最终用户交付低于10毫秒的延迟的应用程序，为5G设备交付超低延迟应用程序</li>
<li>VMware Cloud on AWS- 无需自定义硬件即可构建混合云，快速将 VMware 环境扩展、迁移到 AWS 云并予以保护</li>
<li>AWS 本地扩展区- 可以在特定区域以对最终用户和资源本地执行的方式轻松运行应用程序延迟敏感的部分，从而提供低于10毫秒的延迟，在更靠近最终用户的位置运行对延迟敏感的应用程序</li>
</ol>
<h3 id="五、成本和容器管理服务：（Iaas）"><a href="#五、成本和容器管理服务：（Iaas）" class="headerlink" title="五、成本和容器管理服务：（Iaas）"></a>五、成本和容器管理服务：（Iaas）</h3><ol>
<li>Amazon EC2 Spot- 充分利用 AWS 云中未使用的 EC2 容量。与按需实例的价格相比，使用 Spot 实例最高可以享受 90% 的折扣，运行容错工作负载，节省高达 90%</li>
<li>Amazon EC2 Autoscaling- 保持应用程序的可用性，根据您定义的条件自动添加或删除 EC2 实例，自动添加或删除计算容量以应对需求变化</li>
<li>AWS Batch- 运行任意规模的批处理作业，任意规模的完全托管式批处理</li>
<li>AWS Compute Optimizer- 确定最佳的 AWS 计算资源，为工作负载推荐最佳的 AWS 计算资源，以降低成本并提高性能</li>
<li>AWS Elastic Beanstalk- 运行和管理 Web 应用程序，易于使用的服务，可用于部署和扩展 Web 应用程序和服务</li>
<li>EC2 Image Builder- 构建和维护安全映像，构建和维护安全的 Linux 或 Windows Server 映像</li>
<li>Elastic Load Balancing- 通过确保可扩展性、性能和安全性，让任何应用程序都获得容错能力，在多个目标间自动分配传入的应用程序流量</li>
</ol>
<p>​      </p>
<p>​     </p>
<h2 id="微软Azure"><a href="#微软Azure" class="headerlink" title="微软Azure"></a>微软Azure</h2><h3 id="一、虚拟桌面服务：（Iaas）"><a href="#一、虚拟桌面服务：（Iaas）" class="headerlink" title="一、虚拟桌面服务：（Iaas）"></a>一、虚拟桌面服务：（Iaas）</h3><p>Windows 虚拟桌面- 在云中运行的综合桌面和应用虚拟化服务。它是提供简化管理、多会话 Windows 10、适用于企业的 Microsoft 365 应用优化和远程桌面服务 (RDS) 环境支持的唯一的虚拟桌面基础结构 (VDI)。只需几分钟即可在 Azure 上部署和扩展 Windows 桌面和应用，并获得内置的安全性和符合性功能</p>
<h3 id="二、存储服务：（Iaas）"><a href="#二、存储服务：（Iaas）" class="headerlink" title="二、存储服务：（Iaas）"></a>二、存储服务：（Iaas）</h3><ol>
<li>Avere vFXT for Azure- 先进的高性能计算让数据存储变得更快、更轻松，可以保护基础结构投资，同时轻松管理新需求。使用智能缓存以高效、经济实惠的方式灵活放置数据，无延迟地运行 NFS 和/或 SMB 工作负荷，并根据需求进行缩放。</li>
<li>Azure Data Lake Storage- 大规模可缩放且安全的数据湖，适用于高性能分析工作负载，使用单个存储平台消除数据孤岛。通过分层存储和策略管理优化成本。使用 Azure Active Directory (Azure AD) 和基于角色的访问控制 (RBAC) 对数据进行身份验证。借助静态加密和高级威胁防护等安全功能，帮助保护数据。</li>
</ol>
<h3 id="三、数据库服务：（Paas）"><a href="#三、数据库服务：（Paas）" class="headerlink" title="三、数据库服务：（Paas）"></a>三、数据库服务：（Paas）</h3><p>Azure Cache for Redis- 完全托管且兼容开源的内存中数据存储服务，为可缩放的高速应用程序提供支持。</p>
<h3 id="四、容器服务：（Iaas）"><a href="#四、容器服务：（Iaas）" class="headerlink" title="四、容器服务：（Iaas）"></a>四、容器服务：（Iaas）</h3><p>Azure Kubernetes 服务 (AKS)- 使用完全托管的 Kubernetes 服务，更轻松地部署和管理容器化应用程序。Azure Kubernetes 服务 (AKS) 提供无服务器 Kubernetes（一种整合的持续集成和持续交付 (CI/CD) 体验）以及企业级安全性和治理。将开发和运营团队统一到一个平台上，放心地快速生成、交付和缩放应用程序。</p>
<h3 id="五、弹性计算：（Iaas）"><a href="#五、弹性计算：（Iaas）" class="headerlink" title="五、弹性计算：（Iaas）"></a>五、弹性计算：（Iaas）</h3><ol>
<li>Azure 应用服务- 一个用于构建、部署和缩放 Web 应用的完全托管平台。根据自身情况快速构建、部署和缩放 Web 应用和 API。使用容器中或在 Windows/Linux 上 运行的 .NET、NET Core、Node.js、Java、Python 或 PHP。</li>
<li>Azure CycleCloud- 创建、管理、操作并优化任何规模的 HPC 和大型计算群集。</li>
</ol>
<p>​     </p>
<p>​     </p>
<h2 id="Google-Cloud产品："><a href="#Google-Cloud产品：" class="headerlink" title="Google Cloud产品："></a>Google Cloud产品：</h2><ol>
<li>Compute Engine-  可扩缩的高性能通用虚拟机。常见用途：业务线(LOB)应用、往回走哪托管、数据库、大多数工作负载。应用行业：教育、能源、金融、游戏、政府、医疗、生命科学、娱乐媒体、零售、电信。（Iaas）</li>
<li>Migrate for Compute Engine-  可将服务器和虚拟机迁移到Compute Engine的服务(原Velostrata)。常见用途：将应用从本地、多个数据中心或云端迁移到Google Cloud。（Iaas）</li>
<li>Cloud GPU-  可用于机器学习、科学计算和3D可视化的GPU硬件。常见用途：机器学习、医学分析、地震勘探、视频转码、图形可视化、科学模拟。应用行业：游戏、信息技术、生命科学、娱乐媒体。（Iaas）</li>
<li>抢占式虚拟机-  适合批处理作业和容错工作负载的短期运行计算实例，经济实惠。常见用途：短期运行或具备容错性的工作负载、金融建模、渲染、媒体转码、可制造性设计、Hadoop和大数据、持续集成、Web抓取。应用行业：能源、金融、医疗、娱乐媒体、制药。（Iaas）</li>
<li>安全强化型虚拟机-  更加安全的虚拟机。常见用途：抵御rootkit和bootkit攻击、保护企业工作负载、防范远程攻击、权限提升和恶意内部人员。应用行业：金融、物流、制造、娱乐媒体、零售、供应链。（Iaas）</li>
<li>单租户节点-  符合用户的法规遵从需求、许可需求和管理需求的专用硬件。常见用途：自带许可(BYOL)、工作股灾的专用计算能力、助力满足安全和合规需求、满足每个插槽或每个核心的许可需求、查看物理核心的使用情况信息。应用行业：金融、物流、制造、娱乐媒体、零售、供应链。（Iaas）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/16/大数据架构作业-简答题1/" data-id="ckh7svs7g000n20ujj6wbt7md" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/作业/">作业</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据架构/">大数据架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-入门JavaSE-中级篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/26/入门JavaSE-中级篇/" class="article-date">
  <time datetime="2020-08-26T09:58:24.000Z" itemprop="datePublished">2020-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/26/入门JavaSE-中级篇/">入门JavaSE-中级篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>刚看完中级篇的慕课，记录一下笔记。</p>
<h1 id="Javase入门-中级"><a href="#Javase入门-中级" class="headerlink" title="Javase入门 中级"></a>Javase入门 中级</h1><p><a href="https://www.imooc.com/learn/124" target="_blank" rel="noopener">https://www.imooc.com/learn/124</a></p>
<h2 id="C1-类和对象"><a href="#C1-类和对象" class="headerlink" title="C1 类和对象"></a>C1 类和对象</h2><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>类 对象  方法</p>
<h4 id="定义类-（属性-方法）"><a href="#定义类-（属性-方法）" class="headerlink" title="定义类 （属性 方法）"></a>定义类 （属性 方法）</h4><ol>
<li>定义类名(大写)  <code>public class 类名 {</code></li>
<li>属性也叫做实例变量   <code>// 定义属性 （默认为零）</code></li>
<li>方法                              <code>// 定义方法（参照上面，但不用写public等）}</code></li>
<li>ps：注意和 <code>public static void main {}</code> 的区别</li>
</ol>
<h4 id="使用对象的步骤："><a href="#使用对象的步骤：" class="headerlink" title="使用对象的步骤："></a>使用对象的步骤：</h4><ol>
<li>创建对象 <code>type name = new type();</code></li>
<li>调用对象 <code>name.***</code></li>
<li>ps: 同一个包的类，可以在不同的java文件中使用</li>
</ol>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>类中定义，描述对象的作用<br>作用在本类和其他类的方法 默认初始值为零</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在方法中定义，在方法中保存临时数据<br>只作用在本类的方法 不会有默认值</p>
<p>（其实就是作用域的不同）<br><strong>局部变量的优先级更高</strong></p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>ps: 使用 new+构造方法 创建一个新的对象 </p>
<p>构造方法的名称<strong>与类名相同</strong>，没有返回值<br>没有指定构造方法时，默认有一个“空”的构造方法<br>一旦指定了构造方法，系统就不会生成默认构造方法<br><strong>语法：</strong><code>public 构造方法名() {}</code><br>有无参数的构造方法都是可以并存的（重载）</p>
<h4 id="Java中的static-静态"><a href="#Java中的static-静态" class="headerlink" title="Java中的static(静态)"></a>Java中的static(静态)</h4><p><code>static</code>可以实现同一种<code>类</code>的多个<code>对象</code>共用同一个成员(属性)<br>定义：<code>static 类型 变量名 = ***;</code><br>ps: 静态成员可以直接用类名调用, 也可以用对象名调用 后面加<code>.</code>就行</p>
<p><strong>static修饰方法</strong>: 在返回值类型之前 加<code>static</code><br>如： <code>public static void main() {};</code></p>
<ul>
<li>静态方法中可以直接使用静态成员</li>
<li>静态方法调用非静态成员时，需要献出案件类的对象，在访问非静态变量</li>
<li>普通方法则能照抄使用所有成员</li>
<li>静态方法中能直接调用静态方法，非静态方法必须创建对象来访问</li>
</ul>
<p><strong>static 初始化块</strong><br>初始化块: 用于给已经定义了的变量初始化（赋值） 用<code>{}</code>框柱赋值的语句<br>ps：看上去有点low？<br>静态初始化块: 就是在{}前面加 static</p>
<h2 id="C2-封装"><a href="#C2-封装" class="headerlink" title="C2 封装"></a>C2 封装</h2><p>ps 面向对象三大特性： 封装、 继承、 多态<br><strong>封装</strong>：将类的概念隐藏在内部，不允许外部程序访问，通过类的方法，操作和访问隐藏概念</p>
<h4 id="封装的步骤："><a href="#封装的步骤：" class="headerlink" title="封装的步骤："></a>封装的步骤：</h4><ol>
<li>在变量的变量类型前面加 private</li>
<li>创建getter/setter 等类似方法访问属性，返回需要的变量（相当于一个接口）可以用ide自动生动生成</li>
<li>给上述方法加合理性判断（if语句等）</li>
</ol>
<h4 id="使用包管理java类"><a href="#使用包管理java类" class="headerlink" title="使用包管理java类"></a>使用包管理java类</h4><p>包的作用： 管理Java文件、解决同名文件冲突<br>定义包：<code>package &lt;包名&gt;;</code>  放在源程序第一行，包名之间用<code>.</code>隔开，相当于文件层次<br>使用包： <code>import &lt;包名&gt;;</code> 后面加<code>*</code>表示导入子目录的所包<br>ps: 包一般使用 全小写 命名</p>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><table>
<thead>
<tr>
<th align="center">访问范围</th>
<th align="center">本类</th>
<th align="center">同包</th>
<th align="center">子类</th>
<th align="center">其它</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>this代表当前对象，封装对象属性的时候经常使用</p>
<ol>
<li>区分属性和参数的概念（同名区分）</li>
<li>调用当前对象的方法    </li>
</ol>
<h4 id="内部类-Inner-Class"><a href="#内部类-Inner-Class" class="headerlink" title="内部类 Inner Class"></a>内部类 Inner Class</h4><p>定义：一个类内部，再定义类，提供更好的封装（套娃）<br>种类：成员、静态、方法、匿名内部类</p>
<p><strong>成员内部类</strong> 也叫做普通内部类<br>初始化的时候要用 ``&lt;内部类&gt; &lt;对象名&gt; = &lt;外部类&gt;.new &lt;内部类()&gt;<code>成员内部类可以使用外部和内部的所有数据，但外部类不能使用内部成员，如果内外部有同名的变量，内部需要使用外部变量时，需要</code>this<code>关键字(</code>Outer.this.变量名<code>)
ps: 编译程序之后会出现多个</code>.class`文件</p>
<p><strong>静态内部类</strong><br>用static修饰的内部类<br>不能直接访问外部类的 非静态成员，通过 <code>new Outer().成员</code> 访问<br>如果内外部静态成员<strong>同名</strong>，可以通过 <code>Outer.静态成员</code> 访问外部 静态成员，而是不用this关键字<br>创建静态内部类对象的时候，<code>&lt;内部类&gt; &lt;对象名&gt; = new &lt;内部类()&gt;</code> 即可</p>
<p><strong>方法内部类</strong><br>内部类定义在外部类的方法中，只在该方法类可以使用</p>
<h2 id="C3继承"><a href="#C3继承" class="headerlink" title="C3继承"></a>C3继承</h2><h4 id="Java中的继承"><a href="#Java中的继承" class="headerlink" title="Java中的继承"></a>Java中的继承</h4><p>类与类的关系，Java使用单继承，一个子类只有一个父类<br>子类拥有父类的所有属性和方法（<strong>不能是private</strong>）<br>语法： <code>class 子类 extends 父类</code> </p>
<h4 id="Java中方法的重写"><a href="#Java中方法的重写" class="headerlink" title="Java中方法的重写"></a>Java中方法的重写</h4><p>子类可以<strong>重写</strong>继承父类的方法<br>ps: 重写的方法对应的 返回值 方法名 参数列表种类顺序 要和父类相同</p>
<h4 id="继承的初始化顺序"><a href="#继承的初始化顺序" class="headerlink" title="继承的初始化顺序"></a>继承的初始化顺序</h4><p>先初始化父类在初始化子类<br>先进行<strong>属性</strong>的初始化，再进行<strong>构造方法</strong>的初始化（同一变量定义时的赋值会被构造方法的赋值覆盖掉）</p>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>可以修饰类、方法、属性、变量</p>
<ul>
<li>修饰类 该类不能被继承</li>
<li>修饰方法 该方法不能被重写</li>
<li>修饰属性 属性只能在在构造方法或者显示初始化（不能默认隐式初始化）</li>
<li>修饰变量 该变量只能被赋值一次 常量</li>
</ul>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>对象内部使用，可以代表父类对象，用于访问父类对象的属性和方法<br>语法: <code>super.&lt;父类的属性和方法&gt;</code><br><strong>super的应用</strong></p>
<ol>
<li>子类的构造过程中必须调用父类的构造方法 </li>
<li>super();隐式表达  显示表达要放在子类的构造方法的第一行</li>
<li>系统默认调用无参父类构造方法，如果没有无参构造方法，则报错</li>
</ol>
<h4 id="Java的Object类"><a href="#Java的Object类" class="headerlink" title="Java的Object类"></a>Java的Object类</h4><p>Object类是所有类的父类，默认的继承类（没有指定继承对象）<br><strong>Object类定义的属性方法</strong></p>
<ol>
<li><code>toString()</code> 返回对象的哈希code码（内存地址），可以重写成返回对象的属性，ide Source提供了toString的快速重写</li>
<li><code>equals()</code> 比较对象是否指向同一块内存地址，可以重写成比较两个对象的值是否相等，同样ide 提供了快速重写 (利用”==”)<br>ps: 默认的参数是Object obj，访问对象的属性的时候，需要声明为当前对象的类型 (Dog other = (Dog) obj;)<br>pps: 类对象指obj.getClass() 返回类的类型，类的对象指obj类的变量值</li>
</ol>
<h2 id="C4多态"><a href="#C4多态" class="headerlink" title="C4多态"></a>C4多态</h2><h4 id="Java中的多态"><a href="#Java中的多态" class="headerlink" title="Java中的多态"></a>Java中的多态</h4><p><strong>对象的多种形态:</strong> </p>
<ol>
<li>引用多态 父类的对象可以引用本类和子类的对象，反则不行。 (相当于可以用bus初始化交通工具对象 Transp obj = new bus();)</li>
<li>方法多态 创建本类对象时调用本类的方法，引用子类的对象是调用子类重写或者继承之后的方法</li>
</ol>
<h4 id="多态的引用类型转换"><a href="#多态的引用类型转换" class="headerlink" title="多态的引用类型转换"></a>多态的引用类型转换</h4><p>引用类型转换:</p>
<ol>
<li>向上类型转换(隐式/自动 小到大) 上面的父类引用子类对象</li>
<li>向下类型转换(大到小) 有风险 可以加 (类型) 强制类型转换</li>
<li>使用<code>instanceof</code>运算符 避免引用类型转换的安全性问题<br>如: <code>if (animal instanceof Cat) {Cat cat = (Cat) animal}</code> (向下转换)</li>
</ol>
<h4 id="Java的抽象类"><a href="#Java的抽象类" class="headerlink" title="Java的抽象类"></a>Java的抽象类</h4><p>关注子类应该有什么方法，不关注方法的实现，只关注子类的特征<br>抽象类的规则:</p>
<ol>
<li>abstract定义抽象类 public abstract class Obj{};</li>
<li>abstract定义方法，只有声明</li>
<li>抽象类可包含普通方法，可没有抽象方法</li>
<li>抽象类不能直接创建，可以定义引用变量</li>
</ol>
<h4 id="Java的接口"><a href="#Java的接口" class="headerlink" title="Java的接口"></a>Java的接口</h4><p>类是具体实体，接口是类需要遵守的<strong>规范</strong>，提供抽象方法和常量，把具有共同特征的类联系在一起<br>定义: <code>[修饰符] interface 接口名 [extends 父接口1, 父接口2 ...] {}</code><br>系统隐式添加<code>abstract</code>关键字 接口的内容为若干个常量<code>public static final</code>或者若干个抽象方法 <code>public abstract</code><br>调用接口: 类通过<code>implements</code>关键字使用多个接口 ※关键字接在父类的后面<br>ps: 接口命名通常名字前面加 <code>I</code><br>使用接口： 接口可以指向对象，如  <code>IPlayGame ip1 = new SmartPhone();</code> ，即可使用该类的方法，但是要注意指向的类要调用了该接口<br>ps: <strong>接口经常和匿名内部类使用，匿名内部类就是没有名字的内部类</strong><br><strong>语法格式:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Interface i = <span class="keyword">new</span> Interface()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> noid <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"匿名内部类实现接口的方式"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">i.method();  <span class="comment">// 直接调用方法</span></span><br></pre></td></tr></table></figure>

<p>也可以在new语句后面的分号之前，直接<code>.method()</code>调用方法</p>
<p>可以在new语句后面的分号之前，直接<code>.method()</code>调用方法</p>
<h4 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h4><p>编写代码之前设计代码，支持模型化和软件系统开发的图形化语言<br><strong>常用UML图</strong></p>
<ol>
<li>用例图 对象需要的功能</li>
<li>序列图 事件的发生顺序，对象的交互</li>
<li>类图 业务逻辑 类和类的关系</li>
</ol>
<p><strong>UML建模工具</strong></p>
<p>Visio、Rational、Rose…</p>
<h2 id="C5阶段练习"><a href="#C5阶段练习" class="headerlink" title="C5阶段练习"></a>C5阶段练习</h2><p>利用继承和重写实现中国人和美国人对象讲不同的语言</p>
<h2 id="C6综合练习"><a href="#C6综合练习" class="headerlink" title="C6综合练习"></a>C6综合练习</h2><p>项目分析：<br>    数据模型分析 抽象实体分析约束条件<br>    业务模型分析 需要实现的功能 如何实现<br>    显示和流程分析 划分显示部分，分析不同流程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/26/入门JavaSE-中级篇/" data-id="ckh7svs75000d20ujit8qo5s7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WSL/">WSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/frp/">frp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssl证书/">ssl证书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/作业/">作业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网穿透/">内网穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图像处理/">图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据架构/">大数据架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习笔记/">学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搬运/">搬运</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程/">教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概要/">概要</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科普/">科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/WSL/" style="font-size: 13.33px;">WSL</a> <a href="/tags/frp/" style="font-size: 10px;">frp</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/ssl证书/" style="font-size: 10px;">ssl证书</a> <a href="/tags/作业/" style="font-size: 20px;">作业</a> <a href="/tags/内网穿透/" style="font-size: 10px;">内网穿透</a> <a href="/tags/图像处理/" style="font-size: 10px;">图像处理</a> <a href="/tags/大数据架构/" style="font-size: 20px;">大数据架构</a> <a href="/tags/学习笔记/" style="font-size: 10px;">学习笔记</a> <a href="/tags/搬运/" style="font-size: 13.33px;">搬运</a> <a href="/tags/教程/" style="font-size: 10px;">教程</a> <a href="/tags/概要/" style="font-size: 10px;">概要</a> <a href="/tags/科普/" style="font-size: 10px;">科普</a> <a href="/tags/笔记/" style="font-size: 13.33px;">笔记</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/06/使用SpringBoot编写一个https网站/">使用SpringBoot编写一个https网站</a>
          </li>
        
          <li>
            <a href="/2020/11/05/大数据架构作业-简答题4/">大数据架构作业-简答题4</a>
          </li>
        
          <li>
            <a href="/2020/11/04/大数据架构作业-简答题3/">大数据架构作业-简答题3</a>
          </li>
        
          <li>
            <a href="/2020/10/08/学习内网穿透/">学习内网穿透</a>
          </li>
        
          <li>
            <a href="/2020/09/27/WSLinux之Ubuntu-安装rpm包/">WSLinux之Ubuntu安装rpm包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Miaopashi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>