<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>MPS的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="MPS的个人博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="MPS的个人博客">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MPS的个人博客">
  
    <link rel="alternate" href="/atom.xml" title="MPS的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MPS的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-学习内网穿透" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/08/学习内网穿透/" class="article-date">
  <time datetime="2020-10-08T02:12:54.000Z" itemprop="datePublished">2020-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/08/学习内网穿透/">学习使用frp工具实现内网穿透</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="需要设备"><a href="#需要设备" class="headerlink" title="需要设备"></a>需要设备</h2><ol>
<li>学校分发的虚拟机</li>
<li>一个云服务器</li>
</ol>
<br>

<h2 id="熟悉云服务器"><a href="#熟悉云服务器" class="headerlink" title="熟悉云服务器"></a>熟悉云服务器</h2><p>学生优惠购买了一个实例<br>设置实例密码<br>使用<strong>vnc</strong>链接服务器，发现<strong>login incorrect</strong>，原来是实例密码跟服务器密码不一样，要自己设置一个…<br>通过阿里云的控制台修改服务器密码，重启机子，然后就可以链接啦~<br>后面了解到可以使用<strong>Xshell</strong>代替<strong>workbench</strong>链接到自己的服务器，这个教程很多随便百度都能找到<br><strong>ps:</strong> 通过下文问题一了解到，阿里云服务器通过在控制台设置安全组开启端口。</p>
<br>

<br>

<h2 id="下面正式学习frp"><a href="#下面正式学习frp" class="headerlink" title="下面正式学习frp"></a>下面正式学习frp</h2><h4 id="frp学习参考文章："><a href="#frp学习参考文章：" class="headerlink" title="frp学习参考文章："></a>frp学习参考文章：</h4><ol>
<li><a href="https://sspai.com/post/52523" target="_blank" rel="noopener">https://sspai.com/post/52523</a> =  –”少数派”的博客</li>
<li><a href="https://gofrp.org/" target="_blank" rel="noopener">https://gofrp.org/</a>  –<strong>frp</strong>的官方文档</li>
</ol>
<br>

<h4 id="安装go环境："><a href="#安装go环境：" class="headerlink" title="安装go环境："></a>安装go环境：</h4><p>直接下载<strong>go</strong>对应的版本：<a href="https://golang.org/dl/go1.15.2.linux-amd64.tar.gz" target="_blank" rel="noopener">https://golang.org/dl/go1.15.2.linux-amd64.tar.gz</a><br>也可以使用<strong>wget</strong>命令直接在终端下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.15.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong> 如果想通过<strong>wget</strong>命令下载，貌似需要提前安装git和<strong>gcc</strong>，参考文章1<br>然后参考文章2的提示，通过<code>tar</code>和<code>export</code>命令，完成<strong>go</strong>的安装<br>参考的文章：</p>
<ol>
<li><a href="https://www.jianshu.com/p/21dc1bcf382e" target="_blank" rel="noopener">https://www.jianshu.com/p/21dc1bcf382e</a></li>
<li><a href="https://golang.org/doc/install#requirements" target="_blank" rel="noopener">https://golang.org/doc/install#requirements</a></li>
</ol>
<br>

<h4 id="下载frp"><a href="#下载frp" class="headerlink" title="下载frp"></a>下载frp</h4><p>使用<strong>wget</strong>命令下载<strong>frp</strong>的最新版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.34.0/frp_0.34.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong> 下载的版本错了可以使用rm命令删除，详见博客1<br><strong>pps:</strong> <strong>wget</strong>命令好像跟<strong>yum</strong>命令不一样，配置软件源没有什么用，想配置的可以参考一下博客2<br>参考的博客：</p>
<ol>
<li><a href="https://blog.csdn.net/sqbzo/article/details/8990404" target="_blank" rel="noopener">https://blog.csdn.net/sqbzo/article/details/8990404</a></li>
<li><a href="https://www.jianshu.com/p/541c737bc947" target="_blank" rel="noopener">https://www.jianshu.com/p/541c737bc947</a></li>
</ol>
<br>

<h4 id="启动frps-配置frps端"><a href="#启动frps-配置frps端" class="headerlink" title="启动frps(配置frps端)"></a>启动frps(配置frps端)</h4><p>内网穿透是把自己的终端穿透到有公网ip的服务器上的技术，这里我们先配置<strong>VPS</strong>（有公网ip的服务器），也就是<strong>frps</strong>端，这里我使用了阿里的服务器<br>先使用<strong>tar</strong>命令解压刚下载的frp：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.34.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后cd进该目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.34.0_linux_amd64</span><br></pre></td></tr></table></figure>

<p>检查文件发现目录内除了<strong>fprs</strong>文件还有<strong>frpc</strong>文件，使用rm命令将<strong>frpc</strong>文件一一删除<br>然后修改<strong>frps.ini</strong>文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim frps.ini</span><br></pre></td></tr></table></figure>

<p>文件格式大致如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">vhost_http_port = 10080</span><br><span class="line">vhost_https_port = 100443</span><br><span class="line">dashboard_port = 7500</span><br><span class="line">token = ******</span><br><span class="line">dashboard_user = ms</span><br><span class="line">dashboard_pwd = ********</span><br></pre></td></tr></table></figure>

<p>编辑完成之后保存:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p>然后启动<strong>frps：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>

<p>出现<strong>start</strong>字样，说明<strong>frps</strong>服务启动成功</p>
<br>

<h4 id="问题一：x-x-x-xxx-7500无法连接至控制页面"><a href="#问题一：x-x-x-xxx-7500无法连接至控制页面" class="headerlink" title="问题一：x.x.x.xxx:7500无法连接至控制页面"></a>问题一：x.x.x.xxx:7500无法连接至控制页面</h4><p>运行<strong>frps</strong>之后，使用浏览器访问对应的地址无响应…<br>根据博客2，发现原来是防火墙没有开放服务器指定的端口！<br>查看端口是否开放: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=7500/tcp --zone=public</span><br></pre></td></tr></table></figure>

<p>如果端口开放了就返回<strong>yes</strong>，反则返回<strong>no</strong><br>但是，我返回的是<strong>FirewallD is not running</strong>…<br>百度找到博客3，发现原来服务器没有打开防火墙！<br>根据blog3打开防火墙：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system start firewalld</span><br></pre></td></tr></table></figure>

<p>打开7500端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=7500/tcp</span><br></pre></td></tr></table></figure>

<p>这次再使用<strong>firewall-cmd</strong>命令看端口是否开放，返回的结果居然是<strong>no</strong>…<br>再次百度，根据博客1，发现阿里的服务器需要<strong>另外设置安全组</strong>才能开放相关的端口！<br>根据博客1设置安全组，开放2000到20000的端口<br>重启服务器之后，再次打开防火墙，开放7500端口<br>再次使用<strong>firewall-cmd</strong>检查，这次终于返回yes了<br>访问<strong>x.x.x.xxx:7500</strong>，输入用户密码，成功访问<strong>frp</strong>管理网页！<br>后话：后面配置<strong>frpc</strong>的时候居然要关闭防火墙，所以前面根据博客3和博客2关于防火墙和端口的修改其实没有什么必要，直接使用阿里云的控制平台开放端口才是正解！<br>参考的博客：</p>
<ol>
<li><a href="https://blog.csdn.net/weferxe/article/details/104777838" target="_blank" rel="noopener">https://blog.csdn.net/weferxe/article/details/104777838</a>  –设置阿里云安全组</li>
<li><a href="https://koolshare.cn/forum.php?mod=viewthread&amp;tid=137536&amp;page=1&amp;extra=" target="_blank" rel="noopener">https://koolshare.cn/forum.php?mod=viewthread&amp;tid=137536&amp;page=1&amp;extra=</a>  –开放端口的命令</li>
<li><a href="https://www.cnblogs.com/rxbook/p/8110143.html" target="_blank" rel="noopener">https://www.cnblogs.com/rxbook/p/8110143.html</a>  –控制<strong>linux</strong>的防火墙</li>
</ol>
<br>

<h4 id="使用nohup挂起frps进程"><a href="#使用nohup挂起frps进程" class="headerlink" title="使用nohup挂起frps进程"></a>使用nohup挂起frps进程</h4><p>目前关闭<strong>shell</strong>窗口之后，现在的<strong>frps</strong>进程就会结束<br>为了让<strong>frps</strong>和<strong>frpc</strong>两端一直穿透，需要把<strong>frps</strong>进程挂到后台<br>参考博客1，使用<strong>nohup</strong>命令把进程移动到后台:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure>

<p>同理，后面<strong>frpc</strong>端也要使用nohup挂起进程<br>参考的博客：</p>
<p>同理，后面frpc端也要使用nohup挂起进程<br>参考的博客：</p>
<ol>
<li><a href="https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/</a> –这篇博客还介绍了后台进程的关闭等事项</li>
</ol>
<br>

<h4 id="启动frpc-配置frpc端"><a href="#启动frpc-配置frpc端" class="headerlink" title="启动frpc(配置frpc端)"></a>启动frpc(配置frpc端)</h4><p>上面配置好了<strong>frps</strong>端，下面再配置<strong>frpc</strong>端之后就能实现穿透了！<br>这里我使用学校机房分发的一台虚拟机，作为<strong>frpc</strong>端，同样需要实现安装golang和<strong>frp</strong><br>下载完<strong>frp</strong>的安装包之后，和<strong>frps</strong>端类似，tar解压，然后删除f<strong>rps</strong>文件<br>使用vim命令修改frpc.ini:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure>

<p>文件的格式大致如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line">token = ******</span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = x.x.x.x</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 这里的<strong>local_port</strong>是指frpc机子上<strong>web</strong>进程使用的端口; custom_domains是<strong>frps</strong>端的<strong>ip地址</strong>或者域名，由于我还没买域名，所以这里就填了自己的ip<br>保存之后启动进程: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></table></figure>

<p>进程正常启动，和<strong>frps</strong>端类似，使用nohup把进程挂起，<strong>frpc</strong>端配置就完成了！</p>
<br>

<h4 id="编写一个最简单的web"><a href="#编写一个最简单的web" class="headerlink" title="编写一个最简单的web"></a>编写一个最简单的web</h4><p>现在<strong>frpc</strong>端已经配置完成，还需要写一个web测试一下，<strong>web</strong>服务能否被正常访问<br>远程控制学校分配的虚拟机，使用<strong>python</strong>的flask框架编写一个简单的应用</p>
<br>

<p>安装<strong>python3</strong>和<strong>pip3</strong><br>安装<strong>python3</strong>直接<strong>yum</strong>即可，安装<strong>pip3</strong>可以参照一下文章1<br>使用<strong>pip</strong>安装<strong>flask</strong>： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i [清华源] flask</span><br></pre></td></tr></table></figure>

<p>使用清华源安装<strong>flask</strong>快一点，详细参照文章2<br>完成上面的安装之后就可以开始编写<strong>web</strong>了！<br>参考文章：</p>
<ol>
<li><a href="https://blog.csdn.net/jamieblue1/article/details/89208151" target="_blank" rel="noopener">https://blog.csdn.net/jamieblue1/article/details/89208151</a>  –安装pip</li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a>  –清华</li>
</ol>
<br>

<h4 id="编写app-py"><a href="#编写app-py" class="headerlink" title="编写app.py"></a>编写app.py</h4><p>临时创建一个文件夹<strong>test_flask</strong>，存放app.py<br>根据<strong>flask</strong>的官方文档，文章1，编写一个只返回<strong>‘frp sucess!!!’</strong>的简单应用<br><strong>vim app.py:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'frp sucess!!!'</span></span><br></pre></td></tr></table></figure>

<p>然后保存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p>启动web:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=app.py</span><br><span class="line">python3 -m flask run</span><br></pre></td></tr></table></figure>

<p>然后使用自己的机子访问<strong>x.x.x.x:10080</strong>，显示<strong>‘frp sucess!!!’</strong>，说明内网穿透成功！</p>
<p>参考文章：</p>
<ol>
<li><a href="https://dormousehole.readthedocs.io/en/latest/quickstart.html#id2" target="_blank" rel="noopener">https://dormousehole.readthedocs.io/en/latest/quickstart.html#id2</a></li>
</ol>
<br>

<br>

<p>结语：<br>内网穿透技术可以很好地解决<strong>VPS</strong>配置不足的问题，由于学校机房分配了3台虚拟机，我才想借机利用一下，才学习了<strong>frp</strong>。但是在学习的中途我越发觉得这个技术对于学生来说，能够提供很大的便利，于是把学习的过程记录下来，希望能够帮助到其他人。<br>以后想学习一下<strong>nignx</strong>，尝试一下能否把多个域名映射到一台<strong>VPS</strong>的不同端口，进而穿透到不同的机子，提供多个服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/08/学习内网穿透/" data-id="ckvkw0ou5001kasujkpjunibs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-WSLinux之Ubuntu-安装rpm包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/27/WSLinux之Ubuntu-安装rpm包/" class="article-date">
  <time datetime="2020-09-27T02:28:09.000Z" itemprop="datePublished">2020-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/27/WSLinux之Ubuntu-安装rpm包/">Windows Subsystem for Linux之Ubuntu安装rpm包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在看<strong>《springboot实战》</strong>。</p>
<p>看到<strong>springbootCLI</strong>的时候，想要在<strong>windos</strong>子系统的<strong>Ubuntu</strong>上学习一下，所以想要安装<strong>java</strong>。</p>
<p>从同学那里要到了rpm包之后，发现<strong>Ubuntu</strong>居然不能直接安装<strong>rpm</strong>包！</p>
<p>查看社区发现<strong>Ubuntu</strong>是基于<strong>Debian</strong>的系统，不同于<strong>CentOS, RHEL or Fedora</strong>。</p>
<p><strong>Ubuntu</strong>不能直接使用<strong>rpm</strong>命令，而是要通过<strong>alien命令</strong>。</p>
<br>

<h2 id="安装alien可分为三个步骤："><a href="#安装alien可分为三个步骤：" class="headerlink" title="安装alien可分为三个步骤："></a>安装alien可分为三个步骤：</h2><h3 id="一、添加Universe-distribution-component（渣翻：universe组成元件，用于连接universe仓库）"><a href="#一、添加Universe-distribution-component（渣翻：universe组成元件，用于连接universe仓库）" class="headerlink" title="一、添加Universe distribution component（渣翻：universe组成元件，用于连接universe仓库）"></a>一、添加Universe distribution component（渣翻：universe组成元件，用于连接universe仓库）</h3><p>仓库提供软件安装的地址。除了<strong>universe</strong>以外，<strong>Ubuntu</strong>还有<strong>Main</strong>、<strong>Restricted</strong>、Multiverse等仓库。</p>
<p><strong>Universe</strong>仓库提供由社区主导，并且完全开源的软件。这里的alien安装就需要<strong>Universe</strong>仓库。</p>
<p>添加远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br></pre></td></tr></table></figure>

<p>另外，在命令里添加-r选项，可以移除仓库。</p>
<p><strong>注意，如果网络速度太慢可能会导致部分安装错误，最后无法安装alien！所以安装之前先考虑一下网络，有可能需要科学上网。</strong></p>
<br>

<h3 id="二、更新apt的cache"><a href="#二、更新apt的cache" class="headerlink" title="二、更新apt的cache"></a>二、更新apt的cache</h3><p>更新了仓库之后，还要更新<strong>apt</strong>的<strong>cache</strong>才能查找到需要的软件。apt的<strong>cache</strong>用于提供软件安装的地址，如果不更新就自然就找不到对应的包。另外，系统新装的时候也需要更新一下apt。</p>
<p>更新apt：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p><strong>update</strong>命令并不会直接<strong>apt</strong>安装所有软件。如果需要进一步更新软件需要使用upgrade命令。</p>
<br>

<h3 id="三、安装alien包"><a href="#三、安装alien包" class="headerlink" title="三、安装alien包"></a>三、安装alien包</h3><p><strong>alien</strong>用于安装rpm包，具体的安装方法有两种，第四点会一一介绍。</p>
<p>安装<strong>alien</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install alien</span><br></pre></td></tr></table></figure>

<br>

<h3 id="四、安装rpm包"><a href="#四、安装rpm包" class="headerlink" title="四、安装rpm包"></a>四、安装rpm包</h3><p>安装了<strong>alien</strong>之后就可以愉快地安装rpm包。但是这里在说一下，安装<strong>rpm</strong>包有两种方式。</p>
<ol>
<li>把<strong>rpm</strong>转换成deb包再安装</li>
</ol>
<p><strong>alien</strong>命令可以把rpm包变成<strong>deb</strong>包，再安装。这种方法比较推荐。</p>
<p>把当前目录<strong>cd</strong>到<strong>rpm</strong>包所在的目录下，按一下命令执行即可安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo alien packagename.rpm</span><br><span class="line"></span><br><span class="line">sudo dpkg -i packagename.deb</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>直接安装<strong>rpm</strong>包</li>
</ol>
<p>alien也可直接<strong>rpm</strong>包。但是需要注意，这个方法不是<strong>native</strong>（原生）的所以可能会出现一点问题。</p>
<p>直接安装<strong>rpm</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo alien -i packagename.rpm</span><br></pre></td></tr></table></figure>

<br>

<br>

<p>好了，到这里本次分享已经结束。希望能够帮助你。</p>
<br>

<p>参考文章：</p>
<ol>
<li><a href="https://phoenixnap.com/kb/install-rpm-packages-on-ubuntu" target="_blank" rel="noopener">https://phoenixnap.com/kb/install-rpm-packages-on-ubuntu</a></li>
<li><a href="https://help.ubuntu.com/community/Repositories/Ubuntu" target="_blank" rel="noopener">https://help.ubuntu.com/community/Repositories/Ubuntu</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/27/WSLinux之Ubuntu-安装rpm包/" data-id="ckvkw0osd0001asujvrzbv89k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/26/大数据架构作业-简答题2/" class="article-date">
  <time datetime="2020-09-26T12:05:46.000Z" itemprop="datePublished">2020-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/26/大数据架构作业-简答题2/">大数据架构作业-简答题2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>大数据架构第二次作业出来了，这次照旧记录一下。</em></p>
<br>

<h2 id="容器化技术的核心原理"><a href="#容器化技术的核心原理" class="headerlink" title="容器化技术的核心原理"></a>容器化技术的核心原理</h2><blockquote>
<p><strong>题目：</strong>请从网络下载<strong>virtualbox</strong>软件并安装，然后在<strong>virtualbox</strong>中创建一台或多台虚拟机，尝试在虚拟机中安装<strong>CentOS</strong>或者<strong>Ubuntu</strong>等<strong>Linux</strong>操作系统。在<strong>Linux</strong>操作系统中，测试实现容器的核心技术：<strong>namespace</strong>和<strong>cgroups</strong>两项内核功能，最后在答案部分陈述实验过程、遇到的问题和解决思路、技术原理和实验体会等。</p>
</blockquote>
<br>

<h3 id="使用virtualbox创建Ubuntu虚拟机"><a href="#使用virtualbox创建Ubuntu虚拟机" class="headerlink" title="使用virtualbox创建Ubuntu虚拟机"></a>使用virtualbox创建Ubuntu虚拟机</h3><p>首先在官网下载并安装<strong>virtualbox</strong>，到<strong>Ubuntu</strong>官网：<a href="https://cn.ubuntu.com/download，下载20.04版本的**Ubuntu.ios**文件。然后参考博客安装**Ubuntu**系统。" target="_blank" rel="noopener">https://cn.ubuntu.com/download，下载20.04版本的**Ubuntu.ios**文件。然后参考博客安装**Ubuntu**系统。</a></p>
<p>安装的速度比较慢，有可能是因为机子的配置不够。安装系统提示仍需<strong>8h</strong>的时候，我直接睡觉了…</p>
<p>虚拟机的创建过程很简单，只要根据基本的操作，看看系统安装的步骤很快就可以完成。</p>
<p>考虑到现在<strong>Win10</strong>可以安装<strong>Ubuntu</strong>子系统，其实没有必要非得装一个虚拟机去体验<strong>Linux</strong>。不过以后如果有机会，可以尝试用一下<strong>vbox</strong>安装<strong>windows-xp</strong>，玩一下不兼容的老游戏。</p>
<p>参考博客：<a href="https://blog.csdn.net/u012732259/article/details/70172704" target="_blank" rel="noopener">https://blog.csdn.net/u012732259/article/details/70172704</a></p>
<br>

<p>学习Linux中的容器</p>
<p>容器实现的原理：namespace（实现资源隔离）、cgroups（实现资源控制）（两者是Linux内核功能）</p>
<p>容器是拥有单独命名空间的进程。</p>
<p>Namespace（命名空间）</p>
<p>Namespace定义了一个封闭的作用域范围，约定。Namespace本质是一种资源隔离方案。</p>
<p>处于同一命名空间的进程，只能看到该名字空间下的资源，如主机名、网络、进程、用户、文件系统等。</p>
<p>不同名字空间的进程彼此不可见，互不影响。</p>
<p>每个进程拥有七个命名空间犹豫隔离不同类型的资源：PID Namespace（pid）、CGroup Namespace（cgroup）、IPC Namespace（ipc）、Mount Namespace（mnt）、Network Namespace（net）、User Namespace（user）、UTS Namespace（uts）。</p>
<p>关于namespace的特性可以参考这篇博客：<a href="https://zhengyinyong.com/post/introduction-to-linux-namespace/" target="_blank" rel="noopener">https://zhengyinyong.com/post/introduction-to-linux-namespace/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/26/大数据架构作业-简答题2/" data-id="ckvkw0otx001basujvxvak643" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-入门JavaSE-进阶篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/23/入门JavaSE-进阶篇/" class="article-date">
  <time datetime="2020-09-23T10:36:08.000Z" itemprop="datePublished">2020-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/23/入门JavaSE-进阶篇/">入门Java其三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>趁热打铁，开始看进阶篇，快速入门。</p>
<h2 id="javase入门-进阶"><a href="#javase入门-进阶" class="headerlink" title="javase入门 进阶"></a>javase入门 进阶</h2><p><a href="https://www.imooc.com/learn/110" target="_blank" rel="noopener">https://www.imooc.com/learn/110</a><br><br><br><br></p>
<h2 id="C1-异常与异常处理"><a href="#C1-异常与异常处理" class="headerlink" title="C1-异常与异常处理"></a>C1-异常与异常处理</h2><h3 id="异常简介"><a href="#异常简介" class="headerlink" title="异常简介"></a>异常简介</h3><p>有错误出现，阻止当前方法或作用域<br><code>Throwable</code>所有异常的父类, 有两个子类</p>
<ol>
<li>Error 虚拟机错误，线程死锁</li>
<li>Exception runtime异常（非检查异常），检查异常</li>
</ol>
<br>

<br>

<h3 id="处理异常-捕获异常"><a href="#处理异常-捕获异常" class="headerlink" title="处理异常(捕获异常)"></a>处理异常(捕获异常)</h3><p><code>try-catch</code>以及<code>try-catch-finally</code>，<code>catch</code>语句捕获异常进行处理，可以有多个<code>catch</code>语句块，先<code>catch</code>异常子类再<code>catch</code>异常的父类，<code>finally</code>是异常处理完之后再执行的语句块。<br>ps：打印异常可以用 <code>e.printStackTrace();</code><br>pps: 原来输入法可以切换中英文标点, 不需要整个输入法切换成英文!</p>
<br>

<h3 id="异常抛出以及自定义异常"><a href="#异常抛出以及自定义异常" class="headerlink" title="异常抛出以及自定义异常"></a>异常抛出以及自定义异常</h3><h4 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h4><p><code>throws</code> 声明僬侥抛出何种类型的异常(声明)<br><code>throw</code> 将产生的异常抛出(动作)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出异常方法示例:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名(参数列表) <span class="keyword">throws</span> 异常列表 &#123;</span><br><span class="line">		<span class="comment">//调用会抛出异常的方法或者throw new Exception();</span></span><br><span class="line">		<span class="comment">//处理没有预先规定的异常种类</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>ps: 异常的处理是多样化的, 捕获异常(try-catch)和抛出异常(throws)只是两种方式,抛出异常一般处理<br><br></p>
<h4 id="自定义的异常"><a href="#自定义的异常" class="headerlink" title="自定义的异常"></a>自定义的异常</h4><p>自定义异常: 自定义一个自己编写的异常种类<br>语法: <code>public class MyException extends Exception {}</code><br>ps: 注意要编写构造方法, 另外父类必须为Exception或者其它子类<br>pps: Exception构造方法输入参数作为报错的名称</p>
<p>ps: 异常的处理是多样化的, 捕获异常(try-catch)和抛出异常(throws)只是两种方式,抛出异常一般处理自定义的异常<br>自定义异常<br>自定义一个自己编写的异常种类<br>语法: public class MyException extends Exception {}<br>ps: 注意要编写构造方法, 另外父类必须为Exception或者其它子类<br>pps: Exception构造方法输入参数作为报错的名称</p>
<br>

<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>目的: 用于推测出最初发生异常的位置<br>示例: 自定义一个异常(喝大了), 一个方法(test1)抛出自定义的异常, 另一个方法(test2)调用这个会抛出异常的方法(test1),捕获异常(喝大了)从而再抛出一个异常(运行时异常), 最后在其它方法调用后一个方法, 则形成了一个异常链(由喝大了引发的运行时异常)<br>ps: throw抛出异常之前必须先throws声明异常<br>pps: 异常使用initCase方法, 引用原始异常</p>
<br>

<h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><ol>
<li>运行时异常, 采用逻辑规避, 用try-catch辅助处理</li>
<li>多重catch块后面, 可以catch(Exception)处理可能遗漏的异常</li>
<li>try-catch,处理潜在的异常</li>
<li>积极根据业务需求和异常类型处理异常, 不要简单打印异常</li>
<li>尽量用finally语句释放占用的资源</li>
</ol>
<br>

<br>

<br>

<h2 id="C2-Java中的字符串"><a href="#C2-Java中的字符串" class="headerlink" title="C2-Java中的字符串"></a>C2-Java中的字符串</h2><h3 id="字符串什么"><a href="#字符串什么" class="headerlink" title="字符串什么"></a>字符串什么</h3><p><code>String</code>对象位于<code>java.lang</code>包中, 默认情况下该包自动导入所有的程序<br>创建<code>String</code>对象方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"imooc"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String();</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"imooc"</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="字符串的不变性"><a href="#字符串的不变性" class="headerlink" title="字符串的不变性"></a>字符串的不变性</h3><p><code>String</code>对象创建后不能修改, 只能直接改变指向的内存, 相当于整个变量对应的内容换掉<br>如果需要可以改变的字符串,可以使用<code>StringBuffer</code>或者<code>StringBuilder</code><br>每次<code>new</code>一个<code>String</code>就是一个新的对象, 所以<code>==</code>的结果为<code>flase</code>, 比较两个字符串内容是否相同时, 应该使用<code>equals()</code>方法, 注意区分<code>==</code>和<code>equals()</code></p>
<br>

<h3 id="String类常用的方法"><a href="#String类常用的方法" class="headerlink" title="String类常用的方法"></a><code>String</code>类常用的方法</h3><p><code>String</code>类提供了很多处理字符串的方法, 获取长度,截取字符串,字符串转换为大小写,字符串分割等等<br>可以参照菜鸟教程的<code>Java中String类</code>的说明:<br><a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-string.html</a><br>ps: <code>equals()</code>, <code>indexOf()</code>, <code>substring()</code>, <code>charAt()</code>用的比较多<br>pps: <code>==</code>判断两个对象内存的地址是否相同, <code>equals()</code>比较两个对象的内容是否相等<br>关于<code>getBytes()</code>方法, 由于汉字有两个字节而且会溢出, 所以转换后得到的字节数是两个负数, <code>asc码</code>则转化为一个数</p>
<br>

<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a><code>StringBuilder</code>类</h3><p>修改字符串时不会额外创建一个对象, <code>StringBuffer</code>是线程安全的, <code>StringBuilder</code>则没有但性能更高, 一般课表字符串对象优先考虑<code>StringBuilder</code><br>定义: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str1 = <span class="keyword">new</span> StringBuilder();  <span class="comment">// 参数""可选</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="StringBuilder类的常用方法"><a href="#StringBuilder类的常用方法" class="headerlink" title="StringBuilder类的常用方法"></a><code>StringBuilder类</code>的常用方法</h3><p><code>append()</code>, <code>inset()</code>方法比较常用<br>同样, 可以参照菜鸟教程:<br><a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-stringbuffer.html</a></p>
<br>

<br>

<br>

<h2 id="C3-Java中的常用类"><a href="#C3-Java中的常用类" class="headerlink" title="C3-Java中的常用类"></a>C3-Java中的常用类</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>为了让基本数据类型(<code>int</code> <code>double</code> <code>float</code>等)具备<strong>对象的特性</strong>, 如属性方法等, Java提供的<strong>类</strong>, (变量由一个数值变成对象)<br><br></p>
<h4 id="包装类主要提供两大方法"><a href="#包装类主要提供两大方法" class="headerlink" title="包装类主要提供两大方法:"></a>包装类主要提供两大方法:</h4><ol>
<li>将本类型和其它基本类型进行转换</li>
<li>将字符串和本类型即包装类互相转换</li>
</ol>
<br>

<br>

<h3 id="基本类型和包装类之间的转换"><a href="#基本类型和包装类之间的转换" class="headerlink" title="基本类型和包装类之间的转换"></a>基本类型和包装类之间的转换</h3><p>装箱: 把<strong>基本类型</strong>转换为包装类, 有<strong>手动装箱</strong>(<code>包装类 x = new 包装类(i)</code>)和<strong>自动装箱</strong>(<code>包装类 x = i</code>)<br>拆箱: 把<strong>包装类对象</strong>转换为<strong>基本类型</strong>, 也有手动(<code>int x = j.intValue()</code>)和自动(<code>int x = j</code>)  ps: <code>.intValue()</code>转为整数, <code>.doubleValue()</code>转为双精度<br>pps: 自动转换只能在一种基本类型和与之对应的包装类之间进行转换</p>
<br>

<h3 id="基本类型和字符串之间的转换"><a href="#基本类型和字符串之间的转换" class="headerlink" title="基本类型和字符串之间的转换"></a>基本类型和字符串之间的转换</h3><h4 id="基本类型转换为字符串"><a href="#基本类型转换为字符串" class="headerlink" title="基本类型转换为字符串:"></a>基本类型转换为字符串:</h4><ol>
<li>使用包装类的toString()方法</li>
<li>使用String类的valueOf()方法</li>
<li>用空字符串加上基本类型, 隐式转换为字符串</li>
</ol>
<br>

<h4 id="将字符串转换为基本类型"><a href="#将字符串转换为基本类型" class="headerlink" title="将字符串转换为基本类型:"></a>将字符串转换为基本类型:</h4><ol>
<li>调用包装类的<code>ParseXxx</code>静态方法  (比如: <code>int a = Integer.parseInt(str);</code>)</li>
<li>调用包装类的<code>valueOf()</code>方法转换为对应的包装类, 再自动拆箱  (比如: <code>int a = Integer.valueOf(str);</code>)</li>
</ol>
<br>

<br>

<h3 id="使用Date和SimpleDateFormat类表示时间"><a href="#使用Date和SimpleDateFormat类表示时间" class="headerlink" title="使用Date和SimpleDateFormat类表示时间"></a>使用<code>Date</code>和<code>SimpleDateFormat</code>类表示时间</h3><p><code>Date类</code>在<code>java.util</code>包中, 用于获取当前时间, <strong>默认无参构造方法初始化</strong><br><code>SimpleDateFormat类</code>在<code>java.text</code>包中, 可以将日期转换为指定格式的文本<br>示例:</p>
<ol>
<li><h4 id="使用format-转换日期的显示格式"><a href="#使用format-转换日期的显示格式" class="headerlink" title="使用format()转换日期的显示格式"></a>使用<code>format()</code>转换日期的显示格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String today = sdf.format(d);</span><br><span class="line">System.out.println(today);</span><br></pre></td></tr></table></figure>

<p><code>&quot;yyyy-MM-dd HH:mm:ss&quot;</code>指定日期格式, 读取时期, 把日期转化为指定的格式</p>
<p>“yyyy-MM-dd HH:mm:ss”指定日期格式, 读取时期, 把日期转化为指定的格式</p>
</li>
<li><h4 id="使用parse-方法将文本转换为日期"><a href="#使用parse-方法将文本转换为日期" class="headerlink" title="使用parse()方法将文本转换为日期"></a>使用<code>parse()</code>方法将文本转换为日期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String day = <span class="string">"2020年8月28日 11:48:16"</span></span><br><span class="line">SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">Date date = df.parse(day);</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure>

<p><code>parse</code>根据指定的格式<strong>反过来读取字符串, 从而获得日期</strong></p>
<p>ps: 调用<code>SimpleDateFormat</code>对象的<code>parse()</code>方法可能会出现<strong>转换异常</strong>, <code>ParseException</code>, 因此<strong>需要异常处理</strong><br>使用<code>Date类</code>需要导入<code>java.util</code>包, 使用<code>SimpleDateFormat类</code>需要导入<code>java.text</code>包</p>
<p>parse根据指定的格式反过来读取字符串, 从而获得日期<br>ps:<br>调用SimpleDateFormat对象的parse()方法可能会出现转换异常, ParseException, 因此需要异常处理<br>使用Date类需要导入java.util包, 使用SimpleDateFormat类需要导入java.text包</p>
<p><br><br></p>
</li>
</ol>
<h3 id="Calendar类的应用"><a href="#Calendar类的应用" class="headerlink" title="Calendar类的应用"></a><code>Calendar类</code>的应用</h3><p><code>Date类</code>只要用于获取当前时间, <strong>推荐使用<code>Calendar类</code>进行时间和日期的处理</strong><br><code>java.util.Calendar类</code>是一个<strong>抽象类</strong>, 可调用<code>getInstance()</code>静态方法获取<code>Calendar对象</code>, 如 <code>Calendar c = Calenar.getInstance();</code><br><br></p>
<h4 id="常用方法和属性"><a href="#常用方法和属性" class="headerlink" title="常用方法和属性:"></a>常用方法和属性:</h4><ol>
<li><code>Calendar类</code>有<code>YEAR</code>,<code>MONTH</code>,<code>DAY_OF_MONTH</code>等静态常量, </li>
<li>调用<code>getInstance()</code>获取一个实例, </li>
<li>调用<code>get()</code>方法获取日期信息, <code>getTime()</code>方法获取<code>Date对象</code>, </li>
<li>通过<code>getTimeInMillis()</code>方法获取<code>Calendar</code>时间值(以毫秒为单位)</li>
</ol>
<br>

<h3 id="使用Math类操作数据"><a href="#使用Math类操作数据" class="headerlink" title="使用Math类操作数据"></a>使用Math类操作数据</h3><p><code>java.lang.Math类</code>包含基本数学运算的方法, 因为所有方法都是<strong>静态方法</strong>, 所以可以直接按 ``类名.方法名` 使用<br><br></p>
<h4 id="可以参照一下菜鸟教程的相关介绍"><a href="#可以参照一下菜鸟教程的相关介绍" class="headerlink" title="可以参照一下菜鸟教程的相关介绍:"></a>可以参照一下菜鸟教程的相关介绍:</h4><p><a href="https://www.runoob.com/java/java-number.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-number.html</a></p>
<br>

<br>

<br>

<h2 id="C4-Java中的集合框架-上"><a href="#C4-Java中的集合框架-上" class="headerlink" title="C4  Java中的集合框架(上)"></a>C4  Java中的集合框架(上)</h2><h3 id="集合框架概述"><a href="#集合框架概述" class="headerlink" title="集合框架概述"></a>集合框架概述</h3><p><strong>容器的概念:</strong>  把若干种属性(数目, 种类不一定)存储起来, 就是集合, 是一种工具类存储共同属性种类的对象</p>
<h4 id="容器的作用"><a href="#容器的作用" class="headerlink" title="容器的作用:"></a>容器的作用:</h4><ol>
<li>在类的内部, 对组织数据</li>
<li>简单快速的都说大量条目</li>
<li>一个序列, 方便插入取出某些属性</li>
<li>有的集合提供了映射关系(类似py的字典), 方便了查询</li>
</ol>
<br>

<h3 id="java提供集合的接口"><a href="#java提供集合的接口" class="headerlink" title="java提供集合的接口"></a>java提供集合的接口</h3><ol>
<li><code>Collection</code>: <code>List</code> -<code>ArrayList</code>, <code>Set</code> -<code>HashSet</code>, <code>Queue</code> -<code>LinkedList</code>  (存储的元素是对象)</li>
<li><code>Map</code>: <code>HashMap</code> (存储的元素是键值对, <code>Entry</code>)</li>
</ol>
<br>

<br>

<h3 id="Collection接口-子接口和实现类-看看前面复习一下什么是接口"><a href="#Collection接口-子接口和实现类-看看前面复习一下什么是接口" class="headerlink" title="Collection接口, 子接口和实现类 (看看前面复习一下什么是接口)"></a>Collection接口, 子接口和实现类 (看看前面复习一下什么是接口)</h3><p>Collection集合中, 讲一下List子接口和Set子接口<br><br><br></p>
<h3 id="List接口："><a href="#List接口：" class="headerlink" title="List接口："></a>List接口：</h3><p>List接口的实现类-<code>ArrayList类</code>(类似python列表)<br><code>ArrayList</code>是<strong>数组</strong>序列, 接口和实现类的关系可以参照: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List test = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>

<br>

<h4 id="下面说明一下List增删改查用到的方法"><a href="#下面说明一下List增删改查用到的方法" class="headerlink" title="下面说明一下List增删改查用到的方法:"></a>下面说明一下List增删改查用到的方法:</h4><h4 id="为列表添加对象"><a href="#为列表添加对象" class="headerlink" title="+ 为列表添加对象:"></a>+ 为列表添加对象:</h4><p><code>&lt;ls&gt;.add()</code>方法可以把一个对象添加到List中,<br><code>&lt;ls&gt;.get()</code>方法可以根据索引从List中取出对象,<br>※ 使用add方法, 把对象存入集合时, 默认会变成Object类型.<br>※ 所以get方法取出对象时, 需要类型转化, 在前面加 (强转类型)<br><code>&lt;ls&gt;.add(index, element)</code>方法可以把对象添加到指定的位置<br>※ 如果index大于ls的长度, 会报错IndexOutOfBoundException<br><code>&lt;ls&gt;.addAll()</code>方法可以把一个List添加到ls中,<br><code>Arrays.asList()</code>方法可以把一个数组转化为一个List.<br><code>&lt;ls&gt;.addAll(index, List)</code> 可以指定List插入的位置</p>
<br>

<h4 id="为列表修改对象"><a href="#为列表修改对象" class="headerlink" title="+ 为列表修改对象:"></a>+ 为列表修改对象:</h4><h5 id="遍历列表的三个方法"><a href="#遍历列表的三个方法" class="headerlink" title="遍历列表的三个方法:"></a>遍历列表的三个方法:</h5><ol>
<li><p><code>&lt;ls&gt;.size()</code>方法可以取得List的长度, 用于遍历List;</p>
</li>
<li><p>通过迭代器遍历List, 使用<code>Iterator</code>接口, <code>Iterator it = &lt;ls&gt;.iterator()</code> 获取迭代器, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用while循环遍历List迭代器中的对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;&lt;Class&gt; temp = (Class) it.next();&#125;</span><br></pre></td></tr></table></figure>

<p>※ 集合都具有iterator方法, 迭代器依赖集合存在</p>
</li>
<li><p>使用<code>forEach</code>方法遍历List, 由于在没有指定泛型时, 对象存放在集合中, 会变成Object, 所以应该用 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object obj: &lt;ls&gt;) &#123;<span class="comment">// 记得使用类型强转&#125;.</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="修改List的元素"><a href="#修改List的元素" class="headerlink" title="修改List的元素"></a>修改List的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ls&gt;.set(index, element);  <span class="comment">// 把相应位置的对象修改成新的对象</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="为列表删除对象"><a href="#为列表删除对象" class="headerlink" title="+ 为列表删除对象:"></a>+ 为列表删除对象:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ls&gt;.remove(index);  <span class="comment">// 删除相应索引位置的元素, 不能超出长度范围</span></span><br><span class="line">&lt;ls&gt;.remove(element);  <span class="comment">// 删除指定的对象</span></span><br><span class="line">&lt;ls&gt;.removeAll(Collection ls)  <span class="comment">// 删除指定集合的所有元素, 类似求差</span></span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="使用泛型-Generic-为列表处理不是对象的变量-比如字符串等等"><a href="#使用泛型-Generic-为列表处理不是对象的变量-比如字符串等等" class="headerlink" title="使用泛型(Generic), 为列表处理不是对象的变量(比如字符串等等):"></a>使用泛型(Generic), 为列表处理不是对象的变量(比如字符串等等):</h3><p><code>&lt;ls&gt;.add(OtherClass)</code> 不会报错, 但是后面使用<code>forEach</code>打印的时候, 使用了<strong>强制类型转换</strong>, <code>String</code>不能转化为<code>Course</code>, 所以还是会报错. <strong>为了能够避免向集合加入其它类型的对象, 就要使用到泛型.</strong><br>※ 集合中的元素, 可以使用<strong>任意类型</strong>的对象(对象的引用), 把放入的对象当做<code>Object</code>处理; <strong>泛型</strong>则是规定了某个<strong>集合只可以存放特定类型</strong>的对象及其子类型的对象, 可以<strong>直接指定类型</strong>获取集合元素.<br><br></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Class&gt; ls;  <span class="comment">// 使用&lt;Class&gt;指定泛型类型, 界定符一般要使用private</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.ls = <span class="keyword">new</span> ArrayList&lt;Class&gt;();  <span class="comment">// 初始化的时候仍然需要指明泛型</span></span><br></pre></td></tr></table></figure>

<p>※ 此时<code>get()</code>方法或者遍历ls时, 不需要强制转换类型了<br>※ 指定泛型之后的集合, 还能存储泛型的<strong>子类型</strong>的对象实例, 即可以<code>&lt;ls&gt;.add(new 
ChildClass());</code><br>※ <strong>泛型只能使用引用类型</strong>, 不能使用基本类型(int,char …), 如果有必要也只能用包装类, 指定泛型为包装类之后<code>&lt;ls&gt;.add(temp)</code> 会对<u>基本类型temp变量</u>进行<strong>隐式</strong>类型转换 (比如 int 变成 Interger).<br><br></p>
<h4 id="Set接口："><a href="#Set接口：" class="headerlink" title="Set接口："></a>Set接口：</h4><p><code>Set</code>接口实现类–<code>HashSet类</code>(类似数学里面的集合)<br>※ Set<strong>无序</strong>并且<strong>不可重复</strong><br>※ Set接口同样提供<code>add()</code>, <code>remove()</code>, <code>removeAll()</code>, <code>size()</code>等方法.<br>※ 但是由于Set无序, 所以<u>不提供<code>set()</code>方法和<code>get()</code>方法</u>, 如果想要调用Set内部的元素, 可以使用<code>foreach</code>和<code>Iterator</code>的方式遍历Set, 不过要注意Set是无序的, 多次遍历的顺序会改变.<br>※ Set也可以使用泛型, 使用方法同Collection<br>※ Set中可以添加空对象null<br><br></p>
<br>

<br>

<h2 id="C5-Java中的集合框架-中"><a href="#C5-Java中的集合框架-中" class="headerlink" title="C5  Java中的集合框架(中)"></a>C5  Java中的集合框架(中)</h2><h3 id="Map-amp-HashMap"><a href="#Map-amp-HashMap" class="headerlink" title="Map &amp; HashMap"></a>Map &amp; HashMap</h3><p><code>Map接口</code>提供了映射关系(键值对), 键值对以<code>Entry类</code>存在, <code>key</code>不可重复, <code>Map</code>支持泛型 比如: <code>Map&lt;typeOfK, typeOfV&gt;</code><br><code>HashMap类</code>是<code>Map</code>的一个实现类, <code>HashMap</code>中的<code>Entry对象（单个键值对）</code>无序排列, 基于哈希表实现, <code>Key</code>和<code>value</code>值可以为null, 不过Key为null时不能重复.<br><br></p>
<h3 id="Map-的增删改查"><a href="#Map-的增删改查" class="headerlink" title="Map 的增删改查:"></a>Map 的增删改查:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;.get(Key);  <span class="comment">// 返回Key的索引结果, 没有找到Key则放回null</span></span><br><span class="line">&lt;map&gt;.put(Key, value);  <span class="comment">// 添加映射, 注意要符合原来定义的泛型</span></span><br><span class="line">&lt;map&gt;.size();  <span class="comment">// 返回map的容量</span></span><br><span class="line">&lt;map&gt;.keySet();  <span class="comment">// 返回map中所有key的Set集合</span></span><br></pre></td></tr></table></figure>

<p>※ keySet方法返回Set对象(有序)之后, 可以进一步用来遍历等操作<br>※ keyList()等方法的用法类似<br><br><br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;.remove(key);  <span class="comment">// 删除Map中的映射</span></span><br><span class="line">&lt;map&gt;.entrySet();  <span class="comment">// 返回所有键值对的Set集合</span></span><br></pre></td></tr></table></figure>

<p>※ 使用entrySet()返回的对象需要制定泛型, 比如: <code>Set&lt;Entry&lt;String, Student&gt;&gt; entrySet = students.entrySet();</code><br>※ 当一个类类型定义过泛型之后, 每次调用该类都要注意是否有写该类的泛型<br>※ <code>Entry</code>对象, 使用<code>getKey()</code>方法获取键, 使用<code>getValue()</code>方法获取值, 一个entry就是一个键值对<br><br></p>
<br>

<br>

<h2 id="C6-Java中的集合框架-下"><a href="#C6-Java中的集合框架-下" class="headerlink" title="C6  Java中的集合框架(下)"></a>C6  Java中的集合框架(下)</h2><h3 id="检测某个对象是否包含在序列内"><a href="#检测某个对象是否包含在序列内" class="headerlink" title="检测某个对象是否包含在序列内"></a>检测某个对象是否包含在序列内</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ls&gt;.contains(obj);  <span class="comment">// 检测一个List内是否包含对象obj, 存储的内容相同不代表对象相同</span></span><br></pre></td></tr></table></figure>

<p>※ <code>List</code>对象的<code>contains()</code>方法 相当于遍历序列, 把序列中的每一个元素使用一次<code>equals(obj)</code>, 进行判断, <code>equals方法</code>可以参照前面第二季的笔记<br>※ 可以通过重写(<code>@override</code>)<code>equals()</code>改变<code>contains()</code>的判断逻辑, 比如说比较两个对象的<code>name属性</code>是否相等, 从而找到序列中有相同name属性的元素<br>※ 使用<code>&lt;ls&gt;.containsAll(Collection&lt;?&gt; c)</code>可以实现检测一个序列内是否包含多个对象<br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;set&gt;.contains(obj);  <span class="comment">// 检测一个Set内是否包含对象obj</span></span><br></pre></td></tr></table></figure>

<p>※ 注意<code>Set</code>对象的<code>contains</code>方法, 会先调用<code>hashCode</code>方法。<strong>在判断两个对象的哈希码是否相同的情况下,  再调用equals方法判断两个对象的值是否相等</strong>.<br>※ 同样可以通过重写的<code>hashCode方法</code>和<code>equals方法</code>, 自定义的Set对象的contains方法.<br>※ <code>IDE</code>可以提供<code>hashCode</code>和<code>equals</code>方法的<em>重写模板</em><br><br></p>
<h3 id="获取序列中元素的位置"><a href="#获取序列中元素的位置" class="headerlink" title="获取序列中元素的位置"></a>获取序列中元素的位置</h3><p>使用<code>indexOf方法</code>，<em>获取序列中某元素的索引位置</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;collection&gt;.indexOf(sth1)</span><br></pre></td></tr></table></figure>

<h5 id="indexOf方法实现机制："><a href="#indexOf方法实现机制：" class="headerlink" title="indexOf方法实现机制："></a>indexOf方法实现机制：</h5><ol>
<li>遍历序列内部的元素，调用equals方法；</li>
<li>如果出现了相同的元素，就放回序列中首个对应元素的索引。</li>
<li>如果无匹配结果，则返回-1。<br>ps: 使用lastIndexOf方法，获取序列中某个元素最后一次出现的索引位置。</li>
</ol>
<br>

<h3 id="判断某个映射是否包含在Map内"><a href="#判断某个映射是否包含在Map内" class="headerlink" title="判断某个映射是否包含在Map内"></a>判断某个映射是否包含在Map内</h3><p>在<code>Map</code>中，使用<code>containsKey</code>方法，判断<code>Map</code>是否包含某个<code>Key</code>；使用<code>containsValue</code>方法判断是否包含某个<code>Value</code>值。返回<code>true</code> or <code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;.containsKey(Key)</span><br><span class="line">&lt;map&gt;.containsValue(Value)</span><br></pre></td></tr></table></figure>

<p>※ <code>containsValue</code>方法的实现机制类似于<code>set</code>对象中的<code>contains</code>方法，先调用<code>hashCode</code>方法再调用<code>equals</code>方法。所以一般也需要重写这两个方法。<br><br></p>
<h3 id="给List对象排序"><a href="#给List对象排序" class="headerlink" title="给List对象排序"></a>给List对象排序</h3><p><code>Collections工具类</code>（相当于Arrays工具类，提供特定功能的方法，需要<code>import</code>）<br><strong>使用sort方法，对<code>List&lt;Intiger, String&gt;</code>进行排序：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(ls)  <span class="comment">//默认升序排序，判断依据：整数的大小、字符串的靠前的字符的asc码。</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）："><a href="#给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）：" class="headerlink" title="给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）："></a>给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）：</h3><p>首先，直接使用<code>collections.sort(OtherObj)</code>会报错，因为<code>sort</code>方法只能给<code>Comparable</code>接口的实现类进行排序，而<code>OtherObj</code>不是<code>comparable</code>接口的实现类。</p>
<h4 id="Collections类提供的两个接口："><a href="#Collections类提供的两个接口：" class="headerlink" title="Collections类提供的两个接口："></a>Collections类提供的两个接口：</h4><ol>
<li>Comparable接口—-提供默认比较规则，实现类要实现compareTo方法，返回值的正负表示两个值的比较结果。</li>
<li>Comparator接口—-提供临时比较规则，实现类要实现compare方法。<br>所以想要给存储其它元素的<code>List</code>对象排序，需要给该对象提供<code>comparable</code>接口，重写对应的<code>compareTo</code>方法。<br>ps：重写<code>compareTo</code>方法时，_可以调用默认的<code>compareTo</code>方法，减少工作量_。（善用this指针）<br>※ 给存放<strong>数字字符串的List对象</strong>排序的时候（如：”45688”, “7856”），要注意排序依据还是靠前字符的asc码大小，因此”7856”会排在前面。<br>另外，<code>Collections</code>工具类提供了<code>sort</code>的重载方法。使用<code>Collection.sort(List, Comparator&lt;T&gt; c)</code>，按照<code>Comparator</code>的实现类定义的<code>compare</code>方法进行排序。注意这个实现类很可能是需要自己编写的。（回顾第二季多态中接口实现类的编写）</li>
</ol>
<br>

<br>

<h3 id="回顾本章："><a href="#回顾本章：" class="headerlink" title="回顾本章："></a>回顾本章：</h3><ol>
<li>集合分为Collection和Map接口</li>
<li>Collection代表序列，其子接口有List和Set<br>List的经典实现类是<code>ArrayList</code><br>Set的经典实现类是<code>HashSet</code></li>
<li>Map代表存储键值对的集合，键值对又叫做<code>Entry&lt;Key, Value&gt;</code><br>Map的子接口有<code>HashMap</code></li>
<li>Collections工具类的sort方法用于给序列排序，介绍了两个接口Comparable和Comparator</li>
</ol>
<br>

<br>

<h3 id="扑克牌小程序思路（洗牌发牌）"><a href="#扑克牌小程序思路（洗牌发牌）" class="headerlink" title="扑克牌小程序思路（洗牌发牌）"></a>扑克牌小程序思路（洗牌发牌）</h3><h5 id="功能描述："><a href="#功能描述：" class="headerlink" title="功能描述："></a>功能描述：</h5><ol>
<li>创建扑克牌—-List</li>
<li>玩家需要有手牌（扑克牌的集合）—-编写玩家类，属性：id、name、cardList</li>
<li>洗牌（打乱顺序）—-Collections.shuffle</li>
<li>发牌—-get(), add()</li>
<li>游戏（比较大小）—-sort(), compare()   </li>
</ol>
<br>

<br>

<br>

<h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>至此，本次java入门课程的笔记到此结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/23/入门JavaSE-进阶篇/" data-id="ckvkw0otg000tasujdx00yhd1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程语言入门/">编程语言入门</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-为Windows-Terminal配置Ubuntu系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/为Windows-Terminal配置Ubuntu系统/" class="article-date">
  <time datetime="2020-09-21T12:19:20.000Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/为Windows-Terminal配置Ubuntu系统/">为Windows Terminal配置Ubuntu系统(Windows Subsystem for Linux)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>最近掘金上看了一篇文章，简单介绍了安装WindowsTerminal以及LinuxUbuntu之后，进行基本配置改善shell外观。我原来也用过windows的ubuntu子系统，抱着改善一下shell外观的念头，大概跟着做了一下，遇到了一些问题，记录一下。</em></p>
<blockquote>
<p>文章链接：<a href="https://juejin.im/post/6865596788490338311" target="_blank" rel="noopener">https://juejin.im/post/6865596788490338311</a></p>
</blockquote>
<br>

<p>第一步，安装WindowsTerminal和Ubuntu是没有问题的。打开控制面板里面的Linux子系统功能也没有问题。另外说一下，我安装的是Ubuntu20.04，毕竟技术学新不学旧嘛。</p>
<p>微软商店安装完上面两个应用之后，打开WindowsTerminal，就可以选择Ubuntu窗口了。于是下一步，给ubuntu的软件源换上镜像源。</p>
<br>

<h2 id="关于linux的vi文本编辑器的使用方法"><a href="#关于linux的vi文本编辑器的使用方法" class="headerlink" title="关于linux的vi文本编辑器的使用方法"></a>关于linux的vi文本编辑器的使用方法</h2><p>在linux下可以使用vi或者vim，进行文本编辑。大名鼎鼎的vim自然不用说，vim和vi的基本操作基本一致，但是前者的特殊操作多得多而且非常复杂，我选择这次先学习一下vi。</p>
<p>找到了一篇指导博客，整理了Linux的文件编辑命令。<br>博客地址：<a href="https://blog.csdn.net/u013142781/article/details/50735470" target="_blank" rel="noopener">https://blog.csdn.net/u013142781/article/details/50735470</a></p>
<br>

<p>关于上面这篇博客简单概括一下。</p>
<p>vi编辑器有3种编辑模式：命令行模式、文本输入模式、末行模式。</p>
<p>使用vi命令打开文本之后，默认进入命令行模式。</p>
<p>命令行模式下，输入文本命令（i、l、a等等）会跳转至对应的文本输入模式，此时就可以开始文本编辑了。</p>
<p>文本输入模式下，按Esc回到命令行模式。</p>
<p>命令行模式下按：进入末行模式，使用不同的结束命令，完成对应的操作，退出vi。</p>
<br>

<p>举一个例子</p>
<p><em>比如说我要修改wsl的Ubuntu软件源。</em><br>首先，我要用vi打开软件源所在的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>然后，我要输入指定软件源的语句，于是按下i进入文本输入模式<br><code>i</code><br>接着，在合适的位置把复制的文本粘贴进去<br><code>Linux按右键粘贴</code><br>如果想要删除多行，可以在末行模式使用命令<br><code>：m, n de</code><br>即可删除m到n行的文本<br>最后，写入文件并且退出<br><code>:wq!</code></p>
<p>然后，我要输入指定软件源的语句，于是按下i进入文本输入模式<br>i<br>接着，在合适的位置把复制的文本粘贴进去<br>Linux按右键粘贴<br>如果想要删除多行，可以在末行模式使用命令<br>：m, n de<br>即可删除m到n行的文本<br>最后，写入文件并且退出<br>:wq!</p>
<br>

<p>关于软件源，这里列一下清华源（Ubuntu 20.04）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 预发布软件源，不建议启用</span><br><span class="line"><span class="meta">#</span> deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>关于这个软件源，我后面发现安装东西的时候出了些问题。</p>
<p><strong>这里备一份默认的软件源！</strong></p>
<p>另外，有一个恢复原来的源的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -ra /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>

<p>另另外，Ubuntu每个版本都有一个代号。比如20.04（LTS）版本的代号是Focal Fossa（专注的马达加斯加长尾狸猫）。代号可以用来区分Ubuntu的源的版本。有命令可以查看当前Ubuntu的代号（Description）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<p>github上找到的默认软件源：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.canonical.com/ubuntu focal partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu focal partner</span><br></pre></td></tr></table></figure>

<br>

<p>添加了软件源之后，开始安装shell终端，很简单 sudo apt install zsh 即可。</p>
<p>然后这里我遇到了一个小问题，系统提示找不到zsh这个包。搜索了一下，发现新装的Ubuntu需要更新下apt的repository cache。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>然后再安装即可~</p>
<p>参考文章：<a href="https://itsfoss.com/unable-to-locate-package-error-ubuntu/" target="_blank" rel="noopener">https://itsfoss.com/unable-to-locate-package-error-ubuntu/</a></p>
<br>

<h2 id="安装oh-my-zsh时，又遇到了一些问题。"><a href="#安装oh-my-zsh时，又遇到了一些问题。" class="headerlink" title="安装oh-my-zsh时，又遇到了一些问题。"></a><strong>安装oh-my-zsh时，又遇到了一些问题。</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</span><br></pre></td></tr></table></figure>

<p><strong>这里直接报错：github：443端口拒绝访问</strong></p>
<p>一开始，我以为是这个地址有问题。上github的ohMyZsh项目上看了一下，发现命令没有问题。<br>然后发现原来curl的地址被墙了……</p>
<p>但是我明明是开着梯子的，为啥就没法curl下来？？</p>
<p>原来shell窗口需要自己设置代理，根据另外一篇博客，终于解决了我的问题。<br>shell设置代理参考文章：<a href="https://zhuanlan.zhihu.com/p/115450863" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/115450863</a></p>
<br>

<p>简单来说就一个命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export https_proxy=socks5://127.0.0.1:10808 http_proxy=socks5://127.0.0.1:10808 all_proxy=socks5://127.0.0.1:10808</span><br></pre></td></tr></table></figure>

<p><strong>注意，这里的端口是自己的梯子开放的端口。</strong></p>
<br>

<p>在第一次配置代理的时候，我发现curl的时候被梯子拒绝了。发现是因为没有指明sock5协议。</p>
<p>由于我的梯子没有开放http协议的设置，我没办法设置http的端口。所以10808是我sock5协议开放的端口，需要事先说明协议。</p>
<p>注意，这里的端口是自己的梯子开放的端口。<br>在第一次配置代理的时候，我发现curl的时候被梯子拒绝了。后来发现，是因为没有指明sock5协议。由于我的梯子没有开放http协议的设置，我没办法设置http的端口。所以10808是我sock5协议开放的端口，需要事先说明协议。</p>
<p>另外如果想要恢复成原来的代理状态，可以参考</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unset https_proxy</span><br><span class="line">unset http_proxy</span><br><span class="line">unset all_proxy</span><br><span class="line">env|grep -I proxy</span><br></pre></td></tr></table></figure>

<p>最后一行是干什么我没弄清楚。</p>
<p>最后一行是干什么我没弄清楚。</p>
<br>

<p>安装了oh-my-zsh之后，shell界面终于有了飞跃，画面看上去简介了不少。<br>根据我们的指导文章，我们还要看一看<u>其它zsh主题</u>，把终端的颜值再弄上去一个层次。在 <code>/home/username</code> 目录下使用<code>vi ~/.zshrc</code> 发现<code>OhMyZsh</code>的<code>Plugins</code>只有<code>git</code>，没法选择主题。于是开始在TerminalSplash上看看热门主题。<br>地址：<a href="https://terminalsplash.com/" target="_blank" rel="noopener">https://terminalsplash.com/</a></p>
<br>

<p>terminalsplash上看到一个<strong>miku</strong>的主题，怦然心动。开始琢磨怎么把<del>纸片人老婆</del>miku弄到shell终端上。<br>根据Windows Terminal Miku项目github的readme，得知需要把profiles文件夹里的文件覆盖到windowsterminal的data文件内。<br>于是，我开始<strong>寻找Windowsterminal的文件夹位置</strong>。</p>
<br>

<p>传统的文件检索太慢，所以我使用了一个软件叫<strong>Eveything</strong>，很快找到了多个相关的文件夹。有的文件夹无法访问，需要修改一下文件目录的所有者。具体操作可以参照这篇：<a href="http://www.xitongcheng.com/jiaocheng/win10_article_11880.html。" target="_blank" rel="noopener">http://www.xitongcheng.com/jiaocheng/win10_article_11880.html。</a><br>经过一番排查，终于在<strong>packetges目录下</strong>找到的需要的文件。</p>
<br>

<p>但是，把profile文件复制到对应文件之后发现shell窗口<strong>没有任何变化</strong>。<br>通过查看其它介绍windowsterminal的文章，发现原来修改shell终端的外观，<strong>需要修改windowsterminal/LocalState/settings.json</strong>。于是通过复制miku主题的json相关代码到setting.json，并且在根目录复制对应文件之后，成功修改了shell的外观！<br>其它windowsterminal参考文章：<a href="https://my.oschina.net/u/4269669/blog/4437681" target="_blank" rel="noopener">https://my.oschina.net/u/4269669/blog/4437681</a></p>
<br>

<p>至此，终于安装好了wsl服务，并且修改了shell的外观。对于这个miku主题我还是很满意的。感谢原文章的作者提供的指引~</p>
<br>

<p>参考的github项目：</p>
<ol>
<li>oh-my-zsh:<br><a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh</a></li>
<li>windows-terminal-miku:<br><a href="https://github.com/DamourYouKnow/windows-terminal-miku" target="_blank" rel="noopener">https://github.com/DamourYouKnow/windows-terminal-miku</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/21/为Windows-Terminal配置Ubuntu系统/" data-id="ckvkw0oss0007asujeawq9nde" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/16/大数据架构作业-简答题1/" class="article-date">
  <time datetime="2020-09-16T08:10:58.000Z" itemprop="datePublished">2020-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/16/大数据架构作业-简答题1/">大数据架构作业--简答题1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>写在前面：最近选了大数据架构技术的课，开始学习云计算以及大数据平台的架构。于是记录一下课堂布置的一道作业题。</em></p>
<blockquote>
<p>作业题目：简要回答云计算的三类服务产品及各自的特点，调研各类云计算服务厂商及其产品, 给出产品列表, 说明各类产品的云服务类别,功能,特性,应用场景等。</p>
</blockquote>
<p>​     </p>
<h2 id="云计算的三类服务产品及各自的特点："><a href="#云计算的三类服务产品及各自的特点：" class="headerlink" title="云计算的三类服务产品及各自的特点："></a>云计算的三类服务产品及各自的特点：</h2><blockquote>
<p><strong>云计算按照服务类型可以分为三类：<code>Iaas</code>, <code>Paas</code>, <code>Saas</code>。</strong><br><code>Iaas</code> ：将基础设施作为服务，将硬件设备等基础资源封装成服务供用户使用。<br><code>Paas</code>：将平台作为服务，提供用户应用程序的运行环境。<br><code>Saas</code>：将软件作为服务，只提供某些专门用途的服务供应用调用。</p>
</blockquote>
<p>​     </p>
<h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><h3 id="一、弹性计算（Iaas）："><a href="#一、弹性计算（Iaas）：" class="headerlink" title="一、弹性计算（Iaas）："></a>一、弹性计算（Iaas）：</h3><ol>
<li>云服务器 ECS- 一种弹性可伸缩的计算服务</li>
<li>(高性能计算HPC)超级计算集群（Super Computing Cluster，SCC）- 使用高速RDMA网络互联的CPU以及GPU等异构加速设备，面向高性能计算、人工智能/机器学习、科学/工程计算、数据分析、音视频处理等应用，提供极致计算性能和并行效率的计算集群服务。</li>
<li>容器服务ACS- 提供高性能可伸缩的容器应用管理能力，支持企业级容器化应用的全生命周期管理。整合阿里云虚拟化、存储、网络和安全能力，打造云端最佳容器化应用运行环境。</li>
</ol>
<h3 id="二、存储服务（Iaas）："><a href="#二、存储服务（Iaas）：" class="headerlink" title="二、存储服务（Iaas）："></a>二、存储服务（Iaas）：</h3><ol>
<li>对象存储 OSS- 海量、安全、低成本、高可靠的云存储服务，提供99.9999999999%(12个9)的数据持久性。</li>
<li>块存储- 为云服务器ECS提供的低时延、持久性、高可靠的数据块级随机存储。块存储支持在可用区内自动复制您的数据，防止意外硬件故障导致的数据不可用，保护您的业务免于组件故障的威胁。</li>
</ol>
<h3 id="三、CDN与边缘服务（saas）："><a href="#三、CDN与边缘服务（saas）：" class="headerlink" title="三、CDN与边缘服务（saas）："></a>三、CDN与边缘服务（saas）：</h3><ol>
<li>CDN- 将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。</li>
<li>边缘节点服务（Edge Node Service, ENS）- 基于运营商边缘节点和网络构建，一站式提供“融合、开放、联动、弹性”的分布式算力资源，帮助用户业务下沉至运营商侧边缘，有效降低计算时延和成本。</li>
</ol>
<h3 id="四、数据库服务（Paas）："><a href="#四、数据库服务（Paas）：" class="headerlink" title="四、数据库服务（Paas）："></a>四、数据库服务（Paas）：</h3><p>云数据库专属集群MyBase- MyBase是阿里云专为企业级用户定制优化的解决方案，支持MySQL、PostgreSQL、SQL Server、Redis数据库。具有云资源独享、支持资源超分配，自主可运维、开放部分数据库和OS权限等特点。</p>
<p>​     </p>
<p>​     </p>
<h2 id="腾讯云产品"><a href="#腾讯云产品" class="headerlink" title="腾讯云产品"></a>腾讯云产品</h2><h3 id="一、腾讯云CVM服务器（Iaas）："><a href="#一、腾讯云CVM服务器（Iaas）：" class="headerlink" title="一、腾讯云CVM服务器（Iaas）："></a>一、腾讯云CVM服务器（Iaas）：</h3><p>为用户提供通用和标准的云虚拟机服务，同时依据不同的业务需求还提供GPU服务器，FPGA服务器，专用宿主机，黑石物理服务器等。</p>
<h3 id="二、腾讯云存储（Iaas）："><a href="#二、腾讯云存储（Iaas）：" class="headerlink" title="二、腾讯云存储（Iaas）："></a>二、腾讯云存储（Iaas）：</h3><p>包括对象存储、文件存储、归档存储、存储网关以及私有云存储服务。若企业要实现将文件存储到云端，那么就可以选择文件存储；如果企业的文件包括大量的视频和图片，就可以选择对象存储；而如果企业有将文档进行归档的需求，就可以选择归档存储，对需要实现本地和云端混合存储的企业，存储网关会是一个很好的选择，此外企业还可以根据需求选择私有云存储。</p>
<h3 id="三、腾讯云数据库（Paas）："><a href="#三、腾讯云数据库（Paas）：" class="headerlink" title="三、腾讯云数据库（Paas）："></a>三、腾讯云数据库（Paas）：</h3><p>提供<code>mysql</code> ，<code>sqlserver</code>  <code>mariaDB</code>， <code>postgresql</code> 等不同的数据库产品和数据库平台服务。</p>
<h2 id="亚马逊AWS"><a href="#亚马逊AWS" class="headerlink" title="亚马逊AWS"></a>亚马逊AWS</h2><p><em>主要类别：虚拟机服务、容器服务、非服务器服务、边缘和混合服务、成本和容器管理服务</em></p>
<h3 id="一、虚拟机服务：（Iaas）"><a href="#一、虚拟机服务：（Iaas）" class="headerlink" title="一、虚拟机服务：（Iaas）"></a>一、虚拟机服务：（Iaas）</h3><ol>
<li>Amazon Elastic Compute Cloud(EC2)- 一种Web服务, 可在云中提供安全并且可以调节大小的计算容量(虚拟服务器).</li>
<li>Amazon Lightsail- 易于使用的云平台，用于构建应用程序或网站</li>
</ol>
<h3 id="二、容器服务：（Iaas）"><a href="#二、容器服务：（Iaas）" class="headerlink" title="二、容器服务：（Iaas）"></a>二、容器服务：（Iaas）</h3><ol>
<li>Amazon Elastic Container Service (ECS)- 运行和管理Docker容器，运行容器的高度安全、可靠且可扩展的方式</li>
<li>Amazon Elastic Container Registry (ECR)- 存储和检索Docker镜像，轻松存储、管理和部署容器映像</li>
<li>Amazon Elastic Kubernetes Service (EKS)- 在AWS上运行托管的 Kubernetes，完全托管的 Kubernetes 服务</li>
</ol>
<h3 id="三、非服务器服务：（Iaas）"><a href="#三、非服务器服务：（Iaas）" class="headerlink" title="三、非服务器服务：（Iaas）"></a>三、非服务器服务：（Iaas）</h3><ol>
<li>AWS Lambda- 运行代码，无需预置或管理服务器，无需考虑服务器即可运行代码仅按消耗的计算时间付费</li>
<li>AWS Fargate- 无需管理服务器或集群即可运行容器，适用于容器的无服务器计算</li>
</ol>
<h3 id="四、边缘和混合服务："><a href="#四、边缘和混合服务：" class="headerlink" title="四、边缘和混合服务："></a>四、边缘和混合服务：</h3><ol>
<li>AWS Outposts- 完全托管的服务 可将AWS基础设施、AWS服务、API和工具扩展到几乎任何数据中心、共处空间或本地设施，以实现真正一致的混合体验，运行本地 AWS基础设施和服务以获得真正一致的混合体验</li>
<li>AWS Snow 系列- Snow系列由AWS Snowcone和AWS Snowball组成，可以提供各种具备内置计算功能的物理设备和容量点，用于收集和处理耐用环境或连接断开的边缘环境中的数据</li>
<li>AWS Wavelength- 构建能够为移动设备和最终用户交付低于10毫秒的延迟的应用程序，为5G设备交付超低延迟应用程序</li>
<li>VMware Cloud on AWS- 无需自定义硬件即可构建混合云，快速将 VMware 环境扩展、迁移到 AWS 云并予以保护</li>
<li>AWS 本地扩展区- 可以在特定区域以对最终用户和资源本地执行的方式轻松运行应用程序延迟敏感的部分，从而提供低于10毫秒的延迟，在更靠近最终用户的位置运行对延迟敏感的应用程序</li>
</ol>
<h3 id="五、成本和容器管理服务：（Iaas）"><a href="#五、成本和容器管理服务：（Iaas）" class="headerlink" title="五、成本和容器管理服务：（Iaas）"></a>五、成本和容器管理服务：（Iaas）</h3><ol>
<li>Amazon EC2 Spot- 充分利用 AWS 云中未使用的 EC2 容量。与按需实例的价格相比，使用 Spot 实例最高可以享受 90% 的折扣，运行容错工作负载，节省高达 90%</li>
<li>Amazon EC2 Autoscaling- 保持应用程序的可用性，根据您定义的条件自动添加或删除 EC2 实例，自动添加或删除计算容量以应对需求变化</li>
<li>AWS Batch- 运行任意规模的批处理作业，任意规模的完全托管式批处理</li>
<li>AWS Compute Optimizer- 确定最佳的 AWS 计算资源，为工作负载推荐最佳的 AWS 计算资源，以降低成本并提高性能</li>
<li>AWS Elastic Beanstalk- 运行和管理 Web 应用程序，易于使用的服务，可用于部署和扩展 Web 应用程序和服务</li>
<li>EC2 Image Builder- 构建和维护安全映像，构建和维护安全的 Linux 或 Windows Server 映像</li>
<li>Elastic Load Balancing- 通过确保可扩展性、性能和安全性，让任何应用程序都获得容错能力，在多个目标间自动分配传入的应用程序流量</li>
</ol>
<p>​      </p>
<p>​     </p>
<h2 id="微软Azure"><a href="#微软Azure" class="headerlink" title="微软Azure"></a>微软Azure</h2><h3 id="一、虚拟桌面服务：（Iaas）"><a href="#一、虚拟桌面服务：（Iaas）" class="headerlink" title="一、虚拟桌面服务：（Iaas）"></a>一、虚拟桌面服务：（Iaas）</h3><p>Windows 虚拟桌面- 在云中运行的综合桌面和应用虚拟化服务。它是提供简化管理、多会话 Windows 10、适用于企业的 Microsoft 365 应用优化和远程桌面服务 (RDS) 环境支持的唯一的虚拟桌面基础结构 (VDI)。只需几分钟即可在 Azure 上部署和扩展 Windows 桌面和应用，并获得内置的安全性和符合性功能</p>
<h3 id="二、存储服务：（Iaas）"><a href="#二、存储服务：（Iaas）" class="headerlink" title="二、存储服务：（Iaas）"></a>二、存储服务：（Iaas）</h3><ol>
<li>Avere vFXT for Azure- 先进的高性能计算让数据存储变得更快、更轻松，可以保护基础结构投资，同时轻松管理新需求。使用智能缓存以高效、经济实惠的方式灵活放置数据，无延迟地运行 NFS 和/或 SMB 工作负荷，并根据需求进行缩放。</li>
<li>Azure Data Lake Storage- 大规模可缩放且安全的数据湖，适用于高性能分析工作负载，使用单个存储平台消除数据孤岛。通过分层存储和策略管理优化成本。使用 Azure Active Directory (Azure AD) 和基于角色的访问控制 (RBAC) 对数据进行身份验证。借助静态加密和高级威胁防护等安全功能，帮助保护数据。</li>
</ol>
<h3 id="三、数据库服务：（Paas）"><a href="#三、数据库服务：（Paas）" class="headerlink" title="三、数据库服务：（Paas）"></a>三、数据库服务：（Paas）</h3><p>Azure Cache for Redis- 完全托管且兼容开源的内存中数据存储服务，为可缩放的高速应用程序提供支持。</p>
<h3 id="四、容器服务：（Iaas）"><a href="#四、容器服务：（Iaas）" class="headerlink" title="四、容器服务：（Iaas）"></a>四、容器服务：（Iaas）</h3><p>Azure Kubernetes 服务 (AKS)- 使用完全托管的 Kubernetes 服务，更轻松地部署和管理容器化应用程序。Azure Kubernetes 服务 (AKS) 提供无服务器 Kubernetes（一种整合的持续集成和持续交付 (CI/CD) 体验）以及企业级安全性和治理。将开发和运营团队统一到一个平台上，放心地快速生成、交付和缩放应用程序。</p>
<h3 id="五、弹性计算：（Iaas）"><a href="#五、弹性计算：（Iaas）" class="headerlink" title="五、弹性计算：（Iaas）"></a>五、弹性计算：（Iaas）</h3><ol>
<li>Azure 应用服务- 一个用于构建、部署和缩放 Web 应用的完全托管平台。根据自身情况快速构建、部署和缩放 Web 应用和 API。使用容器中或在 Windows/Linux 上 运行的 .NET、NET Core、Node.js、Java、Python 或 PHP。</li>
<li>Azure CycleCloud- 创建、管理、操作并优化任何规模的 HPC 和大型计算群集。</li>
</ol>
<p>​     </p>
<p>​     </p>
<h2 id="Google-Cloud产品："><a href="#Google-Cloud产品：" class="headerlink" title="Google Cloud产品："></a>Google Cloud产品：</h2><ol>
<li>Compute Engine-  可扩缩的高性能通用虚拟机。常见用途：业务线(LOB)应用、往回走哪托管、数据库、大多数工作负载。应用行业：教育、能源、金融、游戏、政府、医疗、生命科学、娱乐媒体、零售、电信。（Iaas）</li>
<li>Migrate for Compute Engine-  可将服务器和虚拟机迁移到Compute Engine的服务(原Velostrata)。常见用途：将应用从本地、多个数据中心或云端迁移到Google Cloud。（Iaas）</li>
<li>Cloud GPU-  可用于机器学习、科学计算和3D可视化的GPU硬件。常见用途：机器学习、医学分析、地震勘探、视频转码、图形可视化、科学模拟。应用行业：游戏、信息技术、生命科学、娱乐媒体。（Iaas）</li>
<li>抢占式虚拟机-  适合批处理作业和容错工作负载的短期运行计算实例，经济实惠。常见用途：短期运行或具备容错性的工作负载、金融建模、渲染、媒体转码、可制造性设计、Hadoop和大数据、持续集成、Web抓取。应用行业：能源、金融、医疗、娱乐媒体、制药。（Iaas）</li>
<li>安全强化型虚拟机-  更加安全的虚拟机。常见用途：抵御rootkit和bootkit攻击、保护企业工作负载、防范远程攻击、权限提升和恶意内部人员。应用行业：金融、物流、制造、娱乐媒体、零售、供应链。（Iaas）</li>
<li>单租户节点-  符合用户的法规遵从需求、许可需求和管理需求的专用硬件。常见用途：自带许可(BYOL)、工作股灾的专用计算能力、助力满足安全和合规需求、满足每个插槽或每个核心的许可需求、查看物理核心的使用情况信息。应用行业：金融、物流、制造、娱乐媒体、零售、供应链。（Iaas）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/16/大数据架构作业-简答题1/" data-id="ckvkw0ou1001gasujf5dfz7es" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-入门JavaSE-中级篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/26/入门JavaSE-中级篇/" class="article-date">
  <time datetime="2020-08-26T09:58:24.000Z" itemprop="datePublished">2020-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/26/入门JavaSE-中级篇/">入门Java其二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>刚看完中级篇的慕课，记录一下笔记。</p>
<h1 id="Javase入门-中级"><a href="#Javase入门-中级" class="headerlink" title="Javase入门 中级"></a>Javase入门 中级</h1><p><a href="https://www.imooc.com/learn/124" target="_blank" rel="noopener">https://www.imooc.com/learn/124</a></p>
<h2 id="C1-类和对象"><a href="#C1-类和对象" class="headerlink" title="C1 类和对象"></a>C1 类和对象</h2><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>类 对象  方法</p>
<h4 id="定义类-（属性-方法）"><a href="#定义类-（属性-方法）" class="headerlink" title="定义类 （属性 方法）"></a>定义类 （属性 方法）</h4><ol>
<li>定义类名(大写)  <code>public class 类名 {</code></li>
<li>属性也叫做实例变量   <code>// 定义属性 （默认为零）</code></li>
<li>方法                              <code>// 定义方法（参照上面，但不用写public等）}</code></li>
<li>ps：注意和 <code>public static void main {}</code> 的区别</li>
</ol>
<h4 id="使用对象的步骤："><a href="#使用对象的步骤：" class="headerlink" title="使用对象的步骤："></a>使用对象的步骤：</h4><ol>
<li>创建对象 <code>type name = new type();</code></li>
<li>调用对象 <code>name.***</code></li>
<li>ps: 同一个包的类，可以在不同的java文件中使用</li>
</ol>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>类中定义，描述对象的作用<br>作用在本类和其他类的方法 默认初始值为零</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在方法中定义，在方法中保存临时数据<br>只作用在本类的方法 不会有默认值</p>
<p>（其实就是作用域的不同）<br><strong>局部变量的优先级更高</strong></p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>ps: 使用 new+构造方法 创建一个新的对象 </p>
<p>构造方法的名称<strong>与类名相同</strong>，没有返回值<br>没有指定构造方法时，默认有一个“空”的构造方法<br>一旦指定了构造方法，系统就不会生成默认构造方法<br><strong>语法：</strong><code>public 构造方法名() {}</code><br>有无参数的构造方法都是可以并存的（重载）</p>
<h4 id="Java中的static-静态"><a href="#Java中的static-静态" class="headerlink" title="Java中的static(静态)"></a>Java中的static(静态)</h4><p><code>static</code>可以实现同一种<code>类</code>的多个<code>对象</code>共用同一个成员(属性)<br>定义：<code>static 类型 变量名 = ***;</code><br>ps: 静态成员可以直接用类名调用, 也可以用对象名调用 后面加<code>.</code>就行</p>
<p><strong>static修饰方法</strong>: 在返回值类型之前 加<code>static</code><br>如： <code>public static void main() {};</code></p>
<ul>
<li>静态方法中可以直接使用静态成员</li>
<li>静态方法调用非静态成员时，需要献出案件类的对象，在访问非静态变量</li>
<li>普通方法则能照抄使用所有成员</li>
<li>静态方法中能直接调用静态方法，非静态方法必须创建对象来访问</li>
</ul>
<p><strong>static 初始化块</strong><br>初始化块: 用于给已经定义了的变量初始化（赋值） 用<code>{}</code>框柱赋值的语句<br>ps：看上去有点low？<br>静态初始化块: 就是在{}前面加 static</p>
<h2 id="C2-封装"><a href="#C2-封装" class="headerlink" title="C2 封装"></a>C2 封装</h2><p>ps 面向对象三大特性： 封装、 继承、 多态<br><strong>封装</strong>：将类的概念隐藏在内部，不允许外部程序访问，通过类的方法，操作和访问隐藏概念</p>
<h4 id="封装的步骤："><a href="#封装的步骤：" class="headerlink" title="封装的步骤："></a>封装的步骤：</h4><ol>
<li>在变量的变量类型前面加 private</li>
<li>创建getter/setter 等类似方法访问属性，返回需要的变量（相当于一个接口）可以用ide自动生动生成</li>
<li>给上述方法加合理性判断（if语句等）</li>
</ol>
<h4 id="使用包管理java类"><a href="#使用包管理java类" class="headerlink" title="使用包管理java类"></a>使用包管理java类</h4><p>包的作用： 管理Java文件、解决同名文件冲突<br>定义包：<code>package &lt;包名&gt;;</code>  放在源程序第一行，包名之间用<code>.</code>隔开，相当于文件层次<br>使用包： <code>import &lt;包名&gt;;</code> 后面加<code>*</code>表示导入子目录的所包<br>ps: 包一般使用 全小写 命名</p>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><table>
<thead>
<tr>
<th align="center">访问范围</th>
<th align="center">本类</th>
<th align="center">同包</th>
<th align="center">子类</th>
<th align="center">其它</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>this代表当前对象，封装对象属性的时候经常使用</p>
<ol>
<li>区分属性和参数的概念（同名区分）</li>
<li>调用当前对象的方法    </li>
</ol>
<h4 id="内部类-Inner-Class"><a href="#内部类-Inner-Class" class="headerlink" title="内部类 Inner Class"></a>内部类 Inner Class</h4><p>定义：一个类内部，再定义类，提供更好的封装（套娃）<br>种类：成员、静态、方法、匿名内部类</p>
<p><strong>成员内部类</strong> 也叫做普通内部类<br>初始化的时候要用 ``&lt;内部类&gt; &lt;对象名&gt; = &lt;外部类&gt;.new &lt;内部类()&gt;<code>成员内部类可以使用外部和内部的所有数据，但外部类不能使用内部成员，如果内外部有同名的变量，内部需要使用外部变量时，需要</code>this<code>关键字(</code>Outer.this.变量名<code>)
ps: 编译程序之后会出现多个</code>.class`文件</p>
<p><strong>静态内部类</strong><br>用static修饰的内部类<br>不能直接访问外部类的 非静态成员，通过 <code>new Outer().成员</code> 访问<br>如果内外部静态成员<strong>同名</strong>，可以通过 <code>Outer.静态成员</code> 访问外部 静态成员，而是不用this关键字<br>创建静态内部类对象的时候，<code>&lt;内部类&gt; &lt;对象名&gt; = new &lt;内部类()&gt;</code> 即可</p>
<p><strong>方法内部类</strong><br>内部类定义在外部类的方法中，只在该方法类可以使用</p>
<h2 id="C3继承"><a href="#C3继承" class="headerlink" title="C3继承"></a>C3继承</h2><h4 id="Java中的继承"><a href="#Java中的继承" class="headerlink" title="Java中的继承"></a>Java中的继承</h4><p>类与类的关系，Java使用单继承，一个子类只有一个父类<br>子类拥有父类的所有属性和方法（<strong>不能是private</strong>）<br>语法： <code>class 子类 extends 父类</code> </p>
<h4 id="Java中方法的重写"><a href="#Java中方法的重写" class="headerlink" title="Java中方法的重写"></a>Java中方法的重写</h4><p>子类可以<strong>重写</strong>继承父类的方法<br>ps: 重写的方法对应的 返回值 方法名 参数列表种类顺序 要和父类相同</p>
<h4 id="继承的初始化顺序"><a href="#继承的初始化顺序" class="headerlink" title="继承的初始化顺序"></a>继承的初始化顺序</h4><p>先初始化父类在初始化子类<br>先进行<strong>属性</strong>的初始化，再进行<strong>构造方法</strong>的初始化（同一变量定义时的赋值会被构造方法的赋值覆盖掉）</p>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>可以修饰类、方法、属性、变量</p>
<ul>
<li>修饰类 该类不能被继承</li>
<li>修饰方法 该方法不能被重写</li>
<li>修饰属性 属性只能在在构造方法或者显示初始化（不能默认隐式初始化）</li>
<li>修饰变量 该变量只能被赋值一次 常量</li>
</ul>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>对象内部使用，可以代表父类对象，用于访问父类对象的属性和方法<br>语法: <code>super.&lt;父类的属性和方法&gt;</code><br><strong>super的应用</strong></p>
<ol>
<li>子类的构造过程中必须调用父类的构造方法 </li>
<li>super();隐式表达  显示表达要放在子类的构造方法的第一行</li>
<li>系统默认调用无参父类构造方法，如果没有无参构造方法，则报错</li>
</ol>
<h4 id="Java的Object类"><a href="#Java的Object类" class="headerlink" title="Java的Object类"></a>Java的Object类</h4><p>Object类是所有类的父类，默认的继承类（没有指定继承对象）<br><strong>Object类定义的属性方法</strong></p>
<ol>
<li><code>toString()</code> 返回对象的哈希code码（内存地址），可以重写成返回对象的属性，ide Source提供了toString的快速重写</li>
<li><code>equals()</code> 比较对象是否指向同一块内存地址，可以重写成比较两个对象的值是否相等，同样ide 提供了快速重写 (利用”==”)<br>ps: 默认的参数是Object obj，访问对象的属性的时候，需要声明为当前对象的类型 (Dog other = (Dog) obj;)<br>pps: 类对象指obj.getClass() 返回类的类型，类的对象指obj类的变量值</li>
</ol>
<h2 id="C4多态"><a href="#C4多态" class="headerlink" title="C4多态"></a>C4多态</h2><h4 id="Java中的多态"><a href="#Java中的多态" class="headerlink" title="Java中的多态"></a>Java中的多态</h4><p><strong>对象的多种形态:</strong> </p>
<ol>
<li>引用多态 父类的对象可以引用本类和子类的对象，反则不行。 (相当于可以用bus初始化交通工具对象 Transp obj = new bus();)</li>
<li>方法多态 创建本类对象时调用本类的方法，引用子类的对象是调用子类重写或者继承之后的方法</li>
</ol>
<h4 id="多态的引用类型转换"><a href="#多态的引用类型转换" class="headerlink" title="多态的引用类型转换"></a>多态的引用类型转换</h4><p>引用类型转换:</p>
<ol>
<li>向上类型转换(隐式/自动 小到大) 上面的父类引用子类对象</li>
<li>向下类型转换(大到小) 有风险 可以加 (类型) 强制类型转换</li>
<li>使用<code>instanceof</code>运算符 避免引用类型转换的安全性问题<br>如: <code>if (animal instanceof Cat) {Cat cat = (Cat) animal}</code> (向下转换)</li>
</ol>
<h4 id="Java的抽象类"><a href="#Java的抽象类" class="headerlink" title="Java的抽象类"></a>Java的抽象类</h4><p>关注子类应该有什么方法，不关注方法的实现，只关注子类的特征<br>抽象类的规则:</p>
<ol>
<li>abstract定义抽象类 public abstract class Obj{};</li>
<li>abstract定义方法，只有声明</li>
<li>抽象类可包含普通方法，可没有抽象方法</li>
<li>抽象类不能直接创建，可以定义引用变量</li>
</ol>
<h4 id="Java的接口"><a href="#Java的接口" class="headerlink" title="Java的接口"></a>Java的接口</h4><p>类是具体实体，接口是类需要遵守的<strong>规范</strong>，提供抽象方法和常量，把具有共同特征的类联系在一起<br>定义: <code>[修饰符] interface 接口名 [extends 父接口1, 父接口2 ...] {}</code><br>系统隐式添加<code>abstract</code>关键字 接口的内容为若干个常量<code>public static final</code>或者若干个抽象方法 <code>public abstract</code><br>调用接口: 类通过<code>implements</code>关键字使用多个接口 ※关键字接在父类的后面<br>ps: 接口命名通常名字前面加 <code>I</code><br>使用接口： 接口可以指向对象，如  <code>IPlayGame ip1 = new SmartPhone();</code> ，即可使用该类的方法，但是要注意指向的类要调用了该接口<br>ps: <strong>接口经常和匿名内部类使用，匿名内部类就是没有名字的内部类</strong><br><strong>语法格式:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Interface i = <span class="keyword">new</span> Interface()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> noid <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"匿名内部类实现接口的方式"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">i.method();  <span class="comment">// 直接调用方法</span></span><br></pre></td></tr></table></figure>

<p>也可以在new语句后面的分号之前，直接<code>.method()</code>调用方法</p>
<p>可以在new语句后面的分号之前，直接<code>.method()</code>调用方法</p>
<h4 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h4><p>编写代码之前设计代码，支持模型化和软件系统开发的图形化语言<br><strong>常用UML图</strong></p>
<ol>
<li>用例图 对象需要的功能</li>
<li>序列图 事件的发生顺序，对象的交互</li>
<li>类图 业务逻辑 类和类的关系</li>
</ol>
<p><strong>UML建模工具</strong></p>
<p>Visio、Rational、Rose…</p>
<h2 id="C5阶段练习"><a href="#C5阶段练习" class="headerlink" title="C5阶段练习"></a>C5阶段练习</h2><p>利用继承和重写实现中国人和美国人对象讲不同的语言</p>
<h2 id="C6综合练习"><a href="#C6综合练习" class="headerlink" title="C6综合练习"></a>C6综合练习</h2><p>项目分析：<br>    数据模型分析 抽象实体分析约束条件<br>    业务模型分析 需要实现的功能 如何实现<br>    显示和流程分析 划分显示部分，分析不同流程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/26/入门JavaSE-中级篇/" data-id="ckvkw0otb000oasujedltxhwn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程语言入门/">编程语言入门</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-入门JavaSE-初级篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/21/入门JavaSE-初级篇/" class="article-date">
  <time datetime="2020-08-21T08:56:42.000Z" itemprop="datePublished">2020-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/21/入门JavaSE-初级篇/">入门Java其一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>最近计划学习一下JavaSE，在爱慕课上找到了三个入门javase的视频，分为初级、中级和进阶。</em></p>
<p><em>下面记录一下听课的笔记。</em></p>
<h1 id="javase入门-初级"><a href="#javase入门-初级" class="headerlink" title="javase入门 初级"></a>javase入门 初级</h1><p><a href="https://www.imooc.com/learn/85" target="_blank" rel="noopener">https://www.imooc.com/learn/85</a></p>
<h2 id="C1-java初体验"><a href="#C1-java初体验" class="headerlink" title="C1 java初体验"></a>C1 java初体验</h2><h4 id="jvm是java虚拟机"><a href="#jvm是java虚拟机" class="headerlink" title="jvm是java虚拟机"></a>jvm是java虚拟机</h4><p>​    相关概念：源文件 编译器 字节码 解释器（jvm包括解释器）</p>
<h4 id="jdk是java开发工具包"><a href="#jdk是java开发工具包" class="headerlink" title="jdk是java开发工具包"></a>jdk是java开发工具包</h4><h4 id="jre是java运行环境"><a href="#jre是java运行环境" class="headerlink" title="jre是java运行环境"></a>jre是java运行环境</h4><h4 id="三者的集合关系：jvm-lt-jre-lt-jdk"><a href="#三者的集合关系：jvm-lt-jre-lt-jdk" class="headerlink" title="三者的集合关系：jvm &lt; jre &lt; jdk"></a>三者的集合关系：jvm &lt; jre &lt; jdk</h4><h2 id="java开发环境"><a href="#java开发环境" class="headerlink" title="java开发环境"></a>java开发环境</h2><h4 id="安装java-jdk后的文件目录"><a href="#安装java-jdk后的文件目录" class="headerlink" title="安装java_jdk后的文件目录"></a>安装java_jdk后的文件目录</h4><blockquote>
<p>jdk<br>    bin<br>        java<br>        javac<br>    lib(库文件)</p>
</blockquote>
<p>其中，java是解释器，javac是编译器，lib存放java的库</p>
<h4 id="设置环境变量（这里可以参照菜鸟教程）"><a href="#设置环境变量（这里可以参照菜鸟教程）" class="headerlink" title="设置环境变量（这里可以参照菜鸟教程）"></a>设置环境变量（这里可以参照菜鸟教程）</h4><ol>
<li>java_home  jdk路径</li>
<li>path  jdk命令文件</li>
<li>classpath  类库文件的位置</li>
<li>java命令后不能跟文件后缀</li>
</ol>
<h4 id="使用IDE开发java程序"><a href="#使用IDE开发java程序" class="headerlink" title="使用IDE开发java程序"></a>使用IDE开发java程序</h4><p>开发步骤</p>
<ol>
<li>创建java项目</li>
<li>创建程序包  右击src new 命名 一般为域名的反向</li>
<li>编写java源程序</li>
<li>运行java程序</li>
</ol>
<h4 id="程序的移植-拷贝项目到另一台电脑导入-（有点low）"><a href="#程序的移植-拷贝项目到另一台电脑导入-（有点low）" class="headerlink" title="程序的移植  拷贝项目到另一台电脑导入 （有点low）"></a>程序的移植  拷贝项目到另一台电脑导入 （有点low）</h4><h4 id="基本经验：多练-多问-动手-总结"><a href="#基本经验：多练-多问-动手-总结" class="headerlink" title="基本经验：多练 多问 动手 总结"></a>基本经验：多练 多问 动手 总结</h4><h2 id="C2-变量和常量"><a href="#C2-变量和常量" class="headerlink" title="C2 变量和常量"></a>C2 变量和常量</h2><h4 id="java的变量命名"><a href="#java的变量命名" class="headerlink" title="java的变量命名"></a>java的变量命名</h4><p>只能以字母 _ $ 开头，不能包含除了_ $ 以外的特殊字符</p>
<h4 id="java变量的种类有-基本变量-和-引用变量"><a href="#java变量的种类有-基本变量-和-引用变量" class="headerlink" title="java变量的种类有 基本变量 和 引用变量"></a>java变量的种类有 基本变量 和 引用变量</h4><ul>
<li>str就是一个典型的<strong>引用型变量</strong>，还有class interface 等</li>
<li><strong>基本变量</strong>和c/c++差不多 但是布尔类型为boolean</li>
<li>基本类型分为 <strong>数值型 字符型 布尔型</strong></li>
<li>ps： 给<strong>float型变量</strong>赋值的时候需要<strong>加f</strong>，否则会默认成double</li>
</ul>
<h4 id="java用final表示常量-一般用大写命名"><a href="#java用final表示常量-一般用大写命名" class="headerlink" title="java用final表示常量 一般用大写命名"></a>java用final表示常量 一般用大写命名</h4><h4 id="java的注释（和c有点不一样）"><a href="#java的注释（和c有点不一样）" class="headerlink" title="java的注释（和c有点不一样）"></a>java的注释（和c有点不一样）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文档注释</span></span><br><span class="line"><span class="comment"> * 可以使用 javadoc 从java文件中提取文档的内容</span></span><br><span class="line"><span class="comment"> * 可以使用 javadoc 标记 生成更加信息的文档信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 单行注释的另一种写法 */</span></span><br></pre></td></tr></table></figure>

<h2 id="C3-常用运算符"><a href="#C3-常用运算符" class="headerlink" title="C3 常用运算符"></a>C3 常用运算符</h2><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><ul>
<li>算术: <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>++</code> <code>--</code> 自运算放左边是先运算再赋值 反则先赋值后运算</li>
<li>赋值: <code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></li>
<li>比较: <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> 只能是数值类型 <code>==</code> <code>!=</code> 可以使引用类型</li>
<li>逻辑: <code>&amp;&amp;</code> <code>||</code> <code>!</code> <code>^</code>(异或(两者只有一个为真才为真))</li>
<li>条件: 双目表达式 <code>*** ? ** : **</code> 和 c++ 类似</li>
<li>ps: 优先级和c++类似 建议查表</li>
<li>ps: java中 <code>/</code> 是整除</li>
</ul>
<h2 id="C4-流程控制"><a href="#C4-流程控制" class="headerlink" title="C4 流程控制"></a>C4 流程控制</h2><h4 id="if-条件判断和c类似"><a href="#if-条件判断和c类似" class="headerlink" title="if 条件判断和c类似"></a>if 条件判断和c类似</h4><ul>
<li>if (){}  else if(){}  else{}  只有一行语句的时候可以不用{}</li>
<li>if 可以嵌套使用</li>
<li>ps:equals()方法用于判断字符串的内容是否相等</li>
</ul>
<h4 id="switch-判断和c类似"><a href="#switch-判断和c类似" class="headerlink" title="switch 判断和c类似"></a>switch 判断和c类似</h4><ul>
<li>switch (){ case &lt;&gt;: &lt;&gt; break; … default: &lt;&gt; }</li>
<li>当switch的值和case的值相等时，开始往下执行，如果没有break会一直向下</li>
<li>switch的表达式必须是整型或字符型 case后面可以是常量或者常量表达式</li>
<li>相同功能的case可以放在一起 后面接同一段代码</li>
</ul>
<h4 id="while循环-do-while循环-for循环-同c-c"><a href="#while循环-do-while循环-for循环-同c-c" class="headerlink" title="while循环  do while循环  for循环 (同c/c++)"></a>while循环  do while循环  for循环 (同c/c++)</h4><h4 id="break跳出整个循环-continue跳出当前循环"><a href="#break跳出整个循环-continue跳出当前循环" class="headerlink" title="break跳出整个循环 continue跳出当前循环"></a>break跳出整个循环 continue跳出当前循环</h4><p>ps: 循环可以嵌套</p>
<h2 id="C5-程序编写小试"><a href="#C5-程序编写小试" class="headerlink" title="C5 程序编写小试"></a>C5 程序编写小试</h2><h4 id="ps-快捷键"><a href="#ps-快捷键" class="headerlink" title="ps: 快捷键"></a>ps: 快捷键</h4><p><code>&#39;syso&#39; alt+/ = System.out.println()</code><br><code>&#39;main&#39; alt+/</code></p>
<h4 id="获取用户输入-Scanner-工具类-java-util-包-需要导入"><a href="#获取用户输入-Scanner-工具类-java-util-包-需要导入" class="headerlink" title="获取用户输入 Scanner 工具类 java.util 包 需要导入"></a>获取用户输入 Scanner 工具类 java.util 包 需要导入</h4><ol>
<li>导入包    import java.util.Scanner;</li>
<li>创建对象    Scanner input = new Scanner(System.in);</li>
<li>调用方法函数    int score = input.nextInt();</li>
<li>ps: println 和 print 不同 前者会换行</li>
</ol>
<h4 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h4><p>可以利用断点（一个小红点） 使用debug模式 stepover进行下一行代码的执行</p>
<h4 id="经验总结-debug"><a href="#经验总结-debug" class="headerlink" title="经验总结 debug"></a>经验总结 debug</h4><p>通过分析明确需求 整理相关知识点 实例实现流程 借助“断点调试”</p>
<h2 id="C6-数组-（和c-c-很像）"><a href="#C6-数组-（和c-c-很像）" class="headerlink" title="C6 数组 （和c/c++很像）"></a>C6 数组 （和c/c++很像）</h2><h4 id="数组的声明和初始化"><a href="#数组的声明和初始化" class="headerlink" title="数组的声明和初始化"></a>数组的声明和初始化</h4><ul>
<li>声明+初始化  &lt;类型&gt;[] 数组名 = {…}; 等价于  &lt;类型&gt;[] 数组名 = new &lt;类型&gt;[] {…};</li>
<li>可以使用索引 从零开始</li>
<li>分配空间   &lt;类型&gt;[] 数组名 = new &lt;类型&gt;[数组长度];</li>
<li>ps: [ ] 可以在类型或数组名后面加</li>
</ul>
<h4 id="使用-Arrays类造作java中的数组"><a href="#使用-Arrays类造作java中的数组" class="headerlink" title="使用 Arrays类造作java中的数组"></a>使用 Arrays类造作java中的数组</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ol>
<li>排序 <code>Arrays.sort(数组名);</code>  ps: 记得import java.util.Arrays;</li>
<li>转换为字符串 <code>Arrays.toString(数组名);</code></li>
<li><code>数组名.length</code> 可以获取数组的长度</li>
</ol>
<h5 id="使用foreach操纵数组"><a href="#使用foreach操纵数组" class="headerlink" title="使用foreach操纵数组"></a>使用foreach操纵数组</h5><p>foreach 是 for 语句的简化版本<br>语法：<code>for (元素类型 元素变量: 遍历对象) {};</code></p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并且初始化二维数组</span></span><br><span class="line">type [][] arrayName = <span class="keyword">new</span> type [rowNum][colNum];</span><br><span class="line">type [][] arrayName = &#123;&#123;...&#125;, ...&#125;;</span><br><span class="line"><span class="comment">// 赋值 </span></span><br><span class="line">arrayName[row][col] = value;</span><br><span class="line"><span class="comment">// 声明的时候可以不指名列数，后面再具体给各行分配列数</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="C7-方法"><a href="#C7-方法" class="headerlink" title="C7 方法"></a>C7 方法</h2><p>一个功能模块，用于解决某个具体问题的代码序列组合</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>访问修饰符 返回值类型 方法名(参数列表) {方法体}</code><br>访问修饰符指定访问权限范围如：<code>public</code>, <code>protected</code>, <code>private</code><br>根据 <strong>返回值类型</strong> 和 <strong>参数列表</strong> 方法可以分为： 无参无返 有参无返 无参有返 有参有返</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>定义方法， 参照上面语法</li>
<li>定义一个方法所在的类的对象</li>
<li>用对象调用类里面定义的方法</li>
<li>对于有返回值的方法，一般要定义一个变量接收返回值，变量类型要对应</li>
<li>对于没有返回值的方法，不能加return语句</li>
<li>对于有参数的方法，参数的类型顺序数量要与形参对应 形参要标类型</li>
</ol>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>同一个类中可以有多个同名的方法，但必须形参的数量类型顺序不一样，和返回值没有关系</p>
<h6 id="建立动态数组-int-nums-new-int-length"><a href="#建立动态数组-int-nums-new-int-length" class="headerlink" title="建立动态数组 int[] nums = new int[length];"></a>建立动态数组 <code>int[] nums = new int[length];</code></h6><h6 id="生成-100-以内的随机数（用到math类）-int-Math-random-100"><a href="#生成-100-以内的随机数（用到math类）-int-Math-random-100" class="headerlink" title="生成 100 以内的随机数（用到math类） (int)(Math.random() * 100)"></a>生成 100 以内的随机数（用到math类） <code>(int)(Math.random() * 100)</code></h6>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/21/入门JavaSE-初级篇/" data-id="ckvkw0otl000xasujaeqmizgm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程语言入门/">编程语言入门</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用photomosaic库实现马赛克拼图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/21/使用photomosaic库实现马赛克拼图/" class="article-date">
  <time datetime="2020-08-21T08:53:02.000Z" itemprop="datePublished">2020-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/21/使用photomosaic库实现马赛克拼图/">使用Python的photomosaic库实现马赛克拼图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近看到有软件实现了用多张图片拼成指定的某一张图片。</p>
<p>基于好奇心理，想自己实现一个，功能类似的程序。（本来是想做成自己头像的）</p>
<p>于是，搜索了一下相关的程序，果然有不少别人已经写好的程序。</p>
<br>

<p>其中看到某个效果很好，用cpp实现的程序，基于本人太菜，没怎么看。</p>
<p>转而看到python可以通过photomosaic库，几行代码就可以实现功能，于是立马就自己试了一试。</p>
<p>简单捣腾几下就实现了需要的效果，果然还是python用起来香。不过东西学起来蜻蜓点水，笔者对于函数的实现原理是一窍不通的。</p>
<br>

<p>下面是效果图：</p>
<p><img src="../pictures/%E4%BD%BF%E7%94%A8photomosaic%E5%BA%93%E5%AE%9E%E7%8E%B0%E9%A9%AC%E8%B5%9B%E5%85%8B%E6%8B%BC%E5%9B%BE/hdog.jpg" alt="hdog"></p>
<p>怎样有无心动？</p>
<br>

<p>下面先贴出代码：</p>
<p>文件结构：</p>
<blockquote>
<p>MakingChatHeads/</p>
<p>​    i_env/</p>
<p>​    srcHead/</p>
<p>​    srcpool/</p>
<p>​    Head.jpg</p>
<p>​    main.py</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py源代码</span></span><br><span class="line"><span class="keyword">import</span> photomosaic <span class="keyword">as</span> pm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''根据一张图，用多张其它图片拼凑为一张马赛克图'''</span></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line">image = pm.imread(<span class="string">'./srcHead/head.jpg'</span>)</span><br><span class="line"><span class="comment"># 定义照片库</span></span><br><span class="line">pool = pm.make_pool(<span class="string">'./srcpool/*.jpg'</span>)</span><br><span class="line"><span class="comment"># 制作马赛克图</span></span><br><span class="line">mosaic = pm.basic_mosaic(image, pool, (<span class="number">220</span>, <span class="number">170</span>))</span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line">pm.imsave(<span class="string">'./HEAD.jpg'</span>, mosaic)</span><br></pre></td></tr></table></figure>

<br>

<p>代码可以说非常简单了，这里简单提一下主要流程：</p>
<ol>
<li>导入photomosaic库</li>
<li>加载需要拼接出来的底图，比如上面图片原来就是一张doge抱着锦鲤的图片</li>
<li>加载拼图的时候使用的素材图，这里需要的图片数目比较多，读取的时候也只需要给出图片统一存放的文件夹</li>
<li>利用多张素材图生成指定底图的马赛克拼接图，其中的参数是横向和纵向拼接图片的数目</li>
<li>保存拼接出来的图片</li>
</ol>
<br>

<p>下面说一下个人拼图的一点心得：</p>
<ol>
<li>根据底图的颜色选择颜色相近的图片，否则出来的效果不太好</li>
<li>素材图的质量不需要很好，否则读取图片的时间会很长很长</li>
<li>拼接的图不要太多，否则看上去会像十字绣；不过拼图数不够多的话，会完全看不出来原图……</li>
<li>尽量选择颜色鲜艳的图片拼图</li>
</ol>
<br>

<p>再来介绍一下photomosaic库：</p>
<p>photomosaic库主要使用机器学习和相似性搜索算法实现，可以根据给定的图片马赛克化，并且可以使用指定的图片进行马赛克填充。</p>
<p>相关函数的用法相信读者光看源代码就能看懂，毕竟python的优势一直是白嫖大佬的函数，所以调用库之后的代码量小的令人发指。</p>
<p>作者python项目的github-url：<a href="https://github.com/danielballan/photomosaic" target="_blank" rel="noopener">https://github.com/danielballan/photomosaic</a></p>
<p>由于创作者的python文档404了，我暂时没能深入了解这个库的其它函数和精细设置的其它参数。（貌似是由于弗洛伊德事件后的美国暴动，导致微软的服务器被偷了？）</p>
<p>另外，有大佬做出了一个Docker化的photomosaic项目。可以通过–randomness, –opacity, –best-k等参数实现更好的马赛克拼接效果。</p>
<p>url：<a href="https://cloud.tencent.com/developer/news/375609" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/375609</a></p>
<br>

<p>最后谈谈自己对这个算法的一些看法：</p>
<p>这个库提供了高度集成的函数，几行代码就可以实现马赛克拼图功能。对于新手来说非常友好。不过，由于函数大部分已经由对方写好。所以，用户不能根据自己的需求，实现自定义的功能。</p>
<p>另外，目前的代码拼接出的拼图会使用大量重复的图片，这一点不知道是素材图太少，还是函数有其它参数需要调整，还有有待发掘。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/21/使用photomosaic库实现马赛克拼图/" data-id="ckvkw0otf000qasujwue4hnzj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/其它/">其它</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于学校校园网挂VPN解决断网问题的个人解读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/28/关于学校校园网挂VPN解决断网问题的个人解读/" class="article-date">
  <time datetime="2020-06-28T11:59:43.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/28/关于学校校园网挂VPN解决断网问题的个人解读/">关于学校校园网挂VPN解决断网问题的个人解读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>从上个学期开始，学校推展网络一体化，三家运营商的网络归入CUMT_STU，师生通过身份认证上网。</p>
<p>一体化之后，宿舍里三家运营商的wifi合并到一起，插网线也只需要往同一排插口接就可以了</p>
<p>而且全校基本实现wifi覆盖，特别宿舍的wifi质量非常好（有爽到）</p>
<p>​    </p>
<p>不过一体化之后，<strong>学校突然限制了同学的上网时段</strong>（工作日晚十一点半后禁网）</p>
<p>不少深夜奋战的同学<strong>只能选择手机开热点</strong></p>
<p>气抖冷，青年何时才能站起来？（不是）</p>
<p>​    </p>
<p>正值众同学半夜断网大喊卧槽之际</p>
<p>有同学发现</p>
<p>在断网时段之前，如果<strong>连接校园网，再挂学校的vpn</strong></p>
<p>居然可以实现 <strong>在禁网时段，照常使用学校的网络上网</strong>！</p>
<p>​    </p>
<p>最近刚学了计算机网络，觉得这个操作应该可以用课本的知识解释。</p>
<p>于是便有了这篇博客。</p>
<p>​    </p>
<p>要解释这个问题，本文打算先说三个基础知识：</p>
<p>终端如何访问外网、学校的网络情况、vpn的原理</p>
<p>然后再结合以上三点，具体说明校园网挂vpn是如何无视时段禁网的。</p>
<p>​    </p>
<p>下面是正文</p>
<p>​    </p>
<p>​    </p>
<h2 id="三个基本的原理"><a href="#三个基本的原理" class="headerlink" title="三个基本的原理"></a>三个基本的原理</h2><p>​    </p>
<h3 id="原理一：终端通过路由器访问外网"><a href="#原理一：终端通过路由器访问外网" class="headerlink" title="原理一：终端通过路由器访问外网"></a>原理一：终端通过路由器访问外网</h3><p>我们常用的家庭网络都是通过双绞线或者wifi，将手机、pc和ipad等终端连接到路由器，才能上网的。</p>
<p><strong>也就是说，如果要上外网，必须要有路由器！</strong></p>
<p><strong>而通过一个一个的路由器，我们最后就可以访问到某个地点放置的服务器！</strong></p>
<p>​    </p>
<p>​    </p>
<h3 id="原理二：学校的CUMT-STU使用多个路由器供学生上网"><a href="#原理二：学校的CUMT-STU使用多个路由器供学生上网" class="headerlink" title="原理二：学校的CUMT_STU使用多个路由器供学生上网"></a>原理二：学校的CUMT_STU使用多个路由器供学生上网</h3><p>在校园内，虽然会有多个同学都使用CUMT_STU上网</p>
<p><strong>但根据认证页面选择的运营商的不同，我们可以选择不同的路由器上网</strong></p>
<p>​    </p>
<p>下面给出上述结论的依据</p>
<p>​    </p>
<p>以下是分别使用，校园网和联通，访问外网的经过的ip地址：</p>
<p><img src="../pictures/%E5%85%B3%E4%BA%8E%E5%AD%A6%E6%A0%A1%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%8C%82VPN%E8%A7%A3%E5%86%B3%E6%96%AD%E7%BD%91%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%A3%E8%AF%BB/%E6%A0%A1%E5%9B%AD%E7%BD%91tracert.png" alt="校园网tracert"></p>
<p><em>使用校园网访问百度经过的路由器（ip地址），可以看到校园网路由器使用的ip地址为 202.119.203.65</em></p>
<p>​    </p>
<p><img src="../pictures/%E5%85%B3%E4%BA%8E%E5%AD%A6%E6%A0%A1%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%8C%82VPN%E8%A7%A3%E5%86%B3%E6%96%AD%E7%BD%91%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%A3%E8%AF%BB/%E8%81%94%E9%80%9Atracert.png" alt="联通tracert"></p>
<p><em>使用联通访问百度经过的路由器（ip地址），可以看到联通的路由器使用的ip地址为 112.85.229.157</em></p>
<p>​    </p>
<p>可以看到，<u>由于选择的两个运营商不同，访问外网使用的ip地址/路由器也完全不同</u>。</p>
<p>另外，<strong>ip地址是对应到路由器的</strong>，注意这点后面我们会用到。</p>
<p>​    </p>
<p>简单来说，就是在学校，只要是通过wifi或者网线，连接到CUMT_STU的同学</p>
<p>根据他们的选择，一共可以连接到<strong>4个路由器</strong>：</p>
<p>移动的、电信的、联通的、校园网的，用于访问外网。</p>
<p>​    </p>
<p>然后，<strong>到了禁网的时段，路由器就不会帮我们向外部发消息，请求服务，所以我们就没法上网了</strong>。</p>
<p>因为在禁网时段，我们没办法进行网络认证，路由器就不会帮我们给<strong>“外部”</strong>发信息。<em>（注意这个外部是伏笔）</em></p>
<p>（这个认证，每隔一段时间都要进行一次，不单单是首次登录就完事的了）</p>
<p>​    </p>
<p>​    </p>
<h3 id="原理三：虚拟专用网VPN的基本原理"><a href="#原理三：虚拟专用网VPN的基本原理" class="headerlink" title="原理三：虚拟专用网VPN的基本原理"></a>原理三：虚拟专用网VPN的基本原理</h3><p>在原理一我们提到：如果要上外网，必须要有路由器。</p>
<p>但是路由器只是上外网的<strong>必要条件</strong>，如果要访问外部网站还有其他条件，比如<strong>访问权限</strong>。</p>
<p>​    </p>
<p>如果所有人都可以随便访问外网的每一个服务器，那互联网大企供内部人员访问的数据库，估计没几分钟就给各路人马给白嫖完了…</p>
<p>​    </p>
<p>所以，<u>当我们访问外部的主机的时候，目标路由器还会判断我们是否有资格访问。</u></p>
<p>​    </p>
<p>当然，比如百度、微博这些网站是不需要特殊权限的，村里通网了就可以访问。</p>
<p>​    </p>
<p>​    </p>
<h4 id="那我们如何获得访问权限？"><a href="#那我们如何获得访问权限？" class="headerlink" title="那我们如何获得访问权限？"></a>那我们如何获得访问权限？</h4><ol>
<li>专门连一条专用的网线过去，其他人不能用（成本高而且浪费资源); ×</li>
<li><strong>使用虚拟专用网VPN！</strong>（终于到重点了！）√</li>
</ol>
<p>​    </p>
<p>vpn的原理很简单，就是把终端发送的信息进行加密，</p>
<p>而只有目标终端那边的路由器才能解密</p>
<p>中间路过的所有路由器都无法解密，（为何中间会有路由器出现，具体见原理一的加粗字）</p>
<p>因此，中间路由器无法截取发送的信息，保证信息中途不会泄露。（只能当纯工具人）</p>
<p>​    </p>
<p>另外，通过vpn，不管我们访问哪个ip地址，我们都会把<strong>所有的网络请求</strong>都先发给目标路由器！</p>
<p>​    </p>
<p><strong>这点非常重要，可以理解为：</strong></p>
<p><strong>通过vpn我们不仅有了访问其他组织内网的通道，我们还获取了<u>连接其他外网的新的路径</u>！</strong></p>
<p>以上就是我们要讲的三个原理，下面就是重点的分析了</p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>​        </p>
<p>上面说了一大堆，那到底为什么校园网挂vpn可以无视时段禁网？？？</p>
<p>​    </p>
<h4 id="现在咱们就来分析一下"><a href="#现在咱们就来分析一下" class="headerlink" title="现在咱们就来分析一下"></a>现在咱们就来分析一下</h4><blockquote>
<p>​    先来看两个结论：<br>​    首先，根据原理二，我们通过校园网认证页面可以选择不同的运营商，<strong>选择不同的路由器</strong>，访问外网；<br>​    其次，根据原理三，我们挂vpn的时候，会把上网的<strong>所有请求</strong>，<u>从自己的路由器发送到学校的路由器</u>；</p>
</blockquote>
<p>​        </p>
<p>下面就是重点了！</p>
<p>​    </p>
<p>我们来看一下，联通挂vpn和我们使用校园网，分别访问百度的截图：</p>
<p><img src="../pictures/%E5%85%B3%E4%BA%8E%E5%AD%A6%E6%A0%A1%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%8C%82VPN%E8%A7%A3%E5%86%B3%E6%96%AD%E7%BD%91%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%A3%E8%AF%BB/%E8%81%94%E9%80%9A%E6%8C%82VPNtracert.png" alt="联通挂VPNtracert"></p>
<p><em>联通挂vpn上网，离开本地的第一个ip地址【2】，即vpn访问的目标路由器地址，为202.119.203.1</em></p>
<p>​    </p>
<p><img src="../pictures/%E5%85%B3%E4%BA%8E%E5%AD%A6%E6%A0%A1%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%8C%82VPN%E8%A7%A3%E5%86%B3%E6%96%AD%E7%BD%91%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%A3%E8%AF%BB/%E6%A0%A1%E5%9B%AD%E7%BD%91tracert.png" alt="校园网tracert"></p>
<p><em>使用校园网上网，离开本地的第一个ip地址【3】，即用户使用的路由器地址，为202.119.203.65</em></p>
<p>​    </p>
<p><strong>有没有发现什么？</strong></p>
<p><strong>校园网和vpn链接过去的ip地址前面的网络号是一样的</strong>！</p>
<p>​    </p>
<p><strong>也就是说，<u>校园网用的路由器 和 vpn的目标路由器 是同一个</u>！！</strong></p>
<p><strong>我们使用校园网和vpn就是通过”同一个路由器”的”不同子网ip”对外网进行访问！</strong></p>
<p>​    </p>
<p>有的同学可能就会问：“那有怎么样？到点了不还是禁网吗？”</p>
<p>​    </p>
<p>然而，根据原理二，在禁网时段，路由器不会帮我们给<strong>“外部”</strong>发信息，但是我们仍然可以<strong>发信息</strong>给路由器。</p>
<p>​    </p>
<p>信息传递给路由器之后，由于我们挂了vpn</p>
<p>校园网路由器就会给目标路由器发认证消息</p>
<p>​    </p>
<p>而vpn的<strong>目标路由器</strong>和<strong>我们使用的路由器</strong>又恰巧是同一个</p>
<p>所以<strong>学校的路由器会自己把认证消息发给自己看</strong>，不需要访问外部的路由器，所以直接无视断网时间段！</p>
<p>​    </p>
<p>最后，我们肯定是可以通过vpn的认证的</p>
<p>​    </p>
<p>于是我们就从子网：202.119.203.65（校园网的ip），<strong>跳到了子网：202.119.203.1（学校教学用的ip）</strong></p>
<p>​    </p>
<p>注意这里的两个子网是<strong>同一个路由器</strong>里的ip地址</p>
<p><strong>而这个过程是无视断网时段的</strong></p>
<p>​    </p>
<p>路由器当然不会在禁网时段内，允许我们使用202.119.203.65访问外网</p>
<p>毕竟我们的校园认证在该时段会失效</p>
<p>​    </p>
<p><strong>可是，通过vpn，我们就可以使用202.119.203.1访问外网</strong>。</p>
<p>​    </p>
<p>而202.119.203.1是一般情况是不会断网的</p>
<p>否则整个学校教学使用的网络都会断掉！</p>
<p>所以这条路线是非常稳定的。</p>
<p>​    </p>
<p><strong>所以，根据断网前不同的操作，在禁网的时段，我们访问外网（比如说上B站），就经历如下流程：</strong></p>
<blockquote>
<p><strong>①不挂vpn，随便选一个运营商的路由器（包括校园网、移动、联通、电信）：</strong></p>
<p>机子:”我要上B站！” –&gt; </p>
<p>运营商的路由器:”我不认识你，凭什么帮你发消息？” –&gt; </p>
<p>机子:”上不了网了，该歇了~”</p>
</blockquote>
<p>​    </p>
<blockquote>
<p><strong>②挂校园vpn，但是选移动、联通、电信的路由器：</strong><br>机子:”歪？（打电话给运营商的路由器）帮我找学校的路由器，我要上B站！” –&gt; </p>
<p>运营商的路由器:”我不认识你，凭什么帮你转接？” –&gt; </p>
<p>机子:”上不了网了，该歇了~”</p>
</blockquote>
<p>​    </p>
<blockquote>
<p><strong>③挂别的vpn，用校园网：</strong><br>机子:”歪？（打电话给校园网的路由器）帮我找学校的路由器！我要上B站！” –&gt; </p>
<p>校园网的路由器:”我不认识你，凭什么帮你转接？” （连不到vpn的目标路由器）–&gt; </p>
<p>机子:”上不了网了，该歇了~”</p>
</blockquote>
<p>​    </p>
<blockquote>
<p><strong>④挂校园vpn，用校园网：</strong><br>机子:”歪？帮我找学校的路由器！我要上B站！” –&gt; </p>
<p>校园网的路由器:”我不认识你，凭什么……” –&gt; </p>
<p><strong>校园网的路由器:”等等，学校路由器不就是我吗？你等下，我看下你是不是会员哈”</strong> –&gt; </p>
<p>“vpn认证成功 “–&gt; </p>
<p>校园网的路由器:”尊贵的客户…您向B站的请求已发出~ “ –&gt; </p>
<p>机子:”收到B站返回的信息，正在生成网页” –&gt; </p>
<p>我:”up主更新啦！爷青回！不歇了！”</p>
</blockquote>
<p>​    </p>
<p>看这里你可能会担心vpn上网的速度可能不能满足普通的上网需求</p>
<p>​    </p>
<p>其实由于此时vpn链接的两个路由器其实是同一个路由器，不用绕远路找目标路由器</p>
<p>这样就能够省去的大量的中间时间，因此速度还是可以的。</p>
<p>​    </p>
<p>最后发一下正常连联通，和挂vpn的校园网速度对比：</p>
<p><img src="../pictures/%E5%85%B3%E4%BA%8E%E5%AD%A6%E6%A0%A1%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%8C%82VPN%E8%A7%A3%E5%86%B3%E6%96%AD%E7%BD%91%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%A3%E8%AF%BB/%E8%81%94%E9%80%9Aspeedtest.png" alt="联通speedtest"></p>
<p><em>使用联通上网用speedtest测试，速度还是非常可观的</em></p>
<p>​    </p>
<p><img src="../pictures/%E5%85%B3%E4%BA%8E%E5%AD%A6%E6%A0%A1%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%8C%82VPN%E8%A7%A3%E5%86%B3%E6%96%AD%E7%BD%91%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%A3%E8%AF%BB/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%8C%82VPNspeedtest.png" alt="校园网挂VPNspeedtest"></p>
<p><em>使用校园网挂vpn好吧……不过，这个速度其实还是够用的了</em></p>
<p>​    </p>
<p>​    </p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>自此，我尽我所能，大概讲了一下我的理解。由于基本功不扎实，上面的说法应该有不少问题，希望大佬及时指正！</p>
<p>如有错误，还请各位读者原谅……</p>
<p>​    </p>
<p>​    </p>
<p>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/28/关于学校校园网挂VPN解决断网问题的个人解读/" data-id="ckvkw0otn0010asujuwxdefms" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其它/">其它</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程语言入门/">编程语言入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/课程作业/">课程作业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目/">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/其它/" style="font-size: 12.5px;">其它</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/后端/" style="font-size: 20px;">后端</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/编程语言入门/" style="font-size: 15px;">编程语言入门</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/课程作业/" style="font-size: 17.5px;">课程作业</a> <a href="/tags/项目/" style="font-size: 10px;">项目</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/29/MySQL导入csv文件导出sql文件/">MySQL导入csv文件导出sql文件</a>
          </li>
        
          <li>
            <a href="/2021/04/27/使用js和后端模糊查询实现搜索提示功能/">使用js和后端模糊查询实现搜索提示功能</a>
          </li>
        
          <li>
            <a href="/2021/04/27/使用Docker部署jar包/">使用Docker部署jar包</a>
          </li>
        
          <li>
            <a href="/2021/04/15/毕节市可视化Java项目博客记录-日期格式的转换/">毕节市可视化Java项目博客记录----日期格式的转换</a>
          </li>
        
          <li>
            <a href="/2021/04/08/工作室技术分享会/">工作室技术分享会</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Miaopashi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>