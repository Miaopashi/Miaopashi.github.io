<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>MPS的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="MPS的个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="MPS的个人博客">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MPS的个人博客">
  
    <link rel="alternate" href="/atom.xml" title="MPS的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MPS的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-大数据架构作业-简答题6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/大数据架构作业-简答题6/" class="article-date">
  <time datetime="2020-11-16T07:19:44.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/大数据架构作业-简答题6/">大数据架构作业-简答题6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>第六次作业又快截止了，DDL驱动的课程作业…</em></p>
<br>

<blockquote>
<h2 id="1-简述大数据处理的三类场景，说明Spark对这三类典型场景的支持。"><a href="#1-简述大数据处理的三类场景，说明Spark对这三类典型场景的支持。" class="headerlink" title="1 简述大数据处理的三类场景，说明Spark对这三类典型场景的支持。"></a>1 简述大数据处理的三类场景，说明Spark对这三类典型场景的支持。</h2></blockquote>
<h3 id="大数据处理的三类场景："><a href="#大数据处理的三类场景：" class="headerlink" title="大数据处理的三类场景："></a>大数据处理的三类场景：</h3><ol>
<li>复杂的批量数据处理；</li>
<li>基于历史数据的交互式查询；</li>
<li>基于实时数据流的数据处理。</li>
</ol>
<br>

<h3 id="Spark对于以上三类场景的支持："><a href="#Spark对于以上三类场景的支持：" class="headerlink" title="Spark对于以上三类场景的支持："></a>Spark对于以上三类场景的支持：</h3><ol>
<li>对于小时级的复杂批量数据处理，可以把批量数据，以有限数据流的形式，使用Spark进行计算处理；</li>
<li>对于分钟级和秒级的已与历史数据的交互式查询，可以使用Spark SQL组件；</li>
<li>对于毫秒级基于实时数据流的数据处理，可以使用Spark Streaming组件。</li>
</ol>
<br>

<br>

<blockquote>
<h2 id="2-简要陈述Spark的运行架构和基本流程。"><a href="#2-简要陈述Spark的运行架构和基本流程。" class="headerlink" title="2 简要陈述Spark的运行架构和基本流程。"></a>2 简要陈述Spark的运行架构和基本流程。</h2></blockquote>
<h3 id="Spark运行架构包括："><a href="#Spark运行架构包括：" class="headerlink" title="Spark运行架构包括："></a>Spark运行架构包括：</h3><ol>
<li>集群资源管理器（Cluster Manager）；</li>
<li>运行作业任务的工作节点（Worker Node）；</li>
<li>每个应用的任务控制节点（Driver）；</li>
<li>工作节点上负责具体任务的执行进程（Executor）。</li>
</ol>
<br>

<h3 id="Spark运行基本流程："><a href="#Spark运行基本流程：" class="headerlink" title="Spark运行基本流程："></a>Spark运行基本流程：</h3><ol>
<li>由Driver创建一个SparkContext，进行资源申请、任务分配和监控，为应用构建基本运行环境；</li>
<li>资源管理为Executor分配资源，启动Executor进程；</li>
<li>由SparkContext根据RDD的依赖关系构建DAG图，进而DAGScheduler可以将DAG图解析成Stage，然后就可以根据Stage把TaskSet交给TaskScheduler；</li>
<li>Executor向SparkContext申请Task，TaskScheduler将Task发放给Executor运行，并且提供应用程序代码；</li>
<li>Task在Executor上运行，把执行结果反馈给TaskScheduler，然后反馈给DAGScheduler，运行完毕写入数据并释放所有资源。</li>
</ol>
<br>

<br>

<blockquote>
<h2 id="3-简要说明Spark中“stage”的概念及其划分方法。"><a href="#3-简要说明Spark中“stage”的概念及其划分方法。" class="headerlink" title="3 简要说明Spark中“stage”的概念及其划分方法。"></a>3 简要说明Spark中“stage”的概念及其划分方法。</h2></blockquote>
<h3 id="Spark中Stage的概念："><a href="#Spark中Stage的概念：" class="headerlink" title="Spark中Stage的概念："></a>Spark中Stage的概念：</h3><p>Stage是Job的基本调度单位。一个Job可分为多组Task，每一组Task被称为一个Stage或者TaskSet。任务集包含的各项任务之间，相互关联但是没有Shuffle依赖。</p>
<br>

<h3 id="Stage的划分方法："><a href="#Stage的划分方法：" class="headerlink" title="Stage的划分方法："></a>Stage的划分方法：</h3><ol>
<li>DAGScheduler在DAG进行反向解析，遇到宽依赖就断开；</li>
<li>解析过程中，遇到窄依赖就把当前的包含的RDD加入到Stage中；</li>
<li>将窄依赖进项划分到同一个Stage中，以便实现流水线计算。</li>
</ol>
<br>

<h3 id="关于宽依赖和窄依赖："><a href="#关于宽依赖和窄依赖：" class="headerlink" title="关于宽依赖和窄依赖："></a>关于宽依赖和窄依赖：</h3><ol>
<li>宽依赖表现为，一个父RDD的单个分区映射到一个子RDD的多个分区；</li>
<li>窄依赖表现为，一个父RDD的单个分区映射到一个子RDD的单个分组，或者多个父RDD的单个分区映射到一个子RDD的单个分区。</li>
</ol>
<br>

<br>

<blockquote>
<h2 id="4-Spark部署在YARN集群上，运行程序有两种模式，请简要叙述。"><a href="#4-Spark部署在YARN集群上，运行程序有两种模式，请简要叙述。" class="headerlink" title="4 Spark部署在YARN集群上，运行程序有两种模式，请简要叙述。"></a>4 Spark部署在YARN集群上，运行程序有两种模式，请简要叙述。</h2></blockquote>
<h3 id="Spark-on-YARN运行程序有两种模式："><a href="#Spark-on-YARN运行程序有两种模式：" class="headerlink" title="Spark on YARN运行程序有两种模式："></a>Spark on YARN运行程序有两种模式：</h3><ol>
<li>Client模式，Spark的Driver运行在客户端中，程序执行期间客户端不能关闭，否则作业会挂掉，主要用于测试环境；</li>
<li>Cluster模式，Spard的Driver运行在Yarn集群上的ApplicationMaster中，可以在应用程序启动后关闭，多用于实际生产环境。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/16/大数据架构作业-简答题6/" data-id="ckiuf46me001ky8ujjwx3bsal" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/12/大数据架构作业-简答题5/" class="article-date">
  <time datetime="2020-11-12T08:17:20.000Z" itemprop="datePublished">2020-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/12/大数据架构作业-简答题5/">大数据架构作业-简答题5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>大数据架构技术，超星第五次作业。</em></p>
<br>

<blockquote>
<h2 id="一、简要说明Hadoop的三大核心组件及其作用。"><a href="#一、简要说明Hadoop的三大核心组件及其作用。" class="headerlink" title="一、简要说明Hadoop的三大核心组件及其作用。"></a>一、简要说明Hadoop的三大核心组件及其作用。</h2></blockquote>
<h4 id="Hadoop的核心组件："><a href="#Hadoop的核心组件：" class="headerlink" title="Hadoop的核心组件："></a>Hadoop的核心组件：</h4><p>分布式文件系统HDFS、分布式计算框架MapReduce和资源调度框架Yarn。</p>
<h4 id="Hadoop各核心组件的作用："><a href="#Hadoop各核心组件的作用：" class="headerlink" title="Hadoop各核心组件的作用："></a>Hadoop各核心组件的作用：</h4><ol>
<li><p>HDFS分布式文件系统把文件分布式存储到多个计算机节点上，再由成千上万的计算机节点构成分布式存储集群。<strong>HDFS实现了如下目标：</strong></p>
<ol>
<li>兼容廉价的硬件设备；</li>
<li>流数据读写；</li>
<li>大数据集，高可扩展性；</li>
<li>简单的文件模型；</li>
<li>强大的跨平台兼容性</li>
</ol>
</li>
<li><p>YARN框架提供资源管理与调度服务。YARN部署在集群中，为集群的各种计算框架提供统一的资源调度管理服务，并且根据各种计算框架的负载需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩。同时，YARN实现了一个集群上不同应用负载混搭，有效提高了集群的利用率。另外，在YARN框架中，不同计算框架可以共享底层存储，避免了数据集跨集群移动。</p>
</li>
<li><p>MapReduce将大规模集群上的并行计算过程抽象为两个函数Map和Reduce。使程序员无需要掌握分布式并行编程的繁琐细节，即可把自己的程序运行在 分布式系统上，实现海量数据的计算。</p>
</li>
</ol>
<br>

<blockquote>
<h2 id="二、简要说明HDFS的体系结构的组成、副本存储策略以及数据读写过程。"><a href="#二、简要说明HDFS的体系结构的组成、副本存储策略以及数据读写过程。" class="headerlink" title="二、简要说明HDFS的体系结构的组成、副本存储策略以及数据读写过程。"></a>二、简要说明HDFS的体系结构的组成、副本存储策略以及数据读写过程。</h2></blockquote>
<h4 id="HDFS的体系结构组成："><a href="#HDFS的体系结构组成：" class="headerlink" title="HDFS的体系结构组成："></a>HDFS的体系结构组成：</h4><ol>
<li>主节点(Master Node)，或者“名称结点”(NameNode)</li>
<li>从节点(Slave Node)，或者“数据节点”(DataNode)</li>
</ol>
<h4 id="HDFS的副本存储策略："><a href="#HDFS的副本存储策略：" class="headerlink" title="HDFS的副本存储策略："></a>HDFS的副本存储策略：</h4><ol>
<li>HDFS将文件分成多个块，以块为存储单位（默认一个块128MB）。</li>
<li>HDFS采用多副本方式，对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上。</li>
<li>HDFS的数据存放：第一个副本，放置在上传文件的数据节点；第二个副本，放置在与第一个副本不同的机架的节点上；第三个副本，与第一个副本相同机架的其他节点上；更多副本，随机节点。</li>
</ol>
<h4 id="HDFS数据读写过程："><a href="#HDFS数据读写过程：" class="headerlink" title="HDFS数据读写过程："></a>HDFS数据读写过程：</h4><ol>
<li><strong>HDFS读数据的过程：</strong><ol>
<li>客户端向DFS执行打开文件操作；</li>
<li>DFS向NameNode获取数据块信息；</li>
<li>客户端向DFS发送文件读取请求；</li>
<li>DFS向DataNode读取数据；</li>
<li>如果读取失败，DFS可能会再次向NameNode获取数据块信息；</li>
<li>如果读取失败，再次获取数据块信息之后，DFS再次向DataNode读取数据；</li>
<li>客户端使用完文件之后，向DFS发送关闭文件请求。</li>
</ol>
</li>
<li><strong>HDFS写数据的过程：</strong><ol>
<li>客户端向DFS发送创建文件请求；</li>
<li>DFS在NameNode创建文件元数据；</li>
<li>客户端在DFS写入数据；</li>
<li>DFS向DataNode写入数据包；</li>
<li>DataNode写入数据包之后，向DFS发送确认包；</li>
<li>客户端向DFS发送关闭文件请求；</li>
<li>DFS向NameNode通知写操作完成。</li>
</ol>
</li>
</ol>
<br>

<blockquote>
<h2 id="三、简要陈述MapReduce的体系结构组成和工作流程。"><a href="#三、简要陈述MapReduce的体系结构组成和工作流程。" class="headerlink" title="三、简要陈述MapReduce的体系结构组成和工作流程。"></a>三、简要陈述MapReduce的体系结构组成和工作流程。</h2></blockquote>
<h4 id="MapReduce的四个组成部分："><a href="#MapReduce的四个组成部分：" class="headerlink" title="MapReduce的四个组成部分："></a>MapReduce的四个组成部分：</h4><ol>
<li>Client：用户编写的MapReduce程序通过Client提交到JobTracker端；</li>
<li>JobTracker：JobTracker负责资源监控和作业调度；</li>
<li>TaskTracker：TaskTracker周期性地通过“心跳”将本节点上资源的使用情况和任务的运行进度汇报给JobTracker，同时接收JobTracker发送过来的命令并执行相应的操作；</li>
<li>Task：Task分为Map Task和Reduce Task，均由TaskTracker 启动。</li>
</ol>
<h4 id="MapReduce工作流程："><a href="#MapReduce工作流程：" class="headerlink" title="MapReduce工作流程："></a>MapReduce工作流程：</h4><p>分片（split）→本地计算（map） → 洗牌（shuffle） → 汇总计算（reduce）</p>
<h4 id="具体工作流程如下："><a href="#具体工作流程如下：" class="headerlink" title="具体工作流程如下："></a>具体工作流程如下：</h4><ol>
<li>划分MapReduce的基本处理单位split，将需要处理的数据分片；</li>
<li>Hadoop为每个split创建一个Map任务，Worker接收数据并且执行Map任务，并将执行结果写入缓存（Map）；</li>
<li>对写入缓存的数据进行溢写和文件归并等操作，把数据输入给Reduce任务（Shuffle）；</li>
<li>Reduce领取数据先放入缓存，来自不同Map机器，先归并，再合并，写入磁盘（Reduce）；</li>
<li>Map和Reduce阶段相互衔接，Shuffle阶段包含在两者之间。</li>
</ol>
<br>

<blockquote>
<h2 id="四、简要陈述YARN体系结构组成、各部分的功能及工作流程。"><a href="#四、简要陈述YARN体系结构组成、各部分的功能及工作流程。" class="headerlink" title="四、简要陈述YARN体系结构组成、各部分的功能及工作流程。"></a>四、简要陈述YARN体系结构组成、各部分的功能及工作流程。</h2></blockquote>
<h4 id="YARN体系结构组成："><a href="#YARN体系结构组成：" class="headerlink" title="YARN体系结构组成："></a>YARN体系结构组成：</h4><ol>
<li>ResourceManager（RM）：全局资源管理器，负责整个系统的资源管理和分配。包括两个组件：调度器 （Scheduler）和应用程序管理器（Applications Manager）；</li>
<li>NodeManager是驻留在YARN集群中的每个节点上的代理；</li>
<li>JobHistoryServer：统一管理YARN历史任务。</li>
<li>WebAppProxyServer： 任务执行时的Web页面代理。</li>
</ol>
<h4 id="YARN工作流程："><a href="#YARN工作流程：" class="headerlink" title="YARN工作流程："></a>YARN工作流程：</h4><ol>
<li>用户编写客户端应用程序并向YARN提交，提交内容包括ApplicationMaster程序、 启动ApplicationMaster的命令、用户程序等；</li>
<li>YARN中的ResourceManager负责接收和处理来自客户端的请求，为应用程序分 配一个容器，在该容器中启动一个ApplicationMaster；</li>
<li>ApplicationMaster被创建后会首先向ResourceManager注册；</li>
<li>ApplicationMaster采用轮询的方式向ResourceManager申请资源；</li>
<li>ResourceManager以“容器”的形式向 提出申请的ApplicationMaster分配资源；</li>
<li>在容器中启动任务（运行环境、脚本）；</li>
<li>各个任务向ApplicationMaster汇报自己的状态和进度；</li>
<li>应用程序运行完成后，ApplicationMaster向ResourceManager的应用程序管理器注销并关闭自己。</li>
</ol>
<br>

<blockquote>
<h2 id="五、说明在Hadoop计算框架下进行程序开发的主要过程。"><a href="#五、说明在Hadoop计算框架下进行程序开发的主要过程。" class="headerlink" title="五、说明在Hadoop计算框架下进行程序开发的主要过程。"></a>五、说明在Hadoop计算框架下进行程序开发的主要过程。</h2></blockquote>
<h4 id="开发流程："><a href="#开发流程：" class="headerlink" title="开发流程："></a>开发流程：</h4><ol>
<li>使用 Maven 创建项目</li>
<li>检查项目的目录结构</li>
<li>将项目导入IDE</li>
<li>配置Hadoop依赖</li>
<li>编写应用逻辑代码</li>
<li>Maven构建/编译项目</li>
<li>提交集群运行程序</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/12/大数据架构作业-简答题5/" data-id="ckiuf46m3001ay8ujhjsp5mhq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用SpringBoot编写一个https网站" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/06/使用SpringBoot编写一个https网站/" class="article-date">
  <time datetime="2020-11-06T14:26:11.000Z" itemprop="datePublished">2020-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/06/使用SpringBoot编写一个https网站/">使用SpringBoot编写一个https网站</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>本周的任务：使用springboot编写一个helloworld网站，并且部署到服务器上。然后配置ssl正式，建立https站点。</em></p>
<br>

<h2 id="先看第一个任务，编写helloWeb并且部署。"><a href="#先看第一个任务，编写helloWeb并且部署。" class="headerlink" title="先看第一个任务，编写helloWeb并且部署。"></a>先看第一个任务，编写helloWeb并且部署。</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>下载并且安装IDEA旗舰版</li>
<li>查看springboot官方文档，根据教程新建hello项目</li>
<li>修改hello项目开放的端口，把项目打包成jar包</li>
<li>配置服务器端的java环境，让项目在服务器上运行</li>
</ol>
<br>

<h3 id="下载并且安装IDEA旗舰版"><a href="#下载并且安装IDEA旗舰版" class="headerlink" title="下载并且安装IDEA旗舰版"></a>下载并且安装IDEA旗舰版</h3><p>由于目前有学生身份，所以认证成功之后就能够免费试用IDEA旗舰版了。</p>
<p>访问Jet Barin官网，下载IDEA，登录一下学生账号之后，就可以试用IDEA编写代码了~</p>
<br>

<h3 id="查看springboot官方文档，根据教程新建hello项目"><a href="#查看springboot官方文档，根据教程新建hello项目" class="headerlink" title="查看springboot官方文档，根据教程新建hello项目"></a>查看springboot官方文档，根据教程新建hello项目</h3><p>进入springboot官网，找到QuickstartGuide，根据教程的内容打开spring initializr。</p>
<p>根据IDEA的提示，选择start.spring.io创建web项目，决定项目名，添加spring web依赖，选择springboot版本（这里我选了2.3.5），等待IDEA下载对应的配置文件之后，项目就自动生成了。</p>
<p>复制文档中的实例代码，结合原来的项目名（hello）进行一些修改，使用IDEA尝试运行springboot项目。出现app运行字样之后，使用浏览器访问localhost:8080/hello，出现Hello World!字样~</p>
<p>另外，使用浏览器访问localhost:8080/hello?name=mps，会出现Hello mps!字样。</p>
<p>可以修改src/resources/application.properties文件，添加<code>server.port=10066</code>语句，修改服务器监听的端口。</p>
<br>

<h3 id="修改hello项目开放的端口，把项目打包成jar包"><a href="#修改hello项目开放的端口，把项目打包成jar包" class="headerlink" title="修改hello项目开放的端口，把项目打包成jar包"></a>修改hello项目开放的端口，把项目打包成jar包</h3><p>根据IDEA自带的maven选项，可以把项目打包成jar包。</p>
<p>打开maven选项卡&gt;hello&gt;Lifecycle&gt;package，可以自动完成打包操作。</p>
<p>打包完成之后可以在项目的target目录看到刚刚打包出来的jar包。</p>
<p>在本地使用window terminal定位到jar包的位置，使用java -jar命令之后，使用浏览器访问localhost:10066/hello，网站正常运行，说明jar包没有问题。</p>
<br>

<h3 id="配置服务器端的java环境，让项目在服务器上运行"><a href="#配置服务器端的java环境，让项目在服务器上运行" class="headerlink" title="配置服务器端的java环境，让项目在服务器上运行"></a>配置服务器端的java环境，让项目在服务器上运行</h3><p>下面使用Xshell控制阿里云的服务器，配置java环境。</p>
<p>具体步骤：</p>
<ol>
<li>在Xshell使用rz命令，传输jdk和前面写好的jar包</li>
<li>tar命令解压jdk的tar包，安装jdk-8u261</li>
<li>使用vim命令，配置java环境变量</li>
<li>运行jar包（可以使用nohup在后台运行）</li>
</ol>
<h4 id="使用Xshell传输jdk和jar包"><a href="#使用Xshell传输jdk和jar包" class="headerlink" title="使用Xshell传输jdk和jar包"></a>使用Xshell传输jdk和jar包</h4><p>这里已经提前再本地下载了jdk1.8.0_261-liunx-x64的tar包了，可以自行访问官网下载。</p>
<p>我使用Xshell对购买的阿里服务器进行操作，下面对于服务器的操作将使用Xshell完成。</p>
<p>服务器安装lrzsz用于传输jdk以便服务器安装。</p>
<p>$ yum install lrzsz -y</p>
<p>安装完成之后，cd到需要存放文件的目录，再使用rz命令会Xshell会弹出文件传输窗口。</p>
<p>$ cd</p>
<p>$ rz</p>
<p>弹窗出现之后，可以选择本地下载的jdk1.8-linux-x64.tar以及前面打包好的jar包，传输到服务器。</p>
<p>另外，学长推荐使用Xftp传输速度更快，下次有机会可以试试。</p>
<h4 id="服务器端解压包，安装jdk-8u261"><a href="#服务器端解压包，安装jdk-8u261" class="headerlink" title="服务器端解压包，安装jdk-8u261"></a>服务器端解压包，安装jdk-8u261</h4><p>使用tar命令，解压刚刚传输的jdk包，到/usr/local/java目录。java目录可以使用mkdir新建。</p>
<p>$ mkdir /usr/local/java</p>
<p>$ tar -zxvf jdk-8u261-linux-x64.tar.gz -C /usr/local/java/</p>
<h4 id="使用vim命令，配置java环境变量"><a href="#使用vim命令，配置java环境变量" class="headerlink" title="使用vim命令，配置java环境变量"></a>使用vim命令，配置java环境变量</h4><p>使用vim命令可以修改环境变量配置文件。</p>
<p>$ vim /etc/profile</p>
<p>在末尾添加如下字段：</p>
<p>export JAVA_HOME=/usr/local/java/jdk1.8.0_261</p>
<p>export PATH=$JAVA_HOME/bin:$PATH</p>
<p>使用source命令使环境变量生效。</p>
<p>$ source /etc/profile</p>
<p>随后，查看java版本。</p>
<p>$ java -version</p>
<p>可以正常看到java的版本，说明java环境配置成功。</p>
<h4 id="运行jar包"><a href="#运行jar包" class="headerlink" title="运行jar包"></a>运行jar包</h4><p>注意，运行jar包之前，需要确保服务器的相关端口是打开的。</p>
<p>可以打开阿里云的控制台，对于服务器所在的实例，看到比如添加安全组的设置选项；</p>
<p>在安全组中，用户可以自行设置需要开放的端口。</p>
<p>这里我已经把端口提前弄好了，就不一一赘述。</p>
<p>现在可以使用java命令，在服务器运行前面传输的jar包了。</p>
<p>$ java -jar &lt;jar包名&gt;</p>
<p>在本地打开浏览器，输入xxx.xxx.xxx.xxx:10066/hello，成功访问hello网站。</p>
<p>说明项目部署成功！</p>
<br>

<p>开始配置ssl之前，需要购买一个域名。</p>
<p>进入阿里云页面，进入产品选项卡，搜索域名注册。</p>
<p>在万网寻找合适的后缀以及关键字，找到心仪的域名，加入清单。</p>
<p>结算清单，完善个人信息模板，产品支付，域名购买成功。</p>
<p>花了5块钱买了一个域名，yysy.xyz感觉还行。</p>
<br>

<p>购买域名之后，还要等待一下审核。</p>
<p>再把helloWeb解析到前面购买的域名上。</p>
<p>打开阿里云的云解析DNS控制台，点击购买的域名，添加记录，选择对应参数即可解析。</p>
<p>现在可以访问<a href="http://www.yysy.xyz:10066/hello，访问hello网站了。" target="_blank" rel="noopener">www.yysy.xyz:10066/hello，访问hello网站了。</a></p>
<br>

<h2 id="下面再看第二个任务，配置SSL证书"><a href="#下面再看第二个任务，配置SSL证书" class="headerlink" title="下面再看第二个任务，配置SSL证书"></a>下面再看第二个任务，配置SSL证书</h2><p>令项目可以在https协议下运行，实现用户安全访问。</p>
<h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>申请ssl证书</li>
<li>配置ssl证书</li>
</ol>
<br>

<h3 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h3><p>要配置ssl证书，首先需要先申请一个证书。</p>
<p>进入阿里云控制台&gt;SSL证书管理控制台，点击购买证书服务（先别慌）；</p>
<p>选择单个域名、DV域名级SSL、免费版、一年，可以看到费用直接归零，于是可以白嫖了。</p>
<p>白嫖ssl证书之后，还要进行证书申请，填写个人信息。</p>
<p>由于我的域名是阿里云买的，所以可以自动DNS验证，验证也是自动完成，证书很快就签发成功了。</p>
<br>

<h3 id="配置SSL证书之前，先解决一个问题："><a href="#配置SSL证书之前，先解决一个问题：" class="headerlink" title="配置SSL证书之前，先解决一个问题："></a>配置SSL证书之前，先解决一个问题：</h3><p>SSL证书签发之后，开始配置证书。</p>
<p>查看阿里云的SSL证书配置文档，发现SSL证书要部署在Nginx、Tomcat、Apache服务器上，而目前的helloWeb是直接是机器终端的java命令跑起来的，似乎没有包装在上述服务器内。</p>
<p>原来SpringBoot项目内置了一个Tomcat服务器，让网站项目可以直接以jar包的形式跑起来，而不需要借助外部服务器。</p>
<p>既然这个SpringBoot项目的Tomcat是内置的，就很难修改它的配置，更难部署SSL证书。</p>
<p>所以配置SSL证书之前，需要先给机器弄一个正式的服务器。</p>
<p>现在给机器配置一个Nginx服务器，顺便实现二级域名映射，摆脱<a href="http://www.yysy.xyz:10066网址后面端口号的束缚。" target="_blank" rel="noopener">www.yysy.xyz:10066网址后面端口号的束缚。</a></p>
<p>安装Nignx</p>
<p>$ sudo yum -y install nginx   # 安装 nginx<br>$ sudo yum remove nginx  # 卸载 nginx</p>
<p>配置Nginx服务</p>
<p>$ sudo systemctl enable nginx # 设置开机启动<br>$ sudo service nginx start # 启动 nginx 服务<br>$ sudo service nginx stop # 停止 nginx 服务<br>$ sudo service nginx restart # 重启 nginx 服务<br>$ sudo service nginx reload # 重新加载配置，一般是在修改过 nginx 配置文件时使用。</p>
<p>查看Nginx运行状态</p>
<p>$ sudo systemctl status nginx</p>
<p>在本地使用浏览器访问机器ip，如果无法访问可以看看是不是阿里云机器的80和443端口没有开放。</p>
<p>在/etc/nginx/nginx.conf修改配置文件，这里先不展开，下面配置ssl证书才详细讲。</p>
<p>现在直接访问<a href="http://www.yysy.xyz/hello，就可以访问到helloWeb啦！" target="_blank" rel="noopener">www.yysy.xyz/hello，就可以访问到helloWeb啦！</a></p>
<br>

<h3 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h3><p>安装了Nginx服务器之后，就可以正式开始配置SSL证书了。</p>
<p>具体步骤：</p>
<ol>
<li>登录阿里云SSL证书控制台，下载Nginx证书；</li>
<li>创建/etc/nginx/cert目录，把下载的pem和key文件拉到cert目录；</li>
<li>修改Nginx配置文件，如下所示</li>
</ol>
<p>$ vim /etc/nginx/nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。</span><br><span class="line">server &#123;</span><br><span class="line">         listen 443 ssl; #配置HTTPS的默认访问端口号为443。此处如果未配置HTTPS的默认访问端口，可能会造成Nginx无法启动。Nginx 1.15.0以上版本请使用listen 443 ssl代替listen 443 ssl和ssl on。</span><br><span class="line">         server_name www.certificatestests.com; #将www.certificatestests.com修改为您证书绑定的域名，例如：www.example.com。如果您购买的是通配符域名证书，要修改为通配符域名，例如：*.aliyun.com。</span><br><span class="line">         root html;</span><br><span class="line">         index index.html index.htm;</span><br><span class="line">         ssl_certificate cert/domain name.pem;  #将domain name.pem替换成您证书的文件名称。</span><br><span class="line">         ssl_certificate_key cert/domain name.key; #将domain name.key替换成您证书的密钥文件名称。</span><br><span class="line">         ssl_session_timeout 5m;</span><br><span class="line">         ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。</span><br><span class="line">         ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。</span><br><span class="line">         ssl_prefer_server_ciphers on;</span><br><span class="line">         location / &#123;</span><br><span class="line">         root html;  #站点目录。</span><br><span class="line">         index index.html index.htm;</span><br><span class="line">                    &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>最后重启一下Nginx就完成配置了~</p>
<br>

<p>配置SSL证书之后，还要进行网站备案。前面已经完成了域名信息的填写和域名持有者的实名认证，但是还没有进行域名持有者过户。</p>
<p>打开阿里云的域名控制台，管理yysy.xyz域名，选择域名持有者过户填写相关信息。</p>
<p>域名信息更新完成之后，网站运行的机器还要等待三个月才能申请备案，因此在Nginx上部署的项目一时半会是不能通过域名访问了……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/06/使用SpringBoot编写一个https网站/" data-id="ckiuf46lg000iy8ujtsili0q2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/05/大数据架构作业-简答题4/" class="article-date">
  <time datetime="2020-11-05T11:57:57.000Z" itemprop="datePublished">2020-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/05/大数据架构作业-简答题4/">大数据架构作业-简答题4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>没想到第四份作业这么快截止…还好题目全都是能在ppt上找到的…</em></p>
<br>

<blockquote>
<p>第一问：简述什么是大数据系统，在建立大数据系统的时候需要考虑权衡哪些需求。</p>
</blockquote>
<p>大数据系统是整合了数据采集和预处理、存储和管理、处理和分析、可视化呈现等大数据处理 功能的高性能、可伸缩、高可用、高容错、安全易用的软硬件系统。可以用于帮助用户发现大数据中潜在有价值的信息和知识，把握业务现实，预测业务走向。</p>
<p>大数据系统的需求特征：</p>
<ol>
<li>数据分析需求，数据分析分为实时数据分析和批量数据分析；</li>
<li>处理方法需求，处理方法分为预测分析、科学分析、查询报告和混杂分析；</li>
<li>数据反馈频率需求，数据反馈分为按需反馈、持续反馈、实时反馈和时间序列；</li>
<li>数据类型需求，数据类型可以分为元数据类型，基本数据类型，历史数据类型和事务缓存数据类型；</li>
<li>数据内容格式需求，数据内容格式可以分为结构化，非结构化和半结构化；</li>
<li>数据来源需求，数据来源分为网站媒体，机器生成，人工产生，内部数据源，交易数据，生物特征数据等等；</li>
<li>数据客户需求，数据客户可以分为普通用户，商业处理，企业应用和数据存储库；</li>
<li>硬件需求，硬件上有廉价硬件和高性能硬件的区分。</li>
</ol>
<p>根据不同的需求特征，具体系统需要具体的权衡取舍。</p>
<br>

<blockquote>
<p>第二问：简述几类典型的大数据系统架构，详细说明Lambda架构和Kappa架构的特点和适用场合。</p>
</blockquote>
<p>常见的大数据系统架构：传统BI架构、批处理架构、流式处理架构、Lambda架构、Kappa架构。</p>
<p>Lambda架构下，数据通过两天路径并行写到流和批处理系统，程序员需要分别针对批和流两条处理路径提供相应的数据计算逻辑，最终通过服务层整合计算结果视图，进行岁外服务的输出。但是该架构下，程序员需要围挡处批处理层和速度层两套系统，并且容易个业务计算逻辑需要在两层实现和运维，数据的查询以及系统的运维比较复杂。适用于：同时存在事实和离线需求的应用情景。</p>
<p>Kappa架构下，通过流处理系统全程处理事实数据和历史数据，数据作为事件流引入到分布式统一日志中，事件流作为实时数据库进入速度层做流式处理，同时事件流在长期存储中保存，必要的时候重播事件流有流计算引擎重新计算历史数据。Kappa架构解决了Lambda架构里的冗余部分，架构简洁，但是事实难度相对较高（尤其是数据重播部分）。适用于：同时存在事实和离线需求的应用情景。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/05/大数据架构作业-简答题4/" data-id="ckiuf46m20018y8ujsqccu14n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/04/大数据架构作业-简答题3/" class="article-date">
  <time datetime="2020-11-04T06:45:47.000Z" itemprop="datePublished">2020-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/04/大数据架构作业-简答题3/">大数据架构作业-简答题3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>大数据架构第三次作业，依然记录一下。</em></p>
<br>

<h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><blockquote>
<p>假设一个企业网需要建设一个后端的缓存集群，用于缓存用户数据加速用户访问速度，因此希望<strong>每个特定的用户最好每次都访问一台固定的服务器节点</strong>，方法是将n台服务器节点编号为0~(n-1)，通过[用户账户 % n]得到访问的服务器编号。但是，如果集群中某台服务器宕机了，则n就变成了n-1，于是取余计算就很可能得不到正确的服务器编号，导致用户请求定位到错误的服务器编号，造成大量的缓存失效。</p>
<p>请设计一种方案来改善这种情况，使得<strong>集群中部分服务器失效后不会造成大面积的缓存失效</strong>；（2）原有的访问大部分还是保持在同一台服务器节点上；（3）负载尽量均衡。</p>
</blockquote>
<p>这里我的思路是，使用<strong>一致性哈希</strong>进行数据分片。</p>
<p>首先，将n个服务器节点，根据对应的编号计算相应的hash值，映射到一个首尾相接的hash环上；然后，再将用户，按照用户账户计算hash值，映射到同一个hash环上；这样，当用户发起访问请求的时候时，根据用户账户在hash环的位置，将用户的请求交给环上顺时针数到的第一个服务器节点。</p>
<p>为了实现要求(3)，需要根据用户账户的hash映射情况，设计合理的hash算法，把n个服务器以对于用户相对均匀地映射到hash环上。</p>
<p>为了实现要求(2)和要求(1)，当一个服务器宕机之后，需要及时在宕机节点的位置，设置一个新的虚拟分身节点。虚拟分身节点对应的物理节点不应该取宕机服务器附近的节点，避免出现数据倾斜和节点雪崩。</p>
<br>

<br>

<h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><blockquote>
<p>简要说明分布式系统中的副本建立策略以及各种策略存在的问题。</p>
</blockquote>
<p>建立副本的策略及其存在问题</p>
<ol>
<li>单主复制，有且仅有一个master副本，其它都是备用的slave副本，维护master副本的节点作为中心节点，负责维护数据更新、并发控制、协调副本的一致性。</li>
</ol>
<ul>
<li>单主复制的问题。可用性问题，master宕机之后，slave竞选、服务切换到新的master都需要时间，这段时间内系统拥塞，无法提供服务；一致性问题，master宕机之后，通过slave竞选出新的master，此时新旧master之间存在尚未同步的数据，导致数据不一致。</li>
</ul>
<ol start="2">
<li>多主复制，所有副本都是master，副本之间户为主从。</li>
</ol>
<ul>
<li>多主复制的问题，在并发操作时，存在数据不一致性问题。</li>
</ul>
<ol start="3">
<li>无主复制，不区分master和slave副本，客户端向多个副本同时发送请求。</li>
</ol>
<ul>
<li>无主复制的问题，尽管客户端可以进行数据补偿，但是依然存在数据不一致性问题。</li>
</ul>
<br>

<br>

<h2 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h2><blockquote>
<p>分布式系统中是否能够在保证副本强一致性的前提下，同时可以获得高可用和容错性。请简要阐述CAP定理和BASE理论的内容和作用。</p>
</blockquote>
<p><strong>CAP定理</strong>：<strong>一个分布式系统不可能同时满足一致性、可用和分区容错性，最多只能满足其中两项。</strong>一致性，所有数据副本的数据都是一致的；可用性，所有请求都能获取正确的响应；分区容错性，即使发生了网络分区，系统也能对外提供满足一致性和可用性的服务。</p>
<p>CAP定理指出了，在分布式系统的设计中，由于分区容错性不能舍弃，因此只能在一致性和可用性之间做出妥协，不能同时兼得三大特性，该定理给出了简明并且可以理解的证明。</p>
<p><strong>BASE原理</strong>：弱化一致性，追求分区容错性和可用性。基本可用，要求系统能够基本运行，一直提供服务，在出现不可预知故障的时候， 允许损失部分可用性，如响应延时或者服务降级；软状态，允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可 用性，即允许不同节点的副本之间存在暂时的不一致情况；最终一致性，要求数据不能一直处于软状态，必须在一段时间后达到一致，保证所 有副本中的数据一致性。</p>
<p>BASE理论的作用，保证最终一致性，对可用性做出让步，代表了追求可用性和分区容错性的分布式系统设计哲学。这种设计模式，对可用性要求比较高但一致性要求不是特别高的应用场景下，提供了高效的理论指导。</p>
<br>

<br>

<h2 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h2><blockquote>
<p>学习Basic Paxos算法，针对5个节点的集群，模仿算法执行过程。假设集群需要完成来自客户端的如下命令，针对该命令模仿说明算法达成一致性的过程。</p>
<p>Put(“x”, 3)</p>
<p>要求仿真出如下场景：（1）节点故障（3）并发操作请求（4）网络分区。</p>
</blockquote>
<p>假设场景：目前有五个节点，分别为node1、node2、node3、node4、node5；其中节点1、2和3和节点4和5进行了网络分区；同一时刻有两个客户端对集群发出并发请求Put(“x”, 3)；目前node3出现了故障，无法响应客户端的请求。</p>
<p>假设node1首先接收到client1的请求，node4首先接收到client2的请求，而且node1比node4更早收到请求。如下图所示</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/a95fbf4d53abf8c7c4c453ff77d8cccd.png" alt="发送请求.png"></p>
<p>node1和node4接收到请求之后成为提案者，开始Basic Paxos算法的准备阶段。node1开始向各个节点发送prepare请求，K值为1。由于各个节点此前还没有进行过同步操作，所以各个节点的MaxN都小于1，则各个节点都会回应pok。但是，由于node3节点故障，无法响应node1的请求，所以node3没有响应。node4节点上的情景和node1相类似，不再重复说明。如下图所示</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/088f1789610696a20ba27c290c5c6c05.png" alt="Prepare.png"></p>
<p>各节点返回pok之后，算法开始第二阶段接收阶段。node1收到了超过半数的pok，开始向各节点发送accept请求，accept(1, Put(“x”, 3))。但是，由于其他节点已经接收了node4的Prepare(2)请求，所以不会再接收提案编号小于2的accept请求，因此其它节点不会响应node1的请求。另一方面，node4发送的accept(2, Put(“x”, 3))，则会被除了目前故障的node3以外的其他节点接收。如下图所示</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/cb9b0ad7e65cfebdba2c659972542141" alt="img"></p>
<p>完成了如上两个阶段之后，所有非故障节点会主动同步提案2到本地，完成Put(“x”, 3)的一致性修改。</p>
<br>

<br>

<h2 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h2><blockquote>
<p>简述分布式系统中建立逻辑时钟的两种方法。</p>
</blockquote>
<p><strong>Lamport时间戳原理规则</strong>：</p>
<ol>
<li><p>每个节点本地都有一个时间戳，初始值为0。</p>
</li>
<li><p>若事件在节点内发生，本地时间戳加1。</p>
</li>
<li><p>若是发送事件，本地时间戳加1并在消息中带上该时间戳。</p>
</li>
<li><p>若是接收事件，本地时间戳 = Max(本地时间戳，消息中的时间戳)+1。</p>
</li>
</ol>
<p><strong>Lamport时间戳具体操作</strong>：</p>
<ol>
<li>假设事件a和b分别发生在节点5和节点3上，时间戳为L(a)和L(b)。</li>
<li>如果L(a) &lt; L(b)，则a发生在b之前，记作 a-&gt;b。</li>
<li>如果L(a) = L(b)，则按事件发生的节点编号排序，3&lt;5，故 b-&gt;a。</li>
</ol>
<br>

<p><strong>向量时钟具体操作:</strong></p>
<ol>
<li>事件a、b分别在节点P、Q上发生，Vector clock分别为Ta、Tb，如果 Tb[Q] &gt; Ta[Q]并且 Tb[P] &gt;= Ta[P]，则a发生于b之前，记作 a -&gt; b。</li>
<li>如果 Tb[Q] &gt; Ta[Q] 并且 Tb[P] &lt; Ta[P]，则认为a、b同时发生，记作 a &lt;-&gt; b。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/04/大数据架构作业-简答题3/" data-id="ckiuf46lw0010y8ujjkivtcc5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习内网穿透" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/08/学习内网穿透/" class="article-date">
  <time datetime="2020-10-08T02:12:54.000Z" itemprop="datePublished">2020-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/08/学习内网穿透/">学习使用frp工具实现内网穿透</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="需要设备"><a href="#需要设备" class="headerlink" title="需要设备"></a>需要设备</h2><ol>
<li>学校分发的虚拟机</li>
<li>一个云服务器</li>
</ol>
<br>

<h2 id="熟悉云服务器"><a href="#熟悉云服务器" class="headerlink" title="熟悉云服务器"></a>熟悉云服务器</h2><p>学生优惠购买了一个实例<br>设置实例密码<br>使用<strong>vnc</strong>链接服务器，发现<strong>login incorrect</strong>，原来是实例密码跟服务器密码不一样，要自己设置一个…<br>通过阿里云的控制台修改服务器密码，重启机子，然后就可以链接啦~<br>后面了解到可以使用<strong>Xshell</strong>代替<strong>workbench</strong>链接到自己的服务器，这个教程很多随便百度都能找到<br><strong>ps:</strong> 通过下文问题一了解到，阿里云服务器通过在控制台设置安全组开启端口。</p>
<br>

<br>

<h2 id="下面正式学习frp"><a href="#下面正式学习frp" class="headerlink" title="下面正式学习frp"></a>下面正式学习frp</h2><h4 id="frp学习参考文章："><a href="#frp学习参考文章：" class="headerlink" title="frp学习参考文章："></a>frp学习参考文章：</h4><ol>
<li><a href="https://sspai.com/post/52523" target="_blank" rel="noopener">https://sspai.com/post/52523</a> =  –”少数派”的博客</li>
<li><a href="https://gofrp.org/" target="_blank" rel="noopener">https://gofrp.org/</a>  –<strong>frp</strong>的官方文档</li>
</ol>
<br>

<h4 id="安装go环境："><a href="#安装go环境：" class="headerlink" title="安装go环境："></a>安装go环境：</h4><p>直接下载<strong>go</strong>对应的版本：<a href="https://golang.org/dl/go1.15.2.linux-amd64.tar.gz" target="_blank" rel="noopener">https://golang.org/dl/go1.15.2.linux-amd64.tar.gz</a><br>也可以使用<strong>wget</strong>命令直接在终端下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.15.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong> 如果想通过<strong>wget</strong>命令下载，貌似需要提前安装git和<strong>gcc</strong>，参考文章1<br>然后参考文章2的提示，通过<code>tar</code>和<code>export</code>命令，完成<strong>go</strong>的安装<br>参考的文章：</p>
<ol>
<li><a href="https://www.jianshu.com/p/21dc1bcf382e" target="_blank" rel="noopener">https://www.jianshu.com/p/21dc1bcf382e</a></li>
<li><a href="https://golang.org/doc/install#requirements" target="_blank" rel="noopener">https://golang.org/doc/install#requirements</a></li>
</ol>
<br>

<h4 id="下载frp"><a href="#下载frp" class="headerlink" title="下载frp"></a>下载frp</h4><p>使用<strong>wget</strong>命令下载<strong>frp</strong>的最新版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.34.0/frp_0.34.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong> 下载的版本错了可以使用rm命令删除，详见博客1<br><strong>pps:</strong> <strong>wget</strong>命令好像跟<strong>yum</strong>命令不一样，配置软件源没有什么用，想配置的可以参考一下博客2<br>参考的博客：</p>
<ol>
<li><a href="https://blog.csdn.net/sqbzo/article/details/8990404" target="_blank" rel="noopener">https://blog.csdn.net/sqbzo/article/details/8990404</a></li>
<li><a href="https://www.jianshu.com/p/541c737bc947" target="_blank" rel="noopener">https://www.jianshu.com/p/541c737bc947</a></li>
</ol>
<br>

<h4 id="启动frps-配置frps端"><a href="#启动frps-配置frps端" class="headerlink" title="启动frps(配置frps端)"></a>启动frps(配置frps端)</h4><p>内网穿透是把自己的终端穿透到有公网ip的服务器上的技术，这里我们先配置<strong>VPS</strong>（有公网ip的服务器），也就是<strong>frps</strong>端，这里我使用了阿里的服务器<br>先使用<strong>tar</strong>命令解压刚下载的frp：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.34.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后cd进该目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.34.0_linux_amd64</span><br></pre></td></tr></table></figure>

<p>检查文件发现目录内除了<strong>fprs</strong>文件还有<strong>frpc</strong>文件，使用rm命令将<strong>frpc</strong>文件一一删除<br>然后修改<strong>frps.ini</strong>文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim frps.ini</span><br></pre></td></tr></table></figure>

<p>文件格式大致如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">vhost_http_port = 10080</span><br><span class="line">vhost_https_port = 100443</span><br><span class="line">dashboard_port = 7500</span><br><span class="line">token = ******</span><br><span class="line">dashboard_user = ms</span><br><span class="line">dashboard_pwd = ********</span><br></pre></td></tr></table></figure>

<p>编辑完成之后保存:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p>然后启动<strong>frps：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>

<p>出现<strong>start</strong>字样，说明<strong>frps</strong>服务启动成功</p>
<br>

<h4 id="问题一：x-x-x-xxx-7500无法连接至控制页面"><a href="#问题一：x-x-x-xxx-7500无法连接至控制页面" class="headerlink" title="问题一：x.x.x.xxx:7500无法连接至控制页面"></a>问题一：x.x.x.xxx:7500无法连接至控制页面</h4><p>运行<strong>frps</strong>之后，使用浏览器访问对应的地址无响应…<br>根据博客2，发现原来是防火墙没有开放服务器指定的端口！<br>查看端口是否开放: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=7500/tcp --zone=public</span><br></pre></td></tr></table></figure>

<p>如果端口开放了就返回<strong>yes</strong>，反则返回<strong>no</strong><br>但是，我返回的是<strong>FirewallD is not running</strong>…<br>百度找到博客3，发现原来服务器没有打开防火墙！<br>根据blog3打开防火墙：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system start firewalld</span><br></pre></td></tr></table></figure>

<p>打开7500端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=7500/tcp</span><br></pre></td></tr></table></figure>

<p>这次再使用<strong>firewall-cmd</strong>命令看端口是否开放，返回的结果居然是<strong>no</strong>…<br>再次百度，根据博客1，发现阿里的服务器需要<strong>另外设置安全组</strong>才能开放相关的端口！<br>根据博客1设置安全组，开放2000到20000的端口<br>重启服务器之后，再次打开防火墙，开放7500端口<br>再次使用<strong>firewall-cmd</strong>检查，这次终于返回yes了<br>访问<strong>x.x.x.xxx:7500</strong>，输入用户密码，成功访问<strong>frp</strong>管理网页！<br>后话：后面配置<strong>frpc</strong>的时候居然要关闭防火墙，所以前面根据博客3和博客2关于防火墙和端口的修改其实没有什么必要，直接使用阿里云的控制平台开放端口才是正解！<br>参考的博客：</p>
<ol>
<li><a href="https://blog.csdn.net/weferxe/article/details/104777838" target="_blank" rel="noopener">https://blog.csdn.net/weferxe/article/details/104777838</a>  –设置阿里云安全组</li>
<li><a href="https://koolshare.cn/forum.php?mod=viewthread&amp;tid=137536&amp;page=1&amp;extra=" target="_blank" rel="noopener">https://koolshare.cn/forum.php?mod=viewthread&amp;tid=137536&amp;page=1&amp;extra=</a>  –开放端口的命令</li>
<li><a href="https://www.cnblogs.com/rxbook/p/8110143.html" target="_blank" rel="noopener">https://www.cnblogs.com/rxbook/p/8110143.html</a>  –控制<strong>linux</strong>的防火墙</li>
</ol>
<br>

<h4 id="使用nohup挂起frps进程"><a href="#使用nohup挂起frps进程" class="headerlink" title="使用nohup挂起frps进程"></a>使用nohup挂起frps进程</h4><p>目前关闭<strong>shell</strong>窗口之后，现在的<strong>frps</strong>进程就会结束<br>为了让<strong>frps</strong>和<strong>frpc</strong>两端一直穿透，需要把<strong>frps</strong>进程挂到后台<br>参考博客1，使用<strong>nohup</strong>命令把进程移动到后台:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure>

<p>同理，后面<strong>frpc</strong>端也要使用nohup挂起进程<br>参考的博客：</p>
<p>同理，后面frpc端也要使用nohup挂起进程<br>参考的博客：</p>
<ol>
<li><a href="https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/</a> –这篇博客还介绍了后台进程的关闭等事项</li>
</ol>
<br>

<h4 id="启动frpc-配置frpc端"><a href="#启动frpc-配置frpc端" class="headerlink" title="启动frpc(配置frpc端)"></a>启动frpc(配置frpc端)</h4><p>上面配置好了<strong>frps</strong>端，下面再配置<strong>frpc</strong>端之后就能实现穿透了！<br>这里我使用学校机房分发的一台虚拟机，作为<strong>frpc</strong>端，同样需要实现安装golang和<strong>frp</strong><br>下载完<strong>frp</strong>的安装包之后，和<strong>frps</strong>端类似，tar解压，然后删除f<strong>rps</strong>文件<br>使用vim命令修改frpc.ini:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure>

<p>文件的格式大致如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line">token = ******</span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = x.x.x.x</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 这里的<strong>local_port</strong>是指frpc机子上<strong>web</strong>进程使用的端口; custom_domains是<strong>frps</strong>端的<strong>ip地址</strong>或者域名，由于我还没买域名，所以这里就填了自己的ip<br>保存之后启动进程: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></table></figure>

<p>进程正常启动，和<strong>frps</strong>端类似，使用nohup把进程挂起，<strong>frpc</strong>端配置就完成了！</p>
<br>

<h4 id="编写一个最简单的web"><a href="#编写一个最简单的web" class="headerlink" title="编写一个最简单的web"></a>编写一个最简单的web</h4><p>现在<strong>frpc</strong>端已经配置完成，还需要写一个web测试一下，<strong>web</strong>服务能否被正常访问<br>远程控制学校分配的虚拟机，使用<strong>python</strong>的flask框架编写一个简单的应用</p>
<br>

<p>安装<strong>python3</strong>和<strong>pip3</strong><br>安装<strong>python3</strong>直接<strong>yum</strong>即可，安装<strong>pip3</strong>可以参照一下文章1<br>使用<strong>pip</strong>安装<strong>flask</strong>： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i [清华源] flask</span><br></pre></td></tr></table></figure>

<p>使用清华源安装<strong>flask</strong>快一点，详细参照文章2<br>完成上面的安装之后就可以开始编写<strong>web</strong>了！<br>参考文章：</p>
<ol>
<li><a href="https://blog.csdn.net/jamieblue1/article/details/89208151" target="_blank" rel="noopener">https://blog.csdn.net/jamieblue1/article/details/89208151</a>  –安装pip</li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a>  –清华</li>
</ol>
<br>

<h4 id="编写app-py"><a href="#编写app-py" class="headerlink" title="编写app.py"></a>编写app.py</h4><p>临时创建一个文件夹<strong>test_flask</strong>，存放app.py<br>根据<strong>flask</strong>的官方文档，文章1，编写一个只返回<strong>‘frp sucess!!!’</strong>的简单应用<br><strong>vim app.py:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'frp sucess!!!'</span></span><br></pre></td></tr></table></figure>

<p>然后保存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p>启动web:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=app.py</span><br><span class="line">python3 -m flask run</span><br></pre></td></tr></table></figure>

<p>然后使用自己的机子访问<strong>x.x.x.x:10080</strong>，显示<strong>‘frp sucess!!!’</strong>，说明内网穿透成功！</p>
<p>参考文章：</p>
<ol>
<li><a href="https://dormousehole.readthedocs.io/en/latest/quickstart.html#id2" target="_blank" rel="noopener">https://dormousehole.readthedocs.io/en/latest/quickstart.html#id2</a></li>
</ol>
<br>

<br>

<p>结语：<br>内网穿透技术可以很好地解决<strong>VPS</strong>配置不足的问题，由于学校机房分配了3台虚拟机，我才想借机利用一下，才学习了<strong>frp</strong>。但是在学习的中途我越发觉得这个技术对于学生来说，能够提供很大的便利，于是把学习的过程记录下来，希望能够帮助到其他人。<br>以后想学习一下<strong>nignx</strong>，尝试一下能否把多个域名映射到一台<strong>VPS</strong>的不同端口，进而穿透到不同的机子，提供多个服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/08/学习内网穿透/" data-id="ckiuf46mb001fy8uj79ce1d3f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-WSLinux之Ubuntu-安装rpm包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/27/WSLinux之Ubuntu-安装rpm包/" class="article-date">
  <time datetime="2020-09-27T02:28:09.000Z" itemprop="datePublished">2020-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/27/WSLinux之Ubuntu-安装rpm包/">Windows Subsystem for Linux之Ubuntu安装rpm包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在看<strong>《springboot实战》</strong>。</p>
<p>看到<strong>springbootCLI</strong>的时候，想要在<strong>windos</strong>子系统的<strong>Ubuntu</strong>上学习一下，所以想要安装<strong>java</strong>。</p>
<p>从同学那里要到了rpm包之后，发现<strong>Ubuntu</strong>居然不能直接安装<strong>rpm</strong>包！</p>
<p>查看社区发现<strong>Ubuntu</strong>是基于<strong>Debian</strong>的系统，不同于<strong>CentOS, RHEL or Fedora</strong>。</p>
<p><strong>Ubuntu</strong>不能直接使用<strong>rpm</strong>命令，而是要通过<strong>alien命令</strong>。</p>
<br>

<h2 id="安装alien可分为三个步骤："><a href="#安装alien可分为三个步骤：" class="headerlink" title="安装alien可分为三个步骤："></a>安装alien可分为三个步骤：</h2><h3 id="一、添加Universe-distribution-component（渣翻：universe组成元件，用于连接universe仓库）"><a href="#一、添加Universe-distribution-component（渣翻：universe组成元件，用于连接universe仓库）" class="headerlink" title="一、添加Universe distribution component（渣翻：universe组成元件，用于连接universe仓库）"></a>一、添加Universe distribution component（渣翻：universe组成元件，用于连接universe仓库）</h3><p>仓库提供软件安装的地址。除了<strong>universe</strong>以外，<strong>Ubuntu</strong>还有<strong>Main</strong>、<strong>Restricted</strong>、Multiverse等仓库。</p>
<p><strong>Universe</strong>仓库提供由社区主导，并且完全开源的软件。这里的alien安装就需要<strong>Universe</strong>仓库。</p>
<p>添加远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br></pre></td></tr></table></figure>

<p>另外，在命令里添加-r选项，可以移除仓库。</p>
<p><strong>注意，如果网络速度太慢可能会导致部分安装错误，最后无法安装alien！所以安装之前先考虑一下网络，有可能需要科学上网。</strong></p>
<br>

<h3 id="二、更新apt的cache"><a href="#二、更新apt的cache" class="headerlink" title="二、更新apt的cache"></a>二、更新apt的cache</h3><p>更新了仓库之后，还要更新<strong>apt</strong>的<strong>cache</strong>才能查找到需要的软件。apt的<strong>cache</strong>用于提供软件安装的地址，如果不更新就自然就找不到对应的包。另外，系统新装的时候也需要更新一下apt。</p>
<p>更新apt：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p><strong>update</strong>命令并不会直接<strong>apt</strong>安装所有软件。如果需要进一步更新软件需要使用upgrade命令。</p>
<br>

<h3 id="三、安装alien包"><a href="#三、安装alien包" class="headerlink" title="三、安装alien包"></a>三、安装alien包</h3><p><strong>alien</strong>用于安装rpm包，具体的安装方法有两种，第四点会一一介绍。</p>
<p>安装<strong>alien</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install alien</span><br></pre></td></tr></table></figure>

<br>

<h3 id="四、安装rpm包"><a href="#四、安装rpm包" class="headerlink" title="四、安装rpm包"></a>四、安装rpm包</h3><p>安装了<strong>alien</strong>之后就可以愉快地安装rpm包。但是这里在说一下，安装<strong>rpm</strong>包有两种方式。</p>
<ol>
<li>把<strong>rpm</strong>转换成deb包再安装</li>
</ol>
<p><strong>alien</strong>命令可以把rpm包变成<strong>deb</strong>包，再安装。这种方法比较推荐。</p>
<p>把当前目录<strong>cd</strong>到<strong>rpm</strong>包所在的目录下，按一下命令执行即可安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo alien packagename.rpm</span><br><span class="line"></span><br><span class="line">sudo dpkg -i packagename.deb</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>直接安装<strong>rpm</strong>包</li>
</ol>
<p>alien也可直接<strong>rpm</strong>包。但是需要注意，这个方法不是<strong>native</strong>（原生）的所以可能会出现一点问题。</p>
<p>直接安装<strong>rpm</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo alien -i packagename.rpm</span><br></pre></td></tr></table></figure>

<br>

<br>

<p>好了，到这里本次分享已经结束。希望能够帮助你。</p>
<br>

<p>参考文章：</p>
<ol>
<li><a href="https://phoenixnap.com/kb/install-rpm-packages-on-ubuntu" target="_blank" rel="noopener">https://phoenixnap.com/kb/install-rpm-packages-on-ubuntu</a></li>
<li><a href="https://help.ubuntu.com/community/Repositories/Ubuntu" target="_blank" rel="noopener">https://help.ubuntu.com/community/Repositories/Ubuntu</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/27/WSLinux之Ubuntu-安装rpm包/" data-id="ckiuf46kz0005y8uju5c1npgm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/26/大数据架构作业-简答题2/" class="article-date">
  <time datetime="2020-09-26T12:05:46.000Z" itemprop="datePublished">2020-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/26/大数据架构作业-简答题2/">大数据架构作业-简答题2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>大数据架构第二次作业出来了，这次照旧记录一下。</em></p>
<br>

<h2 id="容器化技术的核心原理"><a href="#容器化技术的核心原理" class="headerlink" title="容器化技术的核心原理"></a>容器化技术的核心原理</h2><blockquote>
<p><strong>题目：</strong>请从网络下载<strong>virtualbox</strong>软件并安装，然后在<strong>virtualbox</strong>中创建一台或多台虚拟机，尝试在虚拟机中安装<strong>CentOS</strong>或者<strong>Ubuntu</strong>等<strong>Linux</strong>操作系统。在<strong>Linux</strong>操作系统中，测试实现容器的核心技术：<strong>namespace</strong>和<strong>cgroups</strong>两项内核功能，最后在答案部分陈述实验过程、遇到的问题和解决思路、技术原理和实验体会等。</p>
</blockquote>
<br>

<h3 id="使用virtualbox创建Ubuntu虚拟机"><a href="#使用virtualbox创建Ubuntu虚拟机" class="headerlink" title="使用virtualbox创建Ubuntu虚拟机"></a>使用virtualbox创建Ubuntu虚拟机</h3><p>首先在官网下载并安装<strong>virtualbox</strong>，到<strong>Ubuntu</strong>官网：<a href="https://cn.ubuntu.com/download，下载20.04版本的**Ubuntu.ios**文件。然后参考博客安装**Ubuntu**系统。" target="_blank" rel="noopener">https://cn.ubuntu.com/download，下载20.04版本的**Ubuntu.ios**文件。然后参考博客安装**Ubuntu**系统。</a></p>
<p>安装的速度比较慢，有可能是因为机子的配置不够。安装系统提示仍需<strong>8h</strong>的时候，我直接睡觉了…</p>
<p>虚拟机的创建过程很简单，只要根据基本的操作，看看系统安装的步骤很快就可以完成。</p>
<p>考虑到现在<strong>Win10</strong>可以安装<strong>Ubuntu</strong>子系统，其实没有必要非得装一个虚拟机去体验<strong>Linux</strong>。不过以后如果有机会，可以尝试用一下<strong>vbox</strong>安装<strong>windows-xp</strong>，玩一下不兼容的老游戏。</p>
<p>参考博客：<a href="https://blog.csdn.net/u012732259/article/details/70172704" target="_blank" rel="noopener">https://blog.csdn.net/u012732259/article/details/70172704</a></p>
<br>

<p>学习Linux中的容器</p>
<p>容器实现的原理：namespace（实现资源隔离）、cgroups（实现资源控制）（两者是Linux内核功能）</p>
<p>容器是拥有单独命名空间的进程。</p>
<p>Namespace（命名空间）</p>
<p>Namespace定义了一个封闭的作用域范围，约定。Namespace本质是一种资源隔离方案。</p>
<p>处于同一命名空间的进程，只能看到该名字空间下的资源，如主机名、网络、进程、用户、文件系统等。</p>
<p>不同名字空间的进程彼此不可见，互不影响。</p>
<p>每个进程拥有七个命名空间犹豫隔离不同类型的资源：PID Namespace（pid）、CGroup Namespace（cgroup）、IPC Namespace（ipc）、Mount Namespace（mnt）、Network Namespace（net）、User Namespace（user）、UTS Namespace（uts）。</p>
<p>关于namespace的特性可以参考这篇博客：<a href="https://zhengyinyong.com/post/introduction-to-linux-namespace/" target="_blank" rel="noopener">https://zhengyinyong.com/post/introduction-to-linux-namespace/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/26/大数据架构作业-简答题2/" data-id="ckiuf46ly0013y8uj3liq0iag" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-入门JavaSE-进阶篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/23/入门JavaSE-进阶篇/" class="article-date">
  <time datetime="2020-09-23T10:36:08.000Z" itemprop="datePublished">2020-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/23/入门JavaSE-进阶篇/">入门Java其三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>趁热打铁，开始看进阶篇，快速入门。</p>
<h2 id="javase入门-进阶"><a href="#javase入门-进阶" class="headerlink" title="javase入门 进阶"></a>javase入门 进阶</h2><p><a href="https://www.imooc.com/learn/110" target="_blank" rel="noopener">https://www.imooc.com/learn/110</a><br><br><br><br></p>
<h2 id="C1-异常与异常处理"><a href="#C1-异常与异常处理" class="headerlink" title="C1-异常与异常处理"></a>C1-异常与异常处理</h2><h3 id="异常简介"><a href="#异常简介" class="headerlink" title="异常简介"></a>异常简介</h3><p>有错误出现，阻止当前方法或作用域<br><code>Throwable</code>所有异常的父类, 有两个子类</p>
<ol>
<li>Error 虚拟机错误，线程死锁</li>
<li>Exception runtime异常（非检查异常），检查异常</li>
</ol>
<br>

<br>

<h3 id="处理异常-捕获异常"><a href="#处理异常-捕获异常" class="headerlink" title="处理异常(捕获异常)"></a>处理异常(捕获异常)</h3><p><code>try-catch</code>以及<code>try-catch-finally</code>，<code>catch</code>语句捕获异常进行处理，可以有多个<code>catch</code>语句块，先<code>catch</code>异常子类再<code>catch</code>异常的父类，<code>finally</code>是异常处理完之后再执行的语句块。<br>ps：打印异常可以用 <code>e.printStackTrace();</code><br>pps: 原来输入法可以切换中英文标点, 不需要整个输入法切换成英文!</p>
<br>

<h3 id="异常抛出以及自定义异常"><a href="#异常抛出以及自定义异常" class="headerlink" title="异常抛出以及自定义异常"></a>异常抛出以及自定义异常</h3><h4 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h4><p><code>throws</code> 声明僬侥抛出何种类型的异常(声明)<br><code>throw</code> 将产生的异常抛出(动作)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出异常方法示例:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名(参数列表) <span class="keyword">throws</span> 异常列表 &#123;</span><br><span class="line">		<span class="comment">//调用会抛出异常的方法或者throw new Exception();</span></span><br><span class="line">		<span class="comment">//处理没有预先规定的异常种类</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>ps: 异常的处理是多样化的, 捕获异常(try-catch)和抛出异常(throws)只是两种方式,抛出异常一般处理<br><br></p>
<h4 id="自定义的异常"><a href="#自定义的异常" class="headerlink" title="自定义的异常"></a>自定义的异常</h4><p>自定义异常: 自定义一个自己编写的异常种类<br>语法: <code>public class MyException extends Exception {}</code><br>ps: 注意要编写构造方法, 另外父类必须为Exception或者其它子类<br>pps: Exception构造方法输入参数作为报错的名称</p>
<p>ps: 异常的处理是多样化的, 捕获异常(try-catch)和抛出异常(throws)只是两种方式,抛出异常一般处理自定义的异常<br>自定义异常<br>自定义一个自己编写的异常种类<br>语法: public class MyException extends Exception {}<br>ps: 注意要编写构造方法, 另外父类必须为Exception或者其它子类<br>pps: Exception构造方法输入参数作为报错的名称</p>
<br>

<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>目的: 用于推测出最初发生异常的位置<br>示例: 自定义一个异常(喝大了), 一个方法(test1)抛出自定义的异常, 另一个方法(test2)调用这个会抛出异常的方法(test1),捕获异常(喝大了)从而再抛出一个异常(运行时异常), 最后在其它方法调用后一个方法, 则形成了一个异常链(由喝大了引发的运行时异常)<br>ps: throw抛出异常之前必须先throws声明异常<br>pps: 异常使用initCase方法, 引用原始异常</p>
<br>

<h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><ol>
<li>运行时异常, 采用逻辑规避, 用try-catch辅助处理</li>
<li>多重catch块后面, 可以catch(Exception)处理可能遗漏的异常</li>
<li>try-catch,处理潜在的异常</li>
<li>积极根据业务需求和异常类型处理异常, 不要简单打印异常</li>
<li>尽量用finally语句释放占用的资源</li>
</ol>
<br>

<br>

<br>

<h2 id="C2-Java中的字符串"><a href="#C2-Java中的字符串" class="headerlink" title="C2-Java中的字符串"></a>C2-Java中的字符串</h2><h3 id="字符串什么"><a href="#字符串什么" class="headerlink" title="字符串什么"></a>字符串什么</h3><p><code>String</code>对象位于<code>java.lang</code>包中, 默认情况下该包自动导入所有的程序<br>创建<code>String</code>对象方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"imooc"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String();</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"imooc"</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="字符串的不变性"><a href="#字符串的不变性" class="headerlink" title="字符串的不变性"></a>字符串的不变性</h3><p><code>String</code>对象创建后不能修改, 只能直接改变指向的内存, 相当于整个变量对应的内容换掉<br>如果需要可以改变的字符串,可以使用<code>StringBuffer</code>或者<code>StringBuilder</code><br>每次<code>new</code>一个<code>String</code>就是一个新的对象, 所以<code>==</code>的结果为<code>flase</code>, 比较两个字符串内容是否相同时, 应该使用<code>equals()</code>方法, 注意区分<code>==</code>和<code>equals()</code></p>
<br>

<h3 id="String类常用的方法"><a href="#String类常用的方法" class="headerlink" title="String类常用的方法"></a><code>String</code>类常用的方法</h3><p><code>String</code>类提供了很多处理字符串的方法, 获取长度,截取字符串,字符串转换为大小写,字符串分割等等<br>可以参照菜鸟教程的<code>Java中String类</code>的说明:<br><a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-string.html</a><br>ps: <code>equals()</code>, <code>indexOf()</code>, <code>substring()</code>, <code>charAt()</code>用的比较多<br>pps: <code>==</code>判断两个对象内存的地址是否相同, <code>equals()</code>比较两个对象的内容是否相等<br>关于<code>getBytes()</code>方法, 由于汉字有两个字节而且会溢出, 所以转换后得到的字节数是两个负数, <code>asc码</code>则转化为一个数</p>
<br>

<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a><code>StringBuilder</code>类</h3><p>修改字符串时不会额外创建一个对象, <code>StringBuffer</code>是线程安全的, <code>StringBuilder</code>则没有但性能更高, 一般课表字符串对象优先考虑<code>StringBuilder</code><br>定义: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str1 = <span class="keyword">new</span> StringBuilder();  <span class="comment">// 参数""可选</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="StringBuilder类的常用方法"><a href="#StringBuilder类的常用方法" class="headerlink" title="StringBuilder类的常用方法"></a><code>StringBuilder类</code>的常用方法</h3><p><code>append()</code>, <code>inset()</code>方法比较常用<br>同样, 可以参照菜鸟教程:<br><a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-stringbuffer.html</a></p>
<br>

<br>

<br>

<h2 id="C3-Java中的常用类"><a href="#C3-Java中的常用类" class="headerlink" title="C3-Java中的常用类"></a>C3-Java中的常用类</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>为了让基本数据类型(<code>int</code> <code>double</code> <code>float</code>等)具备<strong>对象的特性</strong>, 如属性方法等, Java提供的<strong>类</strong>, (变量由一个数值变成对象)<br><br></p>
<h4 id="包装类主要提供两大方法"><a href="#包装类主要提供两大方法" class="headerlink" title="包装类主要提供两大方法:"></a>包装类主要提供两大方法:</h4><ol>
<li>将本类型和其它基本类型进行转换</li>
<li>将字符串和本类型即包装类互相转换</li>
</ol>
<br>

<br>

<h3 id="基本类型和包装类之间的转换"><a href="#基本类型和包装类之间的转换" class="headerlink" title="基本类型和包装类之间的转换"></a>基本类型和包装类之间的转换</h3><p>装箱: 把<strong>基本类型</strong>转换为包装类, 有<strong>手动装箱</strong>(<code>包装类 x = new 包装类(i)</code>)和<strong>自动装箱</strong>(<code>包装类 x = i</code>)<br>拆箱: 把<strong>包装类对象</strong>转换为<strong>基本类型</strong>, 也有手动(<code>int x = j.intValue()</code>)和自动(<code>int x = j</code>)  ps: <code>.intValue()</code>转为整数, <code>.doubleValue()</code>转为双精度<br>pps: 自动转换只能在一种基本类型和与之对应的包装类之间进行转换</p>
<br>

<h3 id="基本类型和字符串之间的转换"><a href="#基本类型和字符串之间的转换" class="headerlink" title="基本类型和字符串之间的转换"></a>基本类型和字符串之间的转换</h3><h4 id="基本类型转换为字符串"><a href="#基本类型转换为字符串" class="headerlink" title="基本类型转换为字符串:"></a>基本类型转换为字符串:</h4><ol>
<li>使用包装类的toString()方法</li>
<li>使用String类的valueOf()方法</li>
<li>用空字符串加上基本类型, 隐式转换为字符串</li>
</ol>
<br>

<h4 id="将字符串转换为基本类型"><a href="#将字符串转换为基本类型" class="headerlink" title="将字符串转换为基本类型:"></a>将字符串转换为基本类型:</h4><ol>
<li>调用包装类的<code>ParseXxx</code>静态方法  (比如: <code>int a = Integer.parseInt(str);</code>)</li>
<li>调用包装类的<code>valueOf()</code>方法转换为对应的包装类, 再自动拆箱  (比如: <code>int a = Integer.valueOf(str);</code>)</li>
</ol>
<br>

<br>

<h3 id="使用Date和SimpleDateFormat类表示时间"><a href="#使用Date和SimpleDateFormat类表示时间" class="headerlink" title="使用Date和SimpleDateFormat类表示时间"></a>使用<code>Date</code>和<code>SimpleDateFormat</code>类表示时间</h3><p><code>Date类</code>在<code>java.util</code>包中, 用于获取当前时间, <strong>默认无参构造方法初始化</strong><br><code>SimpleDateFormat类</code>在<code>java.text</code>包中, 可以将日期转换为指定格式的文本<br>示例:</p>
<ol>
<li><h4 id="使用format-转换日期的显示格式"><a href="#使用format-转换日期的显示格式" class="headerlink" title="使用format()转换日期的显示格式"></a>使用<code>format()</code>转换日期的显示格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String today = sdf.format(d);</span><br><span class="line">System.out.println(today);</span><br></pre></td></tr></table></figure>

<p><code>&quot;yyyy-MM-dd HH:mm:ss&quot;</code>指定日期格式, 读取时期, 把日期转化为指定的格式</p>
<p>“yyyy-MM-dd HH:mm:ss”指定日期格式, 读取时期, 把日期转化为指定的格式</p>
</li>
<li><h4 id="使用parse-方法将文本转换为日期"><a href="#使用parse-方法将文本转换为日期" class="headerlink" title="使用parse()方法将文本转换为日期"></a>使用<code>parse()</code>方法将文本转换为日期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String day = <span class="string">"2020年8月28日 11:48:16"</span></span><br><span class="line">SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">Date date = df.parse(day);</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure>

<p><code>parse</code>根据指定的格式<strong>反过来读取字符串, 从而获得日期</strong></p>
<p>ps: 调用<code>SimpleDateFormat</code>对象的<code>parse()</code>方法可能会出现<strong>转换异常</strong>, <code>ParseException</code>, 因此<strong>需要异常处理</strong><br>使用<code>Date类</code>需要导入<code>java.util</code>包, 使用<code>SimpleDateFormat类</code>需要导入<code>java.text</code>包</p>
<p>parse根据指定的格式反过来读取字符串, 从而获得日期<br>ps:<br>调用SimpleDateFormat对象的parse()方法可能会出现转换异常, ParseException, 因此需要异常处理<br>使用Date类需要导入java.util包, 使用SimpleDateFormat类需要导入java.text包</p>
<p><br><br></p>
</li>
</ol>
<h3 id="Calendar类的应用"><a href="#Calendar类的应用" class="headerlink" title="Calendar类的应用"></a><code>Calendar类</code>的应用</h3><p><code>Date类</code>只要用于获取当前时间, <strong>推荐使用<code>Calendar类</code>进行时间和日期的处理</strong><br><code>java.util.Calendar类</code>是一个<strong>抽象类</strong>, 可调用<code>getInstance()</code>静态方法获取<code>Calendar对象</code>, 如 <code>Calendar c = Calenar.getInstance();</code><br><br></p>
<h4 id="常用方法和属性"><a href="#常用方法和属性" class="headerlink" title="常用方法和属性:"></a>常用方法和属性:</h4><ol>
<li><code>Calendar类</code>有<code>YEAR</code>,<code>MONTH</code>,<code>DAY_OF_MONTH</code>等静态常量, </li>
<li>调用<code>getInstance()</code>获取一个实例, </li>
<li>调用<code>get()</code>方法获取日期信息, <code>getTime()</code>方法获取<code>Date对象</code>, </li>
<li>通过<code>getTimeInMillis()</code>方法获取<code>Calendar</code>时间值(以毫秒为单位)</li>
</ol>
<br>

<h3 id="使用Math类操作数据"><a href="#使用Math类操作数据" class="headerlink" title="使用Math类操作数据"></a>使用Math类操作数据</h3><p><code>java.lang.Math类</code>包含基本数学运算的方法, 因为所有方法都是<strong>静态方法</strong>, 所以可以直接按 ``类名.方法名` 使用<br><br></p>
<h4 id="可以参照一下菜鸟教程的相关介绍"><a href="#可以参照一下菜鸟教程的相关介绍" class="headerlink" title="可以参照一下菜鸟教程的相关介绍:"></a>可以参照一下菜鸟教程的相关介绍:</h4><p><a href="https://www.runoob.com/java/java-number.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-number.html</a></p>
<br>

<br>

<br>

<h2 id="C4-Java中的集合框架-上"><a href="#C4-Java中的集合框架-上" class="headerlink" title="C4  Java中的集合框架(上)"></a>C4  Java中的集合框架(上)</h2><h3 id="集合框架概述"><a href="#集合框架概述" class="headerlink" title="集合框架概述"></a>集合框架概述</h3><p><strong>容器的概念:</strong>  把若干种属性(数目, 种类不一定)存储起来, 就是集合, 是一种工具类存储共同属性种类的对象</p>
<h4 id="容器的作用"><a href="#容器的作用" class="headerlink" title="容器的作用:"></a>容器的作用:</h4><ol>
<li>在类的内部, 对组织数据</li>
<li>简单快速的都说大量条目</li>
<li>一个序列, 方便插入取出某些属性</li>
<li>有的集合提供了映射关系(类似py的字典), 方便了查询</li>
</ol>
<br>

<h3 id="java提供集合的接口"><a href="#java提供集合的接口" class="headerlink" title="java提供集合的接口"></a>java提供集合的接口</h3><ol>
<li><code>Collection</code>: <code>List</code> -<code>ArrayList</code>, <code>Set</code> -<code>HashSet</code>, <code>Queue</code> -<code>LinkedList</code>  (存储的元素是对象)</li>
<li><code>Map</code>: <code>HashMap</code> (存储的元素是键值对, <code>Entry</code>)</li>
</ol>
<br>

<br>

<h3 id="Collection接口-子接口和实现类-看看前面复习一下什么是接口"><a href="#Collection接口-子接口和实现类-看看前面复习一下什么是接口" class="headerlink" title="Collection接口, 子接口和实现类 (看看前面复习一下什么是接口)"></a>Collection接口, 子接口和实现类 (看看前面复习一下什么是接口)</h3><p>Collection集合中, 讲一下List子接口和Set子接口<br><br><br></p>
<h3 id="List接口："><a href="#List接口：" class="headerlink" title="List接口："></a>List接口：</h3><p>List接口的实现类-<code>ArrayList类</code>(类似python列表)<br><code>ArrayList</code>是<strong>数组</strong>序列, 接口和实现类的关系可以参照: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List test = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>

<br>

<h4 id="下面说明一下List增删改查用到的方法"><a href="#下面说明一下List增删改查用到的方法" class="headerlink" title="下面说明一下List增删改查用到的方法:"></a>下面说明一下List增删改查用到的方法:</h4><h4 id="为列表添加对象"><a href="#为列表添加对象" class="headerlink" title="+ 为列表添加对象:"></a>+ 为列表添加对象:</h4><p><code>&lt;ls&gt;.add()</code>方法可以把一个对象添加到List中,<br><code>&lt;ls&gt;.get()</code>方法可以根据索引从List中取出对象,<br>※ 使用add方法, 把对象存入集合时, 默认会变成Object类型.<br>※ 所以get方法取出对象时, 需要类型转化, 在前面加 (强转类型)<br><code>&lt;ls&gt;.add(index, element)</code>方法可以把对象添加到指定的位置<br>※ 如果index大于ls的长度, 会报错IndexOutOfBoundException<br><code>&lt;ls&gt;.addAll()</code>方法可以把一个List添加到ls中,<br><code>Arrays.asList()</code>方法可以把一个数组转化为一个List.<br><code>&lt;ls&gt;.addAll(index, List)</code> 可以指定List插入的位置</p>
<br>

<h4 id="为列表修改对象"><a href="#为列表修改对象" class="headerlink" title="+ 为列表修改对象:"></a>+ 为列表修改对象:</h4><h5 id="遍历列表的三个方法"><a href="#遍历列表的三个方法" class="headerlink" title="遍历列表的三个方法:"></a>遍历列表的三个方法:</h5><ol>
<li><p><code>&lt;ls&gt;.size()</code>方法可以取得List的长度, 用于遍历List;</p>
</li>
<li><p>通过迭代器遍历List, 使用<code>Iterator</code>接口, <code>Iterator it = &lt;ls&gt;.iterator()</code> 获取迭代器, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用while循环遍历List迭代器中的对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;&lt;Class&gt; temp = (Class) it.next();&#125;</span><br></pre></td></tr></table></figure>

<p>※ 集合都具有iterator方法, 迭代器依赖集合存在</p>
</li>
<li><p>使用<code>forEach</code>方法遍历List, 由于在没有指定泛型时, 对象存放在集合中, 会变成Object, 所以应该用 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object obj: &lt;ls&gt;) &#123;<span class="comment">// 记得使用类型强转&#125;.</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="修改List的元素"><a href="#修改List的元素" class="headerlink" title="修改List的元素"></a>修改List的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ls&gt;.set(index, element);  <span class="comment">// 把相应位置的对象修改成新的对象</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="为列表删除对象"><a href="#为列表删除对象" class="headerlink" title="+ 为列表删除对象:"></a>+ 为列表删除对象:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ls&gt;.remove(index);  <span class="comment">// 删除相应索引位置的元素, 不能超出长度范围</span></span><br><span class="line">&lt;ls&gt;.remove(element);  <span class="comment">// 删除指定的对象</span></span><br><span class="line">&lt;ls&gt;.removeAll(Collection ls)  <span class="comment">// 删除指定集合的所有元素, 类似求差</span></span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="使用泛型-Generic-为列表处理不是对象的变量-比如字符串等等"><a href="#使用泛型-Generic-为列表处理不是对象的变量-比如字符串等等" class="headerlink" title="使用泛型(Generic), 为列表处理不是对象的变量(比如字符串等等):"></a>使用泛型(Generic), 为列表处理不是对象的变量(比如字符串等等):</h3><p><code>&lt;ls&gt;.add(OtherClass)</code> 不会报错, 但是后面使用<code>forEach</code>打印的时候, 使用了<strong>强制类型转换</strong>, <code>String</code>不能转化为<code>Course</code>, 所以还是会报错. <strong>为了能够避免向集合加入其它类型的对象, 就要使用到泛型.</strong><br>※ 集合中的元素, 可以使用<strong>任意类型</strong>的对象(对象的引用), 把放入的对象当做<code>Object</code>处理; <strong>泛型</strong>则是规定了某个<strong>集合只可以存放特定类型</strong>的对象及其子类型的对象, 可以<strong>直接指定类型</strong>获取集合元素.<br><br></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Class&gt; ls;  <span class="comment">// 使用&lt;Class&gt;指定泛型类型, 界定符一般要使用private</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.ls = <span class="keyword">new</span> ArrayList&lt;Class&gt;();  <span class="comment">// 初始化的时候仍然需要指明泛型</span></span><br></pre></td></tr></table></figure>

<p>※ 此时<code>get()</code>方法或者遍历ls时, 不需要强制转换类型了<br>※ 指定泛型之后的集合, 还能存储泛型的<strong>子类型</strong>的对象实例, 即可以<code>&lt;ls&gt;.add(new 
ChildClass());</code><br>※ <strong>泛型只能使用引用类型</strong>, 不能使用基本类型(int,char …), 如果有必要也只能用包装类, 指定泛型为包装类之后<code>&lt;ls&gt;.add(temp)</code> 会对<u>基本类型temp变量</u>进行<strong>隐式</strong>类型转换 (比如 int 变成 Interger).<br><br></p>
<h4 id="Set接口："><a href="#Set接口：" class="headerlink" title="Set接口："></a>Set接口：</h4><p><code>Set</code>接口实现类–<code>HashSet类</code>(类似数学里面的集合)<br>※ Set<strong>无序</strong>并且<strong>不可重复</strong><br>※ Set接口同样提供<code>add()</code>, <code>remove()</code>, <code>removeAll()</code>, <code>size()</code>等方法.<br>※ 但是由于Set无序, 所以<u>不提供<code>set()</code>方法和<code>get()</code>方法</u>, 如果想要调用Set内部的元素, 可以使用<code>foreach</code>和<code>Iterator</code>的方式遍历Set, 不过要注意Set是无序的, 多次遍历的顺序会改变.<br>※ Set也可以使用泛型, 使用方法同Collection<br>※ Set中可以添加空对象null<br><br></p>
<br>

<br>

<h2 id="C5-Java中的集合框架-中"><a href="#C5-Java中的集合框架-中" class="headerlink" title="C5  Java中的集合框架(中)"></a>C5  Java中的集合框架(中)</h2><h3 id="Map-amp-HashMap"><a href="#Map-amp-HashMap" class="headerlink" title="Map &amp; HashMap"></a>Map &amp; HashMap</h3><p><code>Map接口</code>提供了映射关系(键值对), 键值对以<code>Entry类</code>存在, <code>key</code>不可重复, <code>Map</code>支持泛型 比如: <code>Map&lt;typeOfK, typeOfV&gt;</code><br><code>HashMap类</code>是<code>Map</code>的一个实现类, <code>HashMap</code>中的<code>Entry对象（单个键值对）</code>无序排列, 基于哈希表实现, <code>Key</code>和<code>value</code>值可以为null, 不过Key为null时不能重复.<br><br></p>
<h3 id="Map-的增删改查"><a href="#Map-的增删改查" class="headerlink" title="Map 的增删改查:"></a>Map 的增删改查:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;.get(Key);  <span class="comment">// 返回Key的索引结果, 没有找到Key则放回null</span></span><br><span class="line">&lt;map&gt;.put(Key, value);  <span class="comment">// 添加映射, 注意要符合原来定义的泛型</span></span><br><span class="line">&lt;map&gt;.size();  <span class="comment">// 返回map的容量</span></span><br><span class="line">&lt;map&gt;.keySet();  <span class="comment">// 返回map中所有key的Set集合</span></span><br></pre></td></tr></table></figure>

<p>※ keySet方法返回Set对象(有序)之后, 可以进一步用来遍历等操作<br>※ keyList()等方法的用法类似<br><br><br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;.remove(key);  <span class="comment">// 删除Map中的映射</span></span><br><span class="line">&lt;map&gt;.entrySet();  <span class="comment">// 返回所有键值对的Set集合</span></span><br></pre></td></tr></table></figure>

<p>※ 使用entrySet()返回的对象需要制定泛型, 比如: <code>Set&lt;Entry&lt;String, Student&gt;&gt; entrySet = students.entrySet();</code><br>※ 当一个类类型定义过泛型之后, 每次调用该类都要注意是否有写该类的泛型<br>※ <code>Entry</code>对象, 使用<code>getKey()</code>方法获取键, 使用<code>getValue()</code>方法获取值, 一个entry就是一个键值对<br><br></p>
<br>

<br>

<h2 id="C6-Java中的集合框架-下"><a href="#C6-Java中的集合框架-下" class="headerlink" title="C6  Java中的集合框架(下)"></a>C6  Java中的集合框架(下)</h2><h3 id="检测某个对象是否包含在序列内"><a href="#检测某个对象是否包含在序列内" class="headerlink" title="检测某个对象是否包含在序列内"></a>检测某个对象是否包含在序列内</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ls&gt;.contains(obj);  <span class="comment">// 检测一个List内是否包含对象obj, 存储的内容相同不代表对象相同</span></span><br></pre></td></tr></table></figure>

<p>※ <code>List</code>对象的<code>contains()</code>方法 相当于遍历序列, 把序列中的每一个元素使用一次<code>equals(obj)</code>, 进行判断, <code>equals方法</code>可以参照前面第二季的笔记<br>※ 可以通过重写(<code>@override</code>)<code>equals()</code>改变<code>contains()</code>的判断逻辑, 比如说比较两个对象的<code>name属性</code>是否相等, 从而找到序列中有相同name属性的元素<br>※ 使用<code>&lt;ls&gt;.containsAll(Collection&lt;?&gt; c)</code>可以实现检测一个序列内是否包含多个对象<br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;set&gt;.contains(obj);  <span class="comment">// 检测一个Set内是否包含对象obj</span></span><br></pre></td></tr></table></figure>

<p>※ 注意<code>Set</code>对象的<code>contains</code>方法, 会先调用<code>hashCode</code>方法。<strong>在判断两个对象的哈希码是否相同的情况下,  再调用equals方法判断两个对象的值是否相等</strong>.<br>※ 同样可以通过重写的<code>hashCode方法</code>和<code>equals方法</code>, 自定义的Set对象的contains方法.<br>※ <code>IDE</code>可以提供<code>hashCode</code>和<code>equals</code>方法的<em>重写模板</em><br><br></p>
<h3 id="获取序列中元素的位置"><a href="#获取序列中元素的位置" class="headerlink" title="获取序列中元素的位置"></a>获取序列中元素的位置</h3><p>使用<code>indexOf方法</code>，<em>获取序列中某元素的索引位置</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;collection&gt;.indexOf(sth1)</span><br></pre></td></tr></table></figure>

<h5 id="indexOf方法实现机制："><a href="#indexOf方法实现机制：" class="headerlink" title="indexOf方法实现机制："></a>indexOf方法实现机制：</h5><ol>
<li>遍历序列内部的元素，调用equals方法；</li>
<li>如果出现了相同的元素，就放回序列中首个对应元素的索引。</li>
<li>如果无匹配结果，则返回-1。<br>ps: 使用lastIndexOf方法，获取序列中某个元素最后一次出现的索引位置。</li>
</ol>
<br>

<h3 id="判断某个映射是否包含在Map内"><a href="#判断某个映射是否包含在Map内" class="headerlink" title="判断某个映射是否包含在Map内"></a>判断某个映射是否包含在Map内</h3><p>在<code>Map</code>中，使用<code>containsKey</code>方法，判断<code>Map</code>是否包含某个<code>Key</code>；使用<code>containsValue</code>方法判断是否包含某个<code>Value</code>值。返回<code>true</code> or <code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;.containsKey(Key)</span><br><span class="line">&lt;map&gt;.containsValue(Value)</span><br></pre></td></tr></table></figure>

<p>※ <code>containsValue</code>方法的实现机制类似于<code>set</code>对象中的<code>contains</code>方法，先调用<code>hashCode</code>方法再调用<code>equals</code>方法。所以一般也需要重写这两个方法。<br><br></p>
<h3 id="给List对象排序"><a href="#给List对象排序" class="headerlink" title="给List对象排序"></a>给List对象排序</h3><p><code>Collections工具类</code>（相当于Arrays工具类，提供特定功能的方法，需要<code>import</code>）<br><strong>使用sort方法，对<code>List&lt;Intiger, String&gt;</code>进行排序：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(ls)  <span class="comment">//默认升序排序，判断依据：整数的大小、字符串的靠前的字符的asc码。</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）："><a href="#给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）：" class="headerlink" title="给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）："></a>给非一般泛型的List对象排序（List的元素不是Integer、String等常见类型）：</h3><p>首先，直接使用<code>collections.sort(OtherObj)</code>会报错，因为<code>sort</code>方法只能给<code>Comparable</code>接口的实现类进行排序，而<code>OtherObj</code>不是<code>comparable</code>接口的实现类。</p>
<h4 id="Collections类提供的两个接口："><a href="#Collections类提供的两个接口：" class="headerlink" title="Collections类提供的两个接口："></a>Collections类提供的两个接口：</h4><ol>
<li>Comparable接口—-提供默认比较规则，实现类要实现compareTo方法，返回值的正负表示两个值的比较结果。</li>
<li>Comparator接口—-提供临时比较规则，实现类要实现compare方法。<br>所以想要给存储其它元素的<code>List</code>对象排序，需要给该对象提供<code>comparable</code>接口，重写对应的<code>compareTo</code>方法。<br>ps：重写<code>compareTo</code>方法时，_可以调用默认的<code>compareTo</code>方法，减少工作量_。（善用this指针）<br>※ 给存放<strong>数字字符串的List对象</strong>排序的时候（如：”45688”, “7856”），要注意排序依据还是靠前字符的asc码大小，因此”7856”会排在前面。<br>另外，<code>Collections</code>工具类提供了<code>sort</code>的重载方法。使用<code>Collection.sort(List, Comparator&lt;T&gt; c)</code>，按照<code>Comparator</code>的实现类定义的<code>compare</code>方法进行排序。注意这个实现类很可能是需要自己编写的。（回顾第二季多态中接口实现类的编写）</li>
</ol>
<br>

<br>

<h3 id="回顾本章："><a href="#回顾本章：" class="headerlink" title="回顾本章："></a>回顾本章：</h3><ol>
<li>集合分为Collection和Map接口</li>
<li>Collection代表序列，其子接口有List和Set<br>List的经典实现类是<code>ArrayList</code><br>Set的经典实现类是<code>HashSet</code></li>
<li>Map代表存储键值对的集合，键值对又叫做<code>Entry&lt;Key, Value&gt;</code><br>Map的子接口有<code>HashMap</code></li>
<li>Collections工具类的sort方法用于给序列排序，介绍了两个接口Comparable和Comparator</li>
</ol>
<br>

<br>

<h3 id="扑克牌小程序思路（洗牌发牌）"><a href="#扑克牌小程序思路（洗牌发牌）" class="headerlink" title="扑克牌小程序思路（洗牌发牌）"></a>扑克牌小程序思路（洗牌发牌）</h3><h5 id="功能描述："><a href="#功能描述：" class="headerlink" title="功能描述："></a>功能描述：</h5><ol>
<li>创建扑克牌—-List</li>
<li>玩家需要有手牌（扑克牌的集合）—-编写玩家类，属性：id、name、cardList</li>
<li>洗牌（打乱顺序）—-Collections.shuffle</li>
<li>发牌—-get(), add()</li>
<li>游戏（比较大小）—-sort(), compare()   </li>
</ol>
<br>

<br>

<br>

<h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>至此，本次java入门课程的笔记到此结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/23/入门JavaSE-进阶篇/" data-id="ckiuf46lp000sy8ujmq41220e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程语言入门/">编程语言入门</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-为Windows-Terminal配置Ubuntu系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/为Windows-Terminal配置Ubuntu系统/" class="article-date">
  <time datetime="2020-09-21T12:19:20.000Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/为Windows-Terminal配置Ubuntu系统/">为Windows Terminal配置Ubuntu系统(Windows Subsystem for Linux)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>最近掘金上看了一篇文章，简单介绍了安装WindowsTerminal以及LinuxUbuntu之后，进行基本配置改善shell外观。我原来也用过windows的ubuntu子系统，抱着改善一下shell外观的念头，大概跟着做了一下，遇到了一些问题，记录一下。</em></p>
<blockquote>
<p>文章链接：<a href="https://juejin.im/post/6865596788490338311" target="_blank" rel="noopener">https://juejin.im/post/6865596788490338311</a></p>
</blockquote>
<br>

<p>第一步，安装WindowsTerminal和Ubuntu是没有问题的。打开控制面板里面的Linux子系统功能也没有问题。另外说一下，我安装的是Ubuntu20.04，毕竟技术学新不学旧嘛。</p>
<p>微软商店安装完上面两个应用之后，打开WindowsTerminal，就可以选择Ubuntu窗口了。于是下一步，给ubuntu的软件源换上镜像源。</p>
<br>

<h2 id="关于linux的vi文本编辑器的使用方法"><a href="#关于linux的vi文本编辑器的使用方法" class="headerlink" title="关于linux的vi文本编辑器的使用方法"></a>关于linux的vi文本编辑器的使用方法</h2><p>在linux下可以使用vi或者vim，进行文本编辑。大名鼎鼎的vim自然不用说，vim和vi的基本操作基本一致，但是前者的特殊操作多得多而且非常复杂，我选择这次先学习一下vi。</p>
<p>找到了一篇指导博客，整理了Linux的文件编辑命令。<br>博客地址：<a href="https://blog.csdn.net/u013142781/article/details/50735470" target="_blank" rel="noopener">https://blog.csdn.net/u013142781/article/details/50735470</a></p>
<br>

<p>关于上面这篇博客简单概括一下。</p>
<p>vi编辑器有3种编辑模式：命令行模式、文本输入模式、末行模式。</p>
<p>使用vi命令打开文本之后，默认进入命令行模式。</p>
<p>命令行模式下，输入文本命令（i、l、a等等）会跳转至对应的文本输入模式，此时就可以开始文本编辑了。</p>
<p>文本输入模式下，按Esc回到命令行模式。</p>
<p>命令行模式下按：进入末行模式，使用不同的结束命令，完成对应的操作，退出vi。</p>
<br>

<p>举一个例子</p>
<p><em>比如说我要修改wsl的Ubuntu软件源。</em><br>首先，我要用vi打开软件源所在的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>然后，我要输入指定软件源的语句，于是按下i进入文本输入模式<br><code>i</code><br>接着，在合适的位置把复制的文本粘贴进去<br><code>Linux按右键粘贴</code><br>如果想要删除多行，可以在末行模式使用命令<br><code>：m, n de</code><br>即可删除m到n行的文本<br>最后，写入文件并且退出<br><code>:wq!</code></p>
<p>然后，我要输入指定软件源的语句，于是按下i进入文本输入模式<br>i<br>接着，在合适的位置把复制的文本粘贴进去<br>Linux按右键粘贴<br>如果想要删除多行，可以在末行模式使用命令<br>：m, n de<br>即可删除m到n行的文本<br>最后，写入文件并且退出<br>:wq!</p>
<br>

<p>关于软件源，这里列一下清华源（Ubuntu 20.04）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 预发布软件源，不建议启用</span><br><span class="line"><span class="meta">#</span> deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>关于这个软件源，我后面发现安装东西的时候出了些问题。</p>
<p><strong>这里备一份默认的软件源！</strong></p>
<p>另外，有一个恢复原来的源的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -ra /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>

<p>另另外，Ubuntu每个版本都有一个代号。比如20.04（LTS）版本的代号是Focal Fossa（专注的马达加斯加长尾狸猫）。代号可以用来区分Ubuntu的源的版本。有命令可以查看当前Ubuntu的代号（Description）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<p>github上找到的默认软件源：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.canonical.com/ubuntu focal partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu focal partner</span><br></pre></td></tr></table></figure>

<br>

<p>添加了软件源之后，开始安装shell终端，很简单 sudo apt install zsh 即可。</p>
<p>然后这里我遇到了一个小问题，系统提示找不到zsh这个包。搜索了一下，发现新装的Ubuntu需要更新下apt的repository cache。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>然后再安装即可~</p>
<p>参考文章：<a href="https://itsfoss.com/unable-to-locate-package-error-ubuntu/" target="_blank" rel="noopener">https://itsfoss.com/unable-to-locate-package-error-ubuntu/</a></p>
<br>

<h2 id="安装oh-my-zsh时，又遇到了一些问题。"><a href="#安装oh-my-zsh时，又遇到了一些问题。" class="headerlink" title="安装oh-my-zsh时，又遇到了一些问题。"></a><strong>安装oh-my-zsh时，又遇到了一些问题。</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</span><br></pre></td></tr></table></figure>

<p><strong>这里直接报错：github：443端口拒绝访问</strong></p>
<p>一开始，我以为是这个地址有问题。上github的ohMyZsh项目上看了一下，发现命令没有问题。<br>然后发现原来curl的地址被墙了……</p>
<p>但是我明明是开着梯子的，为啥就没法curl下来？？</p>
<p>原来shell窗口需要自己设置代理，根据另外一篇博客，终于解决了我的问题。<br>shell设置代理参考文章：<a href="https://zhuanlan.zhihu.com/p/115450863" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/115450863</a></p>
<br>

<p>简单来说就一个命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export https_proxy=socks5://127.0.0.1:10808 http_proxy=socks5://127.0.0.1:10808 all_proxy=socks5://127.0.0.1:10808</span><br></pre></td></tr></table></figure>

<p><strong>注意，这里的端口是自己的梯子开放的端口。</strong></p>
<br>

<p>在第一次配置代理的时候，我发现curl的时候被梯子拒绝了。发现是因为没有指明sock5协议。</p>
<p>由于我的梯子没有开放http协议的设置，我没办法设置http的端口。所以10808是我sock5协议开放的端口，需要事先说明协议。</p>
<p>注意，这里的端口是自己的梯子开放的端口。<br>在第一次配置代理的时候，我发现curl的时候被梯子拒绝了。后来发现，是因为没有指明sock5协议。由于我的梯子没有开放http协议的设置，我没办法设置http的端口。所以10808是我sock5协议开放的端口，需要事先说明协议。</p>
<p>另外如果想要恢复成原来的代理状态，可以参考</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unset https_proxy</span><br><span class="line">unset http_proxy</span><br><span class="line">unset all_proxy</span><br><span class="line">env|grep -I proxy</span><br></pre></td></tr></table></figure>

<p>最后一行是干什么我没弄清楚。</p>
<p>最后一行是干什么我没弄清楚。</p>
<br>

<p>安装了oh-my-zsh之后，shell界面终于有了飞跃，画面看上去简介了不少。<br>根据我们的指导文章，我们还要看一看<u>其它zsh主题</u>，把终端的颜值再弄上去一个层次。在 <code>/home/username</code> 目录下使用<code>vi ~/.zshrc</code> 发现<code>OhMyZsh</code>的<code>Plugins</code>只有<code>git</code>，没法选择主题。于是开始在TerminalSplash上看看热门主题。<br>地址：<a href="https://terminalsplash.com/" target="_blank" rel="noopener">https://terminalsplash.com/</a></p>
<br>

<p>terminalsplash上看到一个<strong>miku</strong>的主题，怦然心动。开始琢磨怎么把<del>纸片人老婆</del>miku弄到shell终端上。<br>根据Windows Terminal Miku项目github的readme，得知需要把profiles文件夹里的文件覆盖到windowsterminal的data文件内。<br>于是，我开始<strong>寻找Windowsterminal的文件夹位置</strong>。</p>
<br>

<p>传统的文件检索太慢，所以我使用了一个软件叫<strong>Eveything</strong>，很快找到了多个相关的文件夹。有的文件夹无法访问，需要修改一下文件目录的所有者。具体操作可以参照这篇：<a href="http://www.xitongcheng.com/jiaocheng/win10_article_11880.html。" target="_blank" rel="noopener">http://www.xitongcheng.com/jiaocheng/win10_article_11880.html。</a><br>经过一番排查，终于在<strong>packetges目录下</strong>找到的需要的文件。</p>
<br>

<p>但是，把profile文件复制到对应文件之后发现shell窗口<strong>没有任何变化</strong>。<br>通过查看其它介绍windowsterminal的文章，发现原来修改shell终端的外观，<strong>需要修改windowsterminal/LocalState/settings.json</strong>。于是通过复制miku主题的json相关代码到setting.json，并且在根目录复制对应文件之后，成功修改了shell的外观！<br>其它windowsterminal参考文章：<a href="https://my.oschina.net/u/4269669/blog/4437681" target="_blank" rel="noopener">https://my.oschina.net/u/4269669/blog/4437681</a></p>
<br>

<p>至此，终于安装好了wsl服务，并且修改了shell的外观。对于这个miku主题我还是很满意的。感谢原文章的作者提供的指引~</p>
<br>

<p>参考的github项目：</p>
<ol>
<li>oh-my-zsh:<br><a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh</a></li>
<li>windows-terminal-miku:<br><a href="https://github.com/DamourYouKnow/windows-terminal-miku" target="_blank" rel="noopener">https://github.com/DamourYouKnow/windows-terminal-miku</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/21/为Windows-Terminal配置Ubuntu系统/" data-id="ckiuf46l6000ay8uj428uhkib" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其它/">其它</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程语言入门/">编程语言入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/其它/" style="font-size: 12.5px;">其它</a> <a href="/tags/后端/" style="font-size: 20px;">后端</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/编程语言入门/" style="font-size: 15px;">编程语言入门</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/课程作业/" style="font-size: 17.5px;">课程作业</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/18/阿里云《Serverless云开发从入门到实战》学习笔记/">阿里云《Serverless云开发从入门到实战》学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/12/09/使用DNS映射解决Github访问缓慢的问题/">使用DNS映射解决Github访问缓慢的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/解决无法使用Pycharm自带的pip安装第三方库的问题/">解决无法使用Pycharm自带的pip安装第三方库的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/06/使用Python可视化全国各省（除湖北）新冠疫情累计治愈病例数据/">使用Python可视化全国各省（除湖北）新冠疫情累计治愈病例数据</a>
          </li>
        
          <li>
            <a href="/2020/11/24/关于Spring-Security文档上密码发展史的阅读报告/">关于Spring Security文档上密码发展史的阅读报告</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Miaopashi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>