<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>MPS的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="MPS的个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="MPS的个人博客">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MPS的个人博客">
  
    <link rel="alternate" href="/atom.xml" title="MPS的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MPS的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MySQL的安装指南以及常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/20/MySQL的安装指南以及常用命令/" class="article-date">
  <time datetime="2020-11-20T06:37:42.000Z" itemprop="datePublished">2020-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/20/MySQL的安装指南以及常用命令/">关于CentOS下MySQL的安装指南以及常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>上周学习了如何使用Spring Boot编写一个登录注册系统，采用了<code>MySQL</code>作为数据库。</em></p>
<p>下面来记录一下，如何在<code>centOS</code>上安装<code>MySQL</code>以及<code>MySQL</code>的常用命令。</p>
<br>

<br>

<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>我参考的是掘金上的<a href="https://juejin.cn/post/6844903870053761037#heading-16" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>简要总结一下，关于<code>MySQL</code>在<code>centOS</code>上的安装，主要有四种方法。分别为yum安装法、rpm包安装法，直接解压tar包法和源码安装法。作者对于每种安装方法都进行了详细的讲解，这里我就不复制粘贴了。</p>
<p>我采用的是看上去比较省事的rpm包安装法。</p>
<br>

<br>

<h2 id="关于MySQL的常用命令"><a href="#关于MySQL的常用命令" class="headerlink" title="关于MySQL的常用命令"></a>关于MySQL的常用命令</h2><p>下面记录一下<code>MySQL</code>的常用命令，方便下一次使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">sudo systemctl start mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看状态</span><br><span class="line">sudo systemctl status mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 停止</span><br><span class="line">sudo systemctl stop mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">sudo systemctl restart mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入数据库</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<br>

<p>进入数据库之后，在MySQL-shell中常用的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看使用的端口</span><br><span class="line">show global variables like &apos;port&apos;;</span><br></pre></td></tr></table></figure>

<br>

<br>

<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p><code>MySQL</code>作为一款免费的关系数据库，是很多中小型业务首要考虑使用的数据库。但是随着当前互联网业务的不断发展壮大，关系型数据库已经不能支持很多大型项目的需求了。</p>
<p>作为大数据系的学生，尽管<code>MySQL</code>已经可以很好的支持个人开发的小型项目了，但是还是很有必要去学习一下现在很火的其它非关系型数据库，比如：<code>Redis</code>、<code>MangoDB</code>等等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/20/MySQL的安装指南以及常用命令/" data-id="cknzrcebr00005wujwod67miz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Nginx服务器的常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/18/Nginx服务器的常用命令/" class="article-date">
  <time datetime="2020-11-18T09:16:30.000Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/18/Nginx服务器的常用命令/">Nginx服务器的常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>上次学习Spring Boot编写Hello World网页的时候用到了Nginx服务器，为了以后使用方便，记录一下Nginx的常用命令。</em></p>
<br>

<h3 id="Nginx的常用命令"><a href="#Nginx的常用命令" class="headerlink" title="Nginx的常用命令"></a>Nginx的常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 设置开机启动 </span><br><span class="line">$ sudo systemctl enable nginx </span><br><span class="line"></span><br><span class="line"># 启动 nginx 服务</span><br><span class="line">$ sudo service nginx start </span><br><span class="line"></span><br><span class="line"># 停止 nginx 服务</span><br><span class="line">$ sudo service nginx stop </span><br><span class="line"></span><br><span class="line"># 重启 nginx 服务</span><br><span class="line">$ sudo service nginx restart </span><br><span class="line"></span><br><span class="line"># 重新加载配置，一般是在修改过 nginx 配置文件时使用</span><br><span class="line">$ sudo service nginx reload </span><br><span class="line"></span><br><span class="line"># 查看Nginx运行状态</span><br><span class="line">$ sudo systemctl status nginx</span><br></pre></td></tr></table></figure>

<br>

<h3 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><p>使用yum安装的nginx，配置文件默认在/etc/nginx/nginx.conf。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修改配置文件</span><br><span class="line">$ vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/18/Nginx服务器的常用命令/" data-id="cknzrcebx00025wujylrit7hb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用Spring-Boot-Spring-Security-Hibernate-Bootstrap-JSP-Spring-Data-JPA-MySQL实现的登陆注册系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/17/使用Spring-Boot-Spring-Security-Hibernate-Bootstrap-JSP-Spring-Data-JPA-MySQL实现的登陆注册系统/" class="article-date">
  <time datetime="2020-11-17T13:50:08.000Z" itemprop="datePublished">2020-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/17/使用Spring-Boot-Spring-Security-Hibernate-Bootstrap-JSP-Spring-Data-JPA-MySQL实现的登陆注册系统/">使用Spring Boot, Spring Security, Hibernate, Bootstrap, JSP, Spring Data JPA, MySQL实现的登陆注册系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="本周任务："><a href="#本周任务：" class="headerlink" title="本周任务："></a>本周任务：</h2><p>使用Spring Boot实现一个简单的用户登录系统，并且部署在服务器上。</p>
<br>

<br>

<h2 id="使用工具以及运行环境："><a href="#使用工具以及运行环境：" class="headerlink" title="使用工具以及运行环境："></a>使用工具以及运行环境：</h2><ol>
<li>Spring Boot</li>
<li>Spring Security</li>
<li>Spring Data JPA</li>
<li>Hibernate</li>
<li>JDK 8</li>
<li>Maven 3.6.3</li>
<li>MySQL Server 5.7</li>
<li>Bootstrap</li>
<li>JSP</li>
<li>IDEA</li>
</ol>
<p><br><br></p>
<h2 id="文件目录树："><a href="#文件目录树：" class="headerlink" title="文件目录树："></a>文件目录树：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">│  pom.xml</span><br><span class="line">│  </span><br><span class="line">└─src</span><br><span class="line">    └─main</span><br><span class="line">        ├─java</span><br><span class="line">        │  └─com</span><br><span class="line">        │      └─yysy</span><br><span class="line">        │          └─auth</span><br><span class="line">        │              │  WebApplication.java</span><br><span class="line">        │              │  WebSecurityConfig.java</span><br><span class="line">        │              │  </span><br><span class="line">        │              ├─model</span><br><span class="line">        │              │      Role.java</span><br><span class="line">        │              │      User.java</span><br><span class="line">        │              │      </span><br><span class="line">        │              ├─repository</span><br><span class="line">        │              │      RoleRepository.java</span><br><span class="line">        │              │      UserRepository.java</span><br><span class="line">        │              │      </span><br><span class="line">        │              ├─service</span><br><span class="line">        │              │      SecurityService.java</span><br><span class="line">        │              │      SecurityServiceImpl.java</span><br><span class="line">        │              │      UserDetailsServiceImpl.java</span><br><span class="line">        │              │      UserService.java</span><br><span class="line">        │              │      UserServiceImpl.java</span><br><span class="line">        │              │      </span><br><span class="line">        │              ├─validator</span><br><span class="line">        │              │      UserValidator.java</span><br><span class="line">        │              │      </span><br><span class="line">        │              └─web</span><br><span class="line">        │                      UserController.java</span><br><span class="line">        │                      </span><br><span class="line">        ├─resources</span><br><span class="line">        │      application.properties</span><br><span class="line">        │      validation.properties</span><br><span class="line">        │      </span><br><span class="line">        └─webapp</span><br><span class="line">            │  login.jsp</span><br><span class="line">            │  registration.jsp</span><br><span class="line">            │  welcome.jsp</span><br><span class="line">            │  </span><br><span class="line">            └─resources</span><br><span class="line">                ├─css</span><br><span class="line">                │      bootstrap.min.css</span><br><span class="line">                │      common.css</span><br><span class="line">                │      </span><br><span class="line">                └─js</span><br><span class="line">                        bootstrap.min.js</span><br></pre></td></tr></table></figure>

<br>

<br>

<h2 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h2><ol>
<li>使用Maven新建一个项目，也可以使用spring initializr等工具生成项目。</li>
<li>配置项目依赖，修改pom.xml文件，添加上述的各种依赖。</li>
<li>定义JPA和Hibernate的实体，编写<code>User.java</code>和<code>Role.java</code>，这里属于DAO模式的Model层。</li>
<li>编写Spring Data JPA仓库，编写<code>UserRepository.java</code>和<code>RoleRepository.java</code>，实现DAO模式的接口层。</li>
<li>编写几个Service类，实现用户验证功能。<ol>
<li>编写<code>UserDetailsServiceImpl.java</code>，实现Spring Security中的<code>UserDetailsService</code>接口，下面的<code>SecurityServiceImpl</code>会用到；</li>
<li>编写<code>SecurityService</code>接口以及实现类，主要实现用户的身份验证，即实现用户的登陆功能；</li>
<li>编写<code>UserService</code>接口类以及实现类，主要实现用户的注册功能；</li>
</ol>
</li>
<li>编写<code>UserValidator</code>类，用于注册表单信息的校验；<ol>
<li>主要实现的校验有：<ol>
<li>用户名长度不符合规范</li>
<li>用户名已被使用</li>
<li>用户密码太短</li>
<li>用户密码二次输入错误（二次输入是为了注册时确认密码）</li>
</ol>
</li>
<li>校验的错误信息可以在<code>validation.properties</code>中定义；</li>
<li><code>Validator</code>从<code>Spring.validation</code>导入，已实现了很多常用方法；</li>
<li>登录页面的的错误比较单一，可以直接在Controller中定义；</li>
</ol>
</li>
<li>编写<code>WebController.java</code>，处理各种url请求的响应；</li>
<li>使用Bootstrap编写登录、注册和欢迎的JSP页面；</li>
<li>编写properties文件，包括上面提到的<code>validation.properties</code>和<code>application.properties</code>。<ol>
<li>validation定义注册表单报错的具体信息</li>
<li>application指定的属性如下：<ol>
<li>指定数据库的来源</li>
<li>指定JPA、Hibernate的选项</li>
<li>指定mvc的一些选项，以及监听端口等等</li>
</ol>
</li>
</ol>
</li>
<li>编写<code>WebSecurityConfig.java</code>，其中定义了受保护的页面以及需要的角色。</li>
</ol>
<br>

<h2 id="踩到的坑："><a href="#踩到的坑：" class="headerlink" title="踩到的坑："></a>踩到的坑：</h2><ol>
<li><h3 id="下载Maven配置到IDEA，项目使用Maven下载依赖包速度很慢。"><a href="#下载Maven配置到IDEA，项目使用Maven下载依赖包速度很慢。" class="headerlink" title="下载Maven配置到IDEA，项目使用Maven下载依赖包速度很慢。"></a>下载Maven配置到IDEA，项目使用Maven下载依赖包速度很慢。</h3><p>下载Maven之后，还要修改<code>Setting.xml</code>，添加国内的镜像。（<a href="https://blog.csdn.net/Hello_World_QWP/article/details/82459915" target="_blank" rel="noopener">Maven镜像配置参考</a>）</p>
<br>
</li>
<li><h3 id="application-properties中指定的DataSource无法访问。"><a href="#application-properties中指定的DataSource无法访问。" class="headerlink" title="application.properties中指定的DataSource无法访问。"></a><code>application.properties</code>中指定的<code>DataSource</code>无法访问。</h3><p><code>spring.datasource.url</code>可以指定使用数据库的地址，有时候会遇到数据库的时区和应用的时区不同步的问题；</p>
<p>需要使用相关参数指明时区</p>
<p>使用参数<code>serverTimezone=UTC</code>，规定时区为世界标准时间</p>
<p>参数与参数之间使用<code>&amp;</code>符号进行连接</p>
<br>
</li>
<li><h3 id="JSP中文乱码问题"><a href="#JSP中文乱码问题" class="headerlink" title="JSP中文乱码问题"></a>JSP中文乱码问题</h3><p>JSP是一个java文件，当应用在JVM中运行的时候需要被编译，如果在jsp文件中写了中文，就需要事先指定；</p>
<p>否则，jsp被编译之后会直接乱码，编码说明代码如下（指定jsp文件使用utf-8编码）</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html; charset=utf-8"</span>%&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/chengkai/articles/2171848.html" target="_blank" rel="noopener">参考博客</a>。</p>
<br>
</li>
<li><h3 id="项目在IDEA可以运行，达成jar包之后页面404了"><a href="#项目在IDEA可以运行，达成jar包之后页面404了" class="headerlink" title="项目在IDEA可以运行，达成jar包之后页面404了"></a>项目在IDEA可以运行，达成jar包之后页面404了</h3><p>这是因为maven没有把<code>jsp</code>等静态资源打包进jar包，需要在<code>pom</code>文件的<code>build</code>中，指定项目所需静态文件的存储位置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这里必须是META-INF/resources--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 404解决方案之一 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，使用的spring-boot-maven版本好像只能为1.4.2，否则无法正常把文件打包进去。</p>
<br>
</li>
<li><h3 id="jar包部署到服务器之后，访问页面不知道为什么一直加载不出来（这个是个大坑）"><a href="#jar包部署到服务器之后，访问页面不知道为什么一直加载不出来（这个是个大坑）" class="headerlink" title="jar包部署到服务器之后，访问页面不知道为什么一直加载不出来（这个是个大坑）"></a>jar包部署到服务器之后，访问页面不知道为什么一直加载不出来（这个是个大坑）</h3><p><em>Linux使用<code>NativePRNG</code>算法生成<code>SecureRandom</code>，如果调用<code>generateSeed()</code>方法，这个方法会读取Linux系统的<code>/dev/random</code>文件，这个文件在<code>JAVA_HOME/jre/lib/securiy/java.security</code>里面有默认定义。而<code>/dev/random</code>文件是动态生成的，如果没有数据，就会阻塞！</em></p>
<h4 id="个人猜测："><a href="#个人猜测：" class="headerlink" title="个人猜测："></a>个人猜测：</h4><p>​    由于使用<code>SpringSecurity</code>需要生成随机数，进而JVM调用了<code>/dev/random</code>没有结果，于是发生阻塞，毕竟同样的问题在Win下没有出现。</p>
<h4 id="把JAVA-HOME-jre-lib-securiy-java-security中的securerandom改为urandom即可解决问题！"><a href="#把JAVA-HOME-jre-lib-securiy-java-security中的securerandom改为urandom即可解决问题！" class="headerlink" title="把JAVA_HOME/jre/lib/securiy/java.security中的securerandom改为urandom即可解决问题！"></a>把<code>JAVA_HOME/jre/lib/securiy/java.security</code>中的<code>securerandom</code>改为<code>urandom</code>即可解决问题！</h4><p><a href="https://www.cnblogs.com/it-deepinmind/p/13344558.html" target="_blank" rel="noopener">参考博客</a></p>
</li>
</ol>
<br>

<br>

<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>本次项目学习主要参考了<a href="https://hellokoding.com/registration-and-login-example-with-spring-security-spring-boot-spring-data-jpa-hsql-jsp/" target="_blank" rel="noopener">这篇文章</a>作为学习示例。</p>
<p>读示例项目源码的过程中，学习到了一个Spring Boot项目该有的体系结构和开发流程。</p>
<p>特别是认识到了Spring Security的强大功能，后面还会继续学习记录Spring Security的相关内容。</p>
<p>另外，这次学习没有好好看hibernate框架，后面也要抽时间好好补课，希望不会鸽掉。</p>
<p>Spring Validation提供了常用的用户校验功能，但是hibernate validation似乎能够实现效果更好的自定义校验功能，希望今后有机会可以学习学习。</p>
<p>另另外，这个项目还是使用比较陈旧的jsp文件，编写前端页面，似乎也引发了不少问题。今后学习Spring Boot项目，还是应该首要考虑thymeleaf作为前端框架。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/17/使用Spring-Boot-Spring-Security-Hibernate-Bootstrap-JSP-Spring-Data-JPA-MySQL实现的登陆注册系统/" data-id="cknzrcece000j5wujnks1x6ld" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于DAO模式的小记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/17/关于DAO模式的小记录/" class="article-date">
  <time datetime="2020-11-17T13:34:09.000Z" itemprop="datePublished">2020-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/17/关于DAO模式的小记录/">关于DAO模式的小记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上周学习SpringBoot编写用户登录系统，提到了DAO模式。</p>
<br>

<p>于是网上找了一下<strong>具体概念</strong>：</p>
<blockquote>
<p>Data Access Object Pattern or DAO pattern is used to separate low level data accessing API or operations from high level business services. Following are the participants in Data Access Object Pattern.</p>
<ul>
<li><strong>Data Access Object Interface</strong> - This interface defines the standard operations to be performed on a model object(s).</li>
<li><strong>Data Access Object concrete class</strong> - This class implements above interface. This class is responsible to get data from a data source which can be database / xml or any other storage mechanism.</li>
<li><strong>Model Object or Value Object</strong> - This object is simple POJO containing get/set methods to store data retrieved using DAO class.</li>
</ul>
</blockquote>
<br>

<p><em>渣渣翻译一下</em>：</p>
<p><strong>DAO模式用于应用的数据操作，实现了底层数据操作和高层业务的分离。</strong></p>
<br>

<p>它分为以下三个组成部分：</p>
<ol>
<li><strong>DAO接口</strong> - 定义了对于底层模式对象应该有的规范化操作；</li>
<li><strong>DAO实体类</strong> - 具体实现DAO接口里面定义的操作，<strong>负责从数据库或其它形式的数据存储中读取数据</strong>；</li>
<li><strong>Model模式对象</strong> - 这是一个简单的<strong>POJO</strong>(<strong>Plain Old Java Object</strong>，持久化类)，用于定义需要存储的数据的格式。这个类里面，有许多<strong>get/set方法</strong>，这些方法使用DAO实体类，实现对应数据的存储和修改。</li>
</ol>
<br>

<p>关于上述引用的具体内容，可以看看<a href="https://www.tutorialspoint.com/design_pattern/data_access_object_pattern.htm" target="_blank" rel="noopener">这个网页</a>。</p>
<br>

<p><strong>小结：</strong></p>
<p>DAO模式是一种将底层数据结构和高层数据操作描述分离的设计模式。</p>
<p>通过使用该模式，可以简化用户开发难度，分层进行应用开发。</p>
<p>用户可以从底层的数据存储解放出来（直接定义POJO），从而更加专注于业务需要的数据操作的具体实现上（编写DAO实体类）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/17/关于DAO模式的小记录/" data-id="cknzrcecp000y5wujy0824a08" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/大数据架构作业-简答题6/" class="article-date">
  <time datetime="2020-11-16T07:19:44.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/大数据架构作业-简答题6/">大数据架构作业-简答题6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>第六次作业又快截止了，DDL驱动的课程作业…</em></p>
<br>

<blockquote>
<h2 id="1-简述大数据处理的三类场景，说明Spark对这三类典型场景的支持。"><a href="#1-简述大数据处理的三类场景，说明Spark对这三类典型场景的支持。" class="headerlink" title="1 简述大数据处理的三类场景，说明Spark对这三类典型场景的支持。"></a>1 简述大数据处理的三类场景，说明Spark对这三类典型场景的支持。</h2></blockquote>
<h3 id="大数据处理的三类场景："><a href="#大数据处理的三类场景：" class="headerlink" title="大数据处理的三类场景："></a>大数据处理的三类场景：</h3><ol>
<li>复杂的批量数据处理；</li>
<li>基于历史数据的交互式查询；</li>
<li>基于实时数据流的数据处理。</li>
</ol>
<br>

<h3 id="Spark对于以上三类场景的支持："><a href="#Spark对于以上三类场景的支持：" class="headerlink" title="Spark对于以上三类场景的支持："></a>Spark对于以上三类场景的支持：</h3><ol>
<li>对于小时级的复杂批量数据处理，可以把批量数据，以有限数据流的形式，使用Spark进行计算处理；</li>
<li>对于分钟级和秒级的已与历史数据的交互式查询，可以使用Spark SQL组件；</li>
<li>对于毫秒级基于实时数据流的数据处理，可以使用Spark Streaming组件。</li>
</ol>
<br>

<br>

<blockquote>
<h2 id="2-简要陈述Spark的运行架构和基本流程。"><a href="#2-简要陈述Spark的运行架构和基本流程。" class="headerlink" title="2 简要陈述Spark的运行架构和基本流程。"></a>2 简要陈述Spark的运行架构和基本流程。</h2></blockquote>
<h3 id="Spark运行架构包括："><a href="#Spark运行架构包括：" class="headerlink" title="Spark运行架构包括："></a>Spark运行架构包括：</h3><ol>
<li>集群资源管理器（Cluster Manager）；</li>
<li>运行作业任务的工作节点（Worker Node）；</li>
<li>每个应用的任务控制节点（Driver）；</li>
<li>工作节点上负责具体任务的执行进程（Executor）。</li>
</ol>
<br>

<h3 id="Spark运行基本流程："><a href="#Spark运行基本流程：" class="headerlink" title="Spark运行基本流程："></a>Spark运行基本流程：</h3><ol>
<li>由Driver创建一个SparkContext，进行资源申请、任务分配和监控，为应用构建基本运行环境；</li>
<li>资源管理为Executor分配资源，启动Executor进程；</li>
<li>由SparkContext根据RDD的依赖关系构建DAG图，进而DAGScheduler可以将DAG图解析成Stage，然后就可以根据Stage把TaskSet交给TaskScheduler；</li>
<li>Executor向SparkContext申请Task，TaskScheduler将Task发放给Executor运行，并且提供应用程序代码；</li>
<li>Task在Executor上运行，把执行结果反馈给TaskScheduler，然后反馈给DAGScheduler，运行完毕写入数据并释放所有资源。</li>
</ol>
<br>

<br>

<blockquote>
<h2 id="3-简要说明Spark中“stage”的概念及其划分方法。"><a href="#3-简要说明Spark中“stage”的概念及其划分方法。" class="headerlink" title="3 简要说明Spark中“stage”的概念及其划分方法。"></a>3 简要说明Spark中“stage”的概念及其划分方法。</h2></blockquote>
<h3 id="Spark中Stage的概念："><a href="#Spark中Stage的概念：" class="headerlink" title="Spark中Stage的概念："></a>Spark中Stage的概念：</h3><p>Stage是Job的基本调度单位。一个Job可分为多组Task，每一组Task被称为一个Stage或者TaskSet。任务集包含的各项任务之间，相互关联但是没有Shuffle依赖。</p>
<br>

<h3 id="Stage的划分方法："><a href="#Stage的划分方法：" class="headerlink" title="Stage的划分方法："></a>Stage的划分方法：</h3><ol>
<li>DAGScheduler在DAG进行反向解析，遇到宽依赖就断开；</li>
<li>解析过程中，遇到窄依赖就把当前的包含的RDD加入到Stage中；</li>
<li>将窄依赖进项划分到同一个Stage中，以便实现流水线计算。</li>
</ol>
<br>

<h3 id="关于宽依赖和窄依赖："><a href="#关于宽依赖和窄依赖：" class="headerlink" title="关于宽依赖和窄依赖："></a>关于宽依赖和窄依赖：</h3><ol>
<li>宽依赖表现为，一个父RDD的单个分区映射到一个子RDD的多个分区；</li>
<li>窄依赖表现为，一个父RDD的单个分区映射到一个子RDD的单个分组，或者多个父RDD的单个分区映射到一个子RDD的单个分区。</li>
</ol>
<br>

<br>

<blockquote>
<h2 id="4-Spark部署在YARN集群上，运行程序有两种模式，请简要叙述。"><a href="#4-Spark部署在YARN集群上，运行程序有两种模式，请简要叙述。" class="headerlink" title="4 Spark部署在YARN集群上，运行程序有两种模式，请简要叙述。"></a>4 Spark部署在YARN集群上，运行程序有两种模式，请简要叙述。</h2></blockquote>
<h3 id="Spark-on-YARN运行程序有两种模式："><a href="#Spark-on-YARN运行程序有两种模式：" class="headerlink" title="Spark on YARN运行程序有两种模式："></a>Spark on YARN运行程序有两种模式：</h3><ol>
<li>Client模式，Spark的Driver运行在客户端中，程序执行期间客户端不能关闭，否则作业会挂掉，主要用于测试环境；</li>
<li>Cluster模式，Spard的Driver运行在Yarn集群上的ApplicationMaster中，可以在应用程序启动后关闭，多用于实际生产环境。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/16/大数据架构作业-简答题6/" data-id="cknzrced1001j5wujtbt8k5tx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/12/大数据架构作业-简答题5/" class="article-date">
  <time datetime="2020-11-12T08:17:20.000Z" itemprop="datePublished">2020-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/12/大数据架构作业-简答题5/">大数据架构作业-简答题5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>大数据架构技术，超星第五次作业。</em></p>
<br>

<blockquote>
<h2 id="一、简要说明Hadoop的三大核心组件及其作用。"><a href="#一、简要说明Hadoop的三大核心组件及其作用。" class="headerlink" title="一、简要说明Hadoop的三大核心组件及其作用。"></a>一、简要说明Hadoop的三大核心组件及其作用。</h2></blockquote>
<h4 id="Hadoop的核心组件："><a href="#Hadoop的核心组件：" class="headerlink" title="Hadoop的核心组件："></a>Hadoop的核心组件：</h4><p>分布式文件系统HDFS、分布式计算框架MapReduce和资源调度框架Yarn。</p>
<h4 id="Hadoop各核心组件的作用："><a href="#Hadoop各核心组件的作用：" class="headerlink" title="Hadoop各核心组件的作用："></a>Hadoop各核心组件的作用：</h4><ol>
<li><p>HDFS分布式文件系统把文件分布式存储到多个计算机节点上，再由成千上万的计算机节点构成分布式存储集群。<strong>HDFS实现了如下目标：</strong></p>
<ol>
<li>兼容廉价的硬件设备；</li>
<li>流数据读写；</li>
<li>大数据集，高可扩展性；</li>
<li>简单的文件模型；</li>
<li>强大的跨平台兼容性</li>
</ol>
</li>
<li><p>YARN框架提供资源管理与调度服务。YARN部署在集群中，为集群的各种计算框架提供统一的资源调度管理服务，并且根据各种计算框架的负载需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩。同时，YARN实现了一个集群上不同应用负载混搭，有效提高了集群的利用率。另外，在YARN框架中，不同计算框架可以共享底层存储，避免了数据集跨集群移动。</p>
</li>
<li><p>MapReduce将大规模集群上的并行计算过程抽象为两个函数Map和Reduce。使程序员无需要掌握分布式并行编程的繁琐细节，即可把自己的程序运行在 分布式系统上，实现海量数据的计算。</p>
</li>
</ol>
<br>

<blockquote>
<h2 id="二、简要说明HDFS的体系结构的组成、副本存储策略以及数据读写过程。"><a href="#二、简要说明HDFS的体系结构的组成、副本存储策略以及数据读写过程。" class="headerlink" title="二、简要说明HDFS的体系结构的组成、副本存储策略以及数据读写过程。"></a>二、简要说明HDFS的体系结构的组成、副本存储策略以及数据读写过程。</h2></blockquote>
<h4 id="HDFS的体系结构组成："><a href="#HDFS的体系结构组成：" class="headerlink" title="HDFS的体系结构组成："></a>HDFS的体系结构组成：</h4><ol>
<li>主节点(Master Node)，或者“名称结点”(NameNode)</li>
<li>从节点(Slave Node)，或者“数据节点”(DataNode)</li>
</ol>
<h4 id="HDFS的副本存储策略："><a href="#HDFS的副本存储策略：" class="headerlink" title="HDFS的副本存储策略："></a>HDFS的副本存储策略：</h4><ol>
<li>HDFS将文件分成多个块，以块为存储单位（默认一个块128MB）。</li>
<li>HDFS采用多副本方式，对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上。</li>
<li>HDFS的数据存放：第一个副本，放置在上传文件的数据节点；第二个副本，放置在与第一个副本不同的机架的节点上；第三个副本，与第一个副本相同机架的其他节点上；更多副本，随机节点。</li>
</ol>
<h4 id="HDFS数据读写过程："><a href="#HDFS数据读写过程：" class="headerlink" title="HDFS数据读写过程："></a>HDFS数据读写过程：</h4><ol>
<li><strong>HDFS读数据的过程：</strong><ol>
<li>客户端向DFS执行打开文件操作；</li>
<li>DFS向NameNode获取数据块信息；</li>
<li>客户端向DFS发送文件读取请求；</li>
<li>DFS向DataNode读取数据；</li>
<li>如果读取失败，DFS可能会再次向NameNode获取数据块信息；</li>
<li>如果读取失败，再次获取数据块信息之后，DFS再次向DataNode读取数据；</li>
<li>客户端使用完文件之后，向DFS发送关闭文件请求。</li>
</ol>
</li>
<li><strong>HDFS写数据的过程：</strong><ol>
<li>客户端向DFS发送创建文件请求；</li>
<li>DFS在NameNode创建文件元数据；</li>
<li>客户端在DFS写入数据；</li>
<li>DFS向DataNode写入数据包；</li>
<li>DataNode写入数据包之后，向DFS发送确认包；</li>
<li>客户端向DFS发送关闭文件请求；</li>
<li>DFS向NameNode通知写操作完成。</li>
</ol>
</li>
</ol>
<br>

<blockquote>
<h2 id="三、简要陈述MapReduce的体系结构组成和工作流程。"><a href="#三、简要陈述MapReduce的体系结构组成和工作流程。" class="headerlink" title="三、简要陈述MapReduce的体系结构组成和工作流程。"></a>三、简要陈述MapReduce的体系结构组成和工作流程。</h2></blockquote>
<h4 id="MapReduce的四个组成部分："><a href="#MapReduce的四个组成部分：" class="headerlink" title="MapReduce的四个组成部分："></a>MapReduce的四个组成部分：</h4><ol>
<li>Client：用户编写的MapReduce程序通过Client提交到JobTracker端；</li>
<li>JobTracker：JobTracker负责资源监控和作业调度；</li>
<li>TaskTracker：TaskTracker周期性地通过“心跳”将本节点上资源的使用情况和任务的运行进度汇报给JobTracker，同时接收JobTracker发送过来的命令并执行相应的操作；</li>
<li>Task：Task分为Map Task和Reduce Task，均由TaskTracker 启动。</li>
</ol>
<h4 id="MapReduce工作流程："><a href="#MapReduce工作流程：" class="headerlink" title="MapReduce工作流程："></a>MapReduce工作流程：</h4><p>分片（split）→本地计算（map） → 洗牌（shuffle） → 汇总计算（reduce）</p>
<h4 id="具体工作流程如下："><a href="#具体工作流程如下：" class="headerlink" title="具体工作流程如下："></a>具体工作流程如下：</h4><ol>
<li>划分MapReduce的基本处理单位split，将需要处理的数据分片；</li>
<li>Hadoop为每个split创建一个Map任务，Worker接收数据并且执行Map任务，并将执行结果写入缓存（Map）；</li>
<li>对写入缓存的数据进行溢写和文件归并等操作，把数据输入给Reduce任务（Shuffle）；</li>
<li>Reduce领取数据先放入缓存，来自不同Map机器，先归并，再合并，写入磁盘（Reduce）；</li>
<li>Map和Reduce阶段相互衔接，Shuffle阶段包含在两者之间。</li>
</ol>
<br>

<blockquote>
<h2 id="四、简要陈述YARN体系结构组成、各部分的功能及工作流程。"><a href="#四、简要陈述YARN体系结构组成、各部分的功能及工作流程。" class="headerlink" title="四、简要陈述YARN体系结构组成、各部分的功能及工作流程。"></a>四、简要陈述YARN体系结构组成、各部分的功能及工作流程。</h2></blockquote>
<h4 id="YARN体系结构组成："><a href="#YARN体系结构组成：" class="headerlink" title="YARN体系结构组成："></a>YARN体系结构组成：</h4><ol>
<li>ResourceManager（RM）：全局资源管理器，负责整个系统的资源管理和分配。包括两个组件：调度器 （Scheduler）和应用程序管理器（Applications Manager）；</li>
<li>NodeManager是驻留在YARN集群中的每个节点上的代理；</li>
<li>JobHistoryServer：统一管理YARN历史任务。</li>
<li>WebAppProxyServer： 任务执行时的Web页面代理。</li>
</ol>
<h4 id="YARN工作流程："><a href="#YARN工作流程：" class="headerlink" title="YARN工作流程："></a>YARN工作流程：</h4><ol>
<li>用户编写客户端应用程序并向YARN提交，提交内容包括ApplicationMaster程序、 启动ApplicationMaster的命令、用户程序等；</li>
<li>YARN中的ResourceManager负责接收和处理来自客户端的请求，为应用程序分 配一个容器，在该容器中启动一个ApplicationMaster；</li>
<li>ApplicationMaster被创建后会首先向ResourceManager注册；</li>
<li>ApplicationMaster采用轮询的方式向ResourceManager申请资源；</li>
<li>ResourceManager以“容器”的形式向 提出申请的ApplicationMaster分配资源；</li>
<li>在容器中启动任务（运行环境、脚本）；</li>
<li>各个任务向ApplicationMaster汇报自己的状态和进度；</li>
<li>应用程序运行完成后，ApplicationMaster向ResourceManager的应用程序管理器注销并关闭自己。</li>
</ol>
<br>

<blockquote>
<h2 id="五、说明在Hadoop计算框架下进行程序开发的主要过程。"><a href="#五、说明在Hadoop计算框架下进行程序开发的主要过程。" class="headerlink" title="五、说明在Hadoop计算框架下进行程序开发的主要过程。"></a>五、说明在Hadoop计算框架下进行程序开发的主要过程。</h2></blockquote>
<h4 id="开发流程："><a href="#开发流程：" class="headerlink" title="开发流程："></a>开发流程：</h4><ol>
<li>使用 Maven 创建项目</li>
<li>检查项目的目录结构</li>
<li>将项目导入IDE</li>
<li>配置Hadoop依赖</li>
<li>编写应用逻辑代码</li>
<li>Maven构建/编译项目</li>
<li>提交集群运行程序</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/12/大数据架构作业-简答题5/" data-id="cknzrced0001h5wuj1ef9md80" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用SpringBoot编写一个https网站" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/06/使用SpringBoot编写一个https网站/" class="article-date">
  <time datetime="2020-11-06T14:26:11.000Z" itemprop="datePublished">2020-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/06/使用SpringBoot编写一个https网站/">使用SpringBoot编写一个https网站</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>本周的任务：使用springboot编写一个helloworld网站，并且部署到服务器上。然后配置ssl正式，建立https站点。</em></p>
<br>

<h2 id="先看第一个任务，编写helloWeb并且部署。"><a href="#先看第一个任务，编写helloWeb并且部署。" class="headerlink" title="先看第一个任务，编写helloWeb并且部署。"></a>先看第一个任务，编写helloWeb并且部署。</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>下载并且安装IDEA旗舰版</li>
<li>查看springboot官方文档，根据教程新建hello项目</li>
<li>修改hello项目开放的端口，把项目打包成jar包</li>
<li>配置服务器端的java环境，让项目在服务器上运行</li>
</ol>
<br>

<h3 id="下载并且安装IDEA旗舰版"><a href="#下载并且安装IDEA旗舰版" class="headerlink" title="下载并且安装IDEA旗舰版"></a>下载并且安装IDEA旗舰版</h3><p>由于目前有学生身份，所以认证成功之后就能够免费试用IDEA旗舰版了。</p>
<p>访问Jet Barin官网，下载IDEA，登录一下学生账号之后，就可以试用IDEA编写代码了~</p>
<br>

<h3 id="查看springboot官方文档，根据教程新建hello项目"><a href="#查看springboot官方文档，根据教程新建hello项目" class="headerlink" title="查看springboot官方文档，根据教程新建hello项目"></a>查看springboot官方文档，根据教程新建hello项目</h3><p>进入springboot官网，找到QuickstartGuide，根据教程的内容打开spring initializr。</p>
<p>根据IDEA的提示，选择start.spring.io创建web项目，决定项目名，添加spring web依赖，选择springboot版本（这里我选了2.3.5），等待IDEA下载对应的配置文件之后，项目就自动生成了。</p>
<p>复制文档中的实例代码，结合原来的项目名（hello）进行一些修改，使用IDEA尝试运行springboot项目。出现app运行字样之后，使用浏览器访问localhost:8080/hello，出现Hello World!字样~</p>
<p>另外，使用浏览器访问localhost:8080/hello?name=mps，会出现Hello mps!字样。</p>
<p>可以修改src/resources/application.properties文件，添加<code>server.port=10066</code>语句，修改服务器监听的端口。</p>
<br>

<h3 id="修改hello项目开放的端口，把项目打包成jar包"><a href="#修改hello项目开放的端口，把项目打包成jar包" class="headerlink" title="修改hello项目开放的端口，把项目打包成jar包"></a>修改hello项目开放的端口，把项目打包成jar包</h3><p>根据IDEA自带的maven选项，可以把项目打包成jar包。</p>
<p>打开maven选项卡&gt;hello&gt;Lifecycle&gt;package，可以自动完成打包操作。</p>
<p>打包完成之后可以在项目的target目录看到刚刚打包出来的jar包。</p>
<p>在本地使用window terminal定位到jar包的位置，使用java -jar命令之后，使用浏览器访问localhost:10066/hello，网站正常运行，说明jar包没有问题。</p>
<br>

<h3 id="配置服务器端的java环境，让项目在服务器上运行"><a href="#配置服务器端的java环境，让项目在服务器上运行" class="headerlink" title="配置服务器端的java环境，让项目在服务器上运行"></a>配置服务器端的java环境，让项目在服务器上运行</h3><p>下面使用Xshell控制阿里云的服务器，配置java环境。</p>
<p>具体步骤：</p>
<ol>
<li>在Xshell使用rz命令，传输jdk和前面写好的jar包</li>
<li>tar命令解压jdk的tar包，安装jdk-8u261</li>
<li>使用vim命令，配置java环境变量</li>
<li>运行jar包（可以使用nohup在后台运行）</li>
</ol>
<h4 id="使用Xshell传输jdk和jar包"><a href="#使用Xshell传输jdk和jar包" class="headerlink" title="使用Xshell传输jdk和jar包"></a>使用Xshell传输jdk和jar包</h4><p>这里已经提前再本地下载了jdk1.8.0_261-liunx-x64的tar包了，可以自行访问官网下载。</p>
<p>我使用Xshell对购买的阿里服务器进行操作，下面对于服务器的操作将使用Xshell完成。</p>
<p>服务器安装lrzsz用于传输jdk以便服务器安装。</p>
<p>$ yum install lrzsz -y</p>
<p>安装完成之后，cd到需要存放文件的目录，再使用rz命令会Xshell会弹出文件传输窗口。</p>
<p>$ cd</p>
<p>$ rz</p>
<p>弹窗出现之后，可以选择本地下载的jdk1.8-linux-x64.tar以及前面打包好的jar包，传输到服务器。</p>
<p>另外，学长推荐使用Xftp传输速度更快，下次有机会可以试试。</p>
<h4 id="服务器端解压包，安装jdk-8u261"><a href="#服务器端解压包，安装jdk-8u261" class="headerlink" title="服务器端解压包，安装jdk-8u261"></a>服务器端解压包，安装jdk-8u261</h4><p>使用tar命令，解压刚刚传输的jdk包，到/usr/local/java目录。java目录可以使用mkdir新建。</p>
<p>$ mkdir /usr/local/java</p>
<p>$ tar -zxvf jdk-8u261-linux-x64.tar.gz -C /usr/local/java/</p>
<h4 id="使用vim命令，配置java环境变量"><a href="#使用vim命令，配置java环境变量" class="headerlink" title="使用vim命令，配置java环境变量"></a>使用vim命令，配置java环境变量</h4><p>使用vim命令可以修改环境变量配置文件。</p>
<p>$ vim /etc/profile</p>
<p>在末尾添加如下字段：</p>
<p>export JAVA_HOME=/usr/local/java/jdk1.8.0_261</p>
<p>export PATH=$JAVA_HOME/bin:$PATH</p>
<p>使用source命令使环境变量生效。</p>
<p>$ source /etc/profile</p>
<p>随后，查看java版本。</p>
<p>$ java -version</p>
<p>可以正常看到java的版本，说明java环境配置成功。</p>
<h4 id="运行jar包"><a href="#运行jar包" class="headerlink" title="运行jar包"></a>运行jar包</h4><p>注意，运行jar包之前，需要确保服务器的相关端口是打开的。</p>
<p>可以打开阿里云的控制台，对于服务器所在的实例，看到比如添加安全组的设置选项；</p>
<p>在安全组中，用户可以自行设置需要开放的端口。</p>
<p>这里我已经把端口提前弄好了，就不一一赘述。</p>
<p>现在可以使用java命令，在服务器运行前面传输的jar包了。</p>
<p>$ java -jar &lt;jar包名&gt;</p>
<p>在本地打开浏览器，输入xxx.xxx.xxx.xxx:10066/hello，成功访问hello网站。</p>
<p>说明项目部署成功！</p>
<br>

<p>开始配置ssl之前，需要购买一个域名。</p>
<p>进入阿里云页面，进入产品选项卡，搜索域名注册。</p>
<p>在万网寻找合适的后缀以及关键字，找到心仪的域名，加入清单。</p>
<p>结算清单，完善个人信息模板，产品支付，域名购买成功。</p>
<p>花了5块钱买了一个域名，yysy.xyz感觉还行。</p>
<br>

<p>购买域名之后，还要等待一下审核。</p>
<p>再把helloWeb解析到前面购买的域名上。</p>
<p>打开阿里云的云解析DNS控制台，点击购买的域名，添加记录，选择对应参数即可解析。</p>
<p>现在可以访问<a href="http://www.yysy.xyz:10066/hello，访问hello网站了。" target="_blank" rel="noopener">www.yysy.xyz:10066/hello，访问hello网站了。</a></p>
<br>

<h2 id="下面再看第二个任务，配置SSL证书"><a href="#下面再看第二个任务，配置SSL证书" class="headerlink" title="下面再看第二个任务，配置SSL证书"></a>下面再看第二个任务，配置SSL证书</h2><p>令项目可以在https协议下运行，实现用户安全访问。</p>
<h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>申请ssl证书</li>
<li>配置ssl证书</li>
</ol>
<br>

<h3 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h3><p>要配置ssl证书，首先需要先申请一个证书。</p>
<p>进入阿里云控制台&gt;SSL证书管理控制台，点击购买证书服务（先别慌）；</p>
<p>选择单个域名、DV域名级SSL、免费版、一年，可以看到费用直接归零，于是可以白嫖了。</p>
<p>白嫖ssl证书之后，还要进行证书申请，填写个人信息。</p>
<p>由于我的域名是阿里云买的，所以可以自动DNS验证，验证也是自动完成，证书很快就签发成功了。</p>
<br>

<h3 id="配置SSL证书之前，先解决一个问题："><a href="#配置SSL证书之前，先解决一个问题：" class="headerlink" title="配置SSL证书之前，先解决一个问题："></a>配置SSL证书之前，先解决一个问题：</h3><p>SSL证书签发之后，开始配置证书。</p>
<p>查看阿里云的SSL证书配置文档，发现SSL证书要部署在Nginx、Tomcat、Apache服务器上，而目前的helloWeb是直接是机器终端的java命令跑起来的，似乎没有包装在上述服务器内。</p>
<p>原来SpringBoot项目内置了一个Tomcat服务器，让网站项目可以直接以jar包的形式跑起来，而不需要借助外部服务器。</p>
<p>既然这个SpringBoot项目的Tomcat是内置的，就很难修改它的配置，更难部署SSL证书。</p>
<p>所以配置SSL证书之前，需要先给机器弄一个正式的服务器。</p>
<p>现在给机器配置一个Nginx服务器，顺便实现二级域名映射，摆脱<a href="http://www.yysy.xyz:10066网址后面端口号的束缚。" target="_blank" rel="noopener">www.yysy.xyz:10066网址后面端口号的束缚。</a></p>
<p>安装Nignx</p>
<p>$ sudo yum -y install nginx   # 安装 nginx<br>$ sudo yum remove nginx  # 卸载 nginx</p>
<p>配置Nginx服务</p>
<p>$ sudo systemctl enable nginx # 设置开机启动<br>$ sudo service nginx start # 启动 nginx 服务<br>$ sudo service nginx stop # 停止 nginx 服务<br>$ sudo service nginx restart # 重启 nginx 服务<br>$ sudo service nginx reload # 重新加载配置，一般是在修改过 nginx 配置文件时使用。</p>
<p>查看Nginx运行状态</p>
<p>$ sudo systemctl status nginx</p>
<p>在本地使用浏览器访问机器ip，如果无法访问可以看看是不是阿里云机器的80和443端口没有开放。</p>
<p>在/etc/nginx/nginx.conf修改配置文件，这里先不展开，下面配置ssl证书才详细讲。</p>
<p>现在直接访问<a href="http://www.yysy.xyz/hello，就可以访问到helloWeb啦！" target="_blank" rel="noopener">www.yysy.xyz/hello，就可以访问到helloWeb啦！</a></p>
<br>

<h3 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h3><p>安装了Nginx服务器之后，就可以正式开始配置SSL证书了。</p>
<p>具体步骤：</p>
<ol>
<li>登录阿里云SSL证书控制台，下载Nginx证书；</li>
<li>创建/etc/nginx/cert目录，把下载的pem和key文件拉到cert目录；</li>
<li>修改Nginx配置文件，如下所示</li>
</ol>
<p>$ vim /etc/nginx/nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。</span><br><span class="line">server &#123;</span><br><span class="line">         listen 443 ssl; #配置HTTPS的默认访问端口号为443。此处如果未配置HTTPS的默认访问端口，可能会造成Nginx无法启动。Nginx 1.15.0以上版本请使用listen 443 ssl代替listen 443 ssl和ssl on。</span><br><span class="line">         server_name www.certificatestests.com; #将www.certificatestests.com修改为您证书绑定的域名，例如：www.example.com。如果您购买的是通配符域名证书，要修改为通配符域名，例如：*.aliyun.com。</span><br><span class="line">         root html;</span><br><span class="line">         index index.html index.htm;</span><br><span class="line">         ssl_certificate cert/domain name.pem;  #将domain name.pem替换成您证书的文件名称。</span><br><span class="line">         ssl_certificate_key cert/domain name.key; #将domain name.key替换成您证书的密钥文件名称。</span><br><span class="line">         ssl_session_timeout 5m;</span><br><span class="line">         ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。</span><br><span class="line">         ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。</span><br><span class="line">         ssl_prefer_server_ciphers on;</span><br><span class="line">         location / &#123;</span><br><span class="line">         root html;  #站点目录。</span><br><span class="line">         index index.html index.htm;</span><br><span class="line">                    &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>最后重启一下Nginx就完成配置了~</p>
<br>

<p>配置SSL证书之后，还要进行网站备案。前面已经完成了域名信息的填写和域名持有者的实名认证，但是还没有进行域名持有者过户。</p>
<p>打开阿里云的域名控制台，管理yysy.xyz域名，选择域名持有者过户填写相关信息。</p>
<p>域名信息更新完成之后，网站运行的机器还要等待三个月才能申请备案，因此在Nginx上部署的项目一时半会是不能通过域名访问了……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/06/使用SpringBoot编写一个https网站/" data-id="cknzrcecg000m5wujebhfgtvt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/05/大数据架构作业-简答题4/" class="article-date">
  <time datetime="2020-11-05T11:57:57.000Z" itemprop="datePublished">2020-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/05/大数据架构作业-简答题4/">大数据架构作业-简答题4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>没想到第四份作业这么快截止…还好题目全都是能在ppt上找到的…</em></p>
<br>

<blockquote>
<p>第一问：简述什么是大数据系统，在建立大数据系统的时候需要考虑权衡哪些需求。</p>
</blockquote>
<p>大数据系统是整合了数据采集和预处理、存储和管理、处理和分析、可视化呈现等大数据处理 功能的高性能、可伸缩、高可用、高容错、安全易用的软硬件系统。可以用于帮助用户发现大数据中潜在有价值的信息和知识，把握业务现实，预测业务走向。</p>
<p>大数据系统的需求特征：</p>
<ol>
<li>数据分析需求，数据分析分为实时数据分析和批量数据分析；</li>
<li>处理方法需求，处理方法分为预测分析、科学分析、查询报告和混杂分析；</li>
<li>数据反馈频率需求，数据反馈分为按需反馈、持续反馈、实时反馈和时间序列；</li>
<li>数据类型需求，数据类型可以分为元数据类型，基本数据类型，历史数据类型和事务缓存数据类型；</li>
<li>数据内容格式需求，数据内容格式可以分为结构化，非结构化和半结构化；</li>
<li>数据来源需求，数据来源分为网站媒体，机器生成，人工产生，内部数据源，交易数据，生物特征数据等等；</li>
<li>数据客户需求，数据客户可以分为普通用户，商业处理，企业应用和数据存储库；</li>
<li>硬件需求，硬件上有廉价硬件和高性能硬件的区分。</li>
</ol>
<p>根据不同的需求特征，具体系统需要具体的权衡取舍。</p>
<br>

<blockquote>
<p>第二问：简述几类典型的大数据系统架构，详细说明Lambda架构和Kappa架构的特点和适用场合。</p>
</blockquote>
<p>常见的大数据系统架构：传统BI架构、批处理架构、流式处理架构、Lambda架构、Kappa架构。</p>
<p>Lambda架构下，数据通过两天路径并行写到流和批处理系统，程序员需要分别针对批和流两条处理路径提供相应的数据计算逻辑，最终通过服务层整合计算结果视图，进行岁外服务的输出。但是该架构下，程序员需要围挡处批处理层和速度层两套系统，并且容易个业务计算逻辑需要在两层实现和运维，数据的查询以及系统的运维比较复杂。适用于：同时存在事实和离线需求的应用情景。</p>
<p>Kappa架构下，通过流处理系统全程处理事实数据和历史数据，数据作为事件流引入到分布式统一日志中，事件流作为实时数据库进入速度层做流式处理，同时事件流在长期存储中保存，必要的时候重播事件流有流计算引擎重新计算历史数据。Kappa架构解决了Lambda架构里的冗余部分，架构简洁，但是事实难度相对较高（尤其是数据重播部分）。适用于：同时存在事实和离线需求的应用情景。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/05/大数据架构作业-简答题4/" data-id="cknzrcecy001e5wujei4bubuy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大数据架构作业-简答题3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/04/大数据架构作业-简答题3/" class="article-date">
  <time datetime="2020-11-04T06:45:47.000Z" itemprop="datePublished">2020-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/04/大数据架构作业-简答题3/">大数据架构作业-简答题3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>大数据架构第三次作业，依然记录一下。</em></p>
<br>

<h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><blockquote>
<p>假设一个企业网需要建设一个后端的缓存集群，用于缓存用户数据加速用户访问速度，因此希望<strong>每个特定的用户最好每次都访问一台固定的服务器节点</strong>，方法是将n台服务器节点编号为0~(n-1)，通过[用户账户 % n]得到访问的服务器编号。但是，如果集群中某台服务器宕机了，则n就变成了n-1，于是取余计算就很可能得不到正确的服务器编号，导致用户请求定位到错误的服务器编号，造成大量的缓存失效。</p>
<p>请设计一种方案来改善这种情况，使得<strong>集群中部分服务器失效后不会造成大面积的缓存失效</strong>；（2）原有的访问大部分还是保持在同一台服务器节点上；（3）负载尽量均衡。</p>
</blockquote>
<p>这里我的思路是，使用<strong>一致性哈希</strong>进行数据分片。</p>
<p>首先，将n个服务器节点，根据对应的编号计算相应的hash值，映射到一个首尾相接的hash环上；然后，再将用户，按照用户账户计算hash值，映射到同一个hash环上；这样，当用户发起访问请求的时候时，根据用户账户在hash环的位置，将用户的请求交给环上顺时针数到的第一个服务器节点。</p>
<p>为了实现要求(3)，需要根据用户账户的hash映射情况，设计合理的hash算法，把n个服务器以对于用户相对均匀地映射到hash环上。</p>
<p>为了实现要求(2)和要求(1)，当一个服务器宕机之后，需要及时在宕机节点的位置，设置一个新的虚拟分身节点。虚拟分身节点对应的物理节点不应该取宕机服务器附近的节点，避免出现数据倾斜和节点雪崩。</p>
<br>

<br>

<h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><blockquote>
<p>简要说明分布式系统中的副本建立策略以及各种策略存在的问题。</p>
</blockquote>
<p>建立副本的策略及其存在问题</p>
<ol>
<li>单主复制，有且仅有一个master副本，其它都是备用的slave副本，维护master副本的节点作为中心节点，负责维护数据更新、并发控制、协调副本的一致性。</li>
</ol>
<ul>
<li>单主复制的问题。可用性问题，master宕机之后，slave竞选、服务切换到新的master都需要时间，这段时间内系统拥塞，无法提供服务；一致性问题，master宕机之后，通过slave竞选出新的master，此时新旧master之间存在尚未同步的数据，导致数据不一致。</li>
</ul>
<ol start="2">
<li>多主复制，所有副本都是master，副本之间户为主从。</li>
</ol>
<ul>
<li>多主复制的问题，在并发操作时，存在数据不一致性问题。</li>
</ul>
<ol start="3">
<li>无主复制，不区分master和slave副本，客户端向多个副本同时发送请求。</li>
</ol>
<ul>
<li>无主复制的问题，尽管客户端可以进行数据补偿，但是依然存在数据不一致性问题。</li>
</ul>
<br>

<br>

<h2 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h2><blockquote>
<p>分布式系统中是否能够在保证副本强一致性的前提下，同时可以获得高可用和容错性。请简要阐述CAP定理和BASE理论的内容和作用。</p>
</blockquote>
<p><strong>CAP定理</strong>：<strong>一个分布式系统不可能同时满足一致性、可用和分区容错性，最多只能满足其中两项。</strong>一致性，所有数据副本的数据都是一致的；可用性，所有请求都能获取正确的响应；分区容错性，即使发生了网络分区，系统也能对外提供满足一致性和可用性的服务。</p>
<p>CAP定理指出了，在分布式系统的设计中，由于分区容错性不能舍弃，因此只能在一致性和可用性之间做出妥协，不能同时兼得三大特性，该定理给出了简明并且可以理解的证明。</p>
<p><strong>BASE原理</strong>：弱化一致性，追求分区容错性和可用性。基本可用，要求系统能够基本运行，一直提供服务，在出现不可预知故障的时候， 允许损失部分可用性，如响应延时或者服务降级；软状态，允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可 用性，即允许不同节点的副本之间存在暂时的不一致情况；最终一致性，要求数据不能一直处于软状态，必须在一段时间后达到一致，保证所 有副本中的数据一致性。</p>
<p>BASE理论的作用，保证最终一致性，对可用性做出让步，代表了追求可用性和分区容错性的分布式系统设计哲学。这种设计模式，对可用性要求比较高但一致性要求不是特别高的应用场景下，提供了高效的理论指导。</p>
<br>

<br>

<h2 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h2><blockquote>
<p>学习Basic Paxos算法，针对5个节点的集群，模仿算法执行过程。假设集群需要完成来自客户端的如下命令，针对该命令模仿说明算法达成一致性的过程。</p>
<p>Put(“x”, 3)</p>
<p>要求仿真出如下场景：（1）节点故障（3）并发操作请求（4）网络分区。</p>
</blockquote>
<p>假设场景：目前有五个节点，分别为node1、node2、node3、node4、node5；其中节点1、2和3和节点4和5进行了网络分区；同一时刻有两个客户端对集群发出并发请求Put(“x”, 3)；目前node3出现了故障，无法响应客户端的请求。</p>
<p>假设node1首先接收到client1的请求，node4首先接收到client2的请求，而且node1比node4更早收到请求。如下图所示</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/a95fbf4d53abf8c7c4c453ff77d8cccd.png" alt="发送请求.png"></p>
<p>node1和node4接收到请求之后成为提案者，开始Basic Paxos算法的准备阶段。node1开始向各个节点发送prepare请求，K值为1。由于各个节点此前还没有进行过同步操作，所以各个节点的MaxN都小于1，则各个节点都会回应pok。但是，由于node3节点故障，无法响应node1的请求，所以node3没有响应。node4节点上的情景和node1相类似，不再重复说明。如下图所示</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/088f1789610696a20ba27c290c5c6c05.png" alt="Prepare.png"></p>
<p>各节点返回pok之后，算法开始第二阶段接收阶段。node1收到了超过半数的pok，开始向各节点发送accept请求，accept(1, Put(“x”, 3))。但是，由于其他节点已经接收了node4的Prepare(2)请求，所以不会再接收提案编号小于2的accept请求，因此其它节点不会响应node1的请求。另一方面，node4发送的accept(2, Put(“x”, 3))，则会被除了目前故障的node3以外的其他节点接收。如下图所示</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/cb9b0ad7e65cfebdba2c659972542141" alt="img"></p>
<p>完成了如上两个阶段之后，所有非故障节点会主动同步提案2到本地，完成Put(“x”, 3)的一致性修改。</p>
<br>

<br>

<h2 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h2><blockquote>
<p>简述分布式系统中建立逻辑时钟的两种方法。</p>
</blockquote>
<p><strong>Lamport时间戳原理规则</strong>：</p>
<ol>
<li><p>每个节点本地都有一个时间戳，初始值为0。</p>
</li>
<li><p>若事件在节点内发生，本地时间戳加1。</p>
</li>
<li><p>若是发送事件，本地时间戳加1并在消息中带上该时间戳。</p>
</li>
<li><p>若是接收事件，本地时间戳 = Max(本地时间戳，消息中的时间戳)+1。</p>
</li>
</ol>
<p><strong>Lamport时间戳具体操作</strong>：</p>
<ol>
<li>假设事件a和b分别发生在节点5和节点3上，时间戳为L(a)和L(b)。</li>
<li>如果L(a) &lt; L(b)，则a发生在b之前，记作 a-&gt;b。</li>
<li>如果L(a) = L(b)，则按事件发生的节点编号排序，3&lt;5，故 b-&gt;a。</li>
</ol>
<br>

<p><strong>向量时钟具体操作:</strong></p>
<ol>
<li>事件a、b分别在节点P、Q上发生，Vector clock分别为Ta、Tb，如果 Tb[Q] &gt; Ta[Q]并且 Tb[P] &gt;= Ta[P]，则a发生于b之前，记作 a -&gt; b。</li>
<li>如果 Tb[Q] &gt; Ta[Q] 并且 Tb[P] &lt; Ta[P]，则认为a、b同时发生，记作 a &lt;-&gt; b。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/04/大数据架构作业-简答题3/" data-id="cknzrcecx001c5wujfku9l4ga" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程作业/">课程作业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习内网穿透" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/08/学习内网穿透/" class="article-date">
  <time datetime="2020-10-08T02:12:54.000Z" itemprop="datePublished">2020-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/08/学习内网穿透/">学习使用frp工具实现内网穿透</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="需要设备"><a href="#需要设备" class="headerlink" title="需要设备"></a>需要设备</h2><ol>
<li>学校分发的虚拟机</li>
<li>一个云服务器</li>
</ol>
<br>

<h2 id="熟悉云服务器"><a href="#熟悉云服务器" class="headerlink" title="熟悉云服务器"></a>熟悉云服务器</h2><p>学生优惠购买了一个实例<br>设置实例密码<br>使用<strong>vnc</strong>链接服务器，发现<strong>login incorrect</strong>，原来是实例密码跟服务器密码不一样，要自己设置一个…<br>通过阿里云的控制台修改服务器密码，重启机子，然后就可以链接啦~<br>后面了解到可以使用<strong>Xshell</strong>代替<strong>workbench</strong>链接到自己的服务器，这个教程很多随便百度都能找到<br><strong>ps:</strong> 通过下文问题一了解到，阿里云服务器通过在控制台设置安全组开启端口。</p>
<br>

<br>

<h2 id="下面正式学习frp"><a href="#下面正式学习frp" class="headerlink" title="下面正式学习frp"></a>下面正式学习frp</h2><h4 id="frp学习参考文章："><a href="#frp学习参考文章：" class="headerlink" title="frp学习参考文章："></a>frp学习参考文章：</h4><ol>
<li><a href="https://sspai.com/post/52523" target="_blank" rel="noopener">https://sspai.com/post/52523</a> =  –”少数派”的博客</li>
<li><a href="https://gofrp.org/" target="_blank" rel="noopener">https://gofrp.org/</a>  –<strong>frp</strong>的官方文档</li>
</ol>
<br>

<h4 id="安装go环境："><a href="#安装go环境：" class="headerlink" title="安装go环境："></a>安装go环境：</h4><p>直接下载<strong>go</strong>对应的版本：<a href="https://golang.org/dl/go1.15.2.linux-amd64.tar.gz" target="_blank" rel="noopener">https://golang.org/dl/go1.15.2.linux-amd64.tar.gz</a><br>也可以使用<strong>wget</strong>命令直接在终端下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.15.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong> 如果想通过<strong>wget</strong>命令下载，貌似需要提前安装git和<strong>gcc</strong>，参考文章1<br>然后参考文章2的提示，通过<code>tar</code>和<code>export</code>命令，完成<strong>go</strong>的安装<br>参考的文章：</p>
<ol>
<li><a href="https://www.jianshu.com/p/21dc1bcf382e" target="_blank" rel="noopener">https://www.jianshu.com/p/21dc1bcf382e</a></li>
<li><a href="https://golang.org/doc/install#requirements" target="_blank" rel="noopener">https://golang.org/doc/install#requirements</a></li>
</ol>
<br>

<h4 id="下载frp"><a href="#下载frp" class="headerlink" title="下载frp"></a>下载frp</h4><p>使用<strong>wget</strong>命令下载<strong>frp</strong>的最新版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.34.0/frp_0.34.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong> 下载的版本错了可以使用rm命令删除，详见博客1<br><strong>pps:</strong> <strong>wget</strong>命令好像跟<strong>yum</strong>命令不一样，配置软件源没有什么用，想配置的可以参考一下博客2<br>参考的博客：</p>
<ol>
<li><a href="https://blog.csdn.net/sqbzo/article/details/8990404" target="_blank" rel="noopener">https://blog.csdn.net/sqbzo/article/details/8990404</a></li>
<li><a href="https://www.jianshu.com/p/541c737bc947" target="_blank" rel="noopener">https://www.jianshu.com/p/541c737bc947</a></li>
</ol>
<br>

<h4 id="启动frps-配置frps端"><a href="#启动frps-配置frps端" class="headerlink" title="启动frps(配置frps端)"></a>启动frps(配置frps端)</h4><p>内网穿透是把自己的终端穿透到有公网ip的服务器上的技术，这里我们先配置<strong>VPS</strong>（有公网ip的服务器），也就是<strong>frps</strong>端，这里我使用了阿里的服务器<br>先使用<strong>tar</strong>命令解压刚下载的frp：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.34.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后cd进该目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.34.0_linux_amd64</span><br></pre></td></tr></table></figure>

<p>检查文件发现目录内除了<strong>fprs</strong>文件还有<strong>frpc</strong>文件，使用rm命令将<strong>frpc</strong>文件一一删除<br>然后修改<strong>frps.ini</strong>文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim frps.ini</span><br></pre></td></tr></table></figure>

<p>文件格式大致如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">vhost_http_port = 10080</span><br><span class="line">vhost_https_port = 100443</span><br><span class="line">dashboard_port = 7500</span><br><span class="line">token = ******</span><br><span class="line">dashboard_user = ms</span><br><span class="line">dashboard_pwd = ********</span><br></pre></td></tr></table></figure>

<p>编辑完成之后保存:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p>然后启动<strong>frps：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>

<p>出现<strong>start</strong>字样，说明<strong>frps</strong>服务启动成功</p>
<br>

<h4 id="问题一：x-x-x-xxx-7500无法连接至控制页面"><a href="#问题一：x-x-x-xxx-7500无法连接至控制页面" class="headerlink" title="问题一：x.x.x.xxx:7500无法连接至控制页面"></a>问题一：x.x.x.xxx:7500无法连接至控制页面</h4><p>运行<strong>frps</strong>之后，使用浏览器访问对应的地址无响应…<br>根据博客2，发现原来是防火墙没有开放服务器指定的端口！<br>查看端口是否开放: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=7500/tcp --zone=public</span><br></pre></td></tr></table></figure>

<p>如果端口开放了就返回<strong>yes</strong>，反则返回<strong>no</strong><br>但是，我返回的是<strong>FirewallD is not running</strong>…<br>百度找到博客3，发现原来服务器没有打开防火墙！<br>根据blog3打开防火墙：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system start firewalld</span><br></pre></td></tr></table></figure>

<p>打开7500端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=7500/tcp</span><br></pre></td></tr></table></figure>

<p>这次再使用<strong>firewall-cmd</strong>命令看端口是否开放，返回的结果居然是<strong>no</strong>…<br>再次百度，根据博客1，发现阿里的服务器需要<strong>另外设置安全组</strong>才能开放相关的端口！<br>根据博客1设置安全组，开放2000到20000的端口<br>重启服务器之后，再次打开防火墙，开放7500端口<br>再次使用<strong>firewall-cmd</strong>检查，这次终于返回yes了<br>访问<strong>x.x.x.xxx:7500</strong>，输入用户密码，成功访问<strong>frp</strong>管理网页！<br>后话：后面配置<strong>frpc</strong>的时候居然要关闭防火墙，所以前面根据博客3和博客2关于防火墙和端口的修改其实没有什么必要，直接使用阿里云的控制平台开放端口才是正解！<br>参考的博客：</p>
<ol>
<li><a href="https://blog.csdn.net/weferxe/article/details/104777838" target="_blank" rel="noopener">https://blog.csdn.net/weferxe/article/details/104777838</a>  –设置阿里云安全组</li>
<li><a href="https://koolshare.cn/forum.php?mod=viewthread&amp;tid=137536&amp;page=1&amp;extra=" target="_blank" rel="noopener">https://koolshare.cn/forum.php?mod=viewthread&amp;tid=137536&amp;page=1&amp;extra=</a>  –开放端口的命令</li>
<li><a href="https://www.cnblogs.com/rxbook/p/8110143.html" target="_blank" rel="noopener">https://www.cnblogs.com/rxbook/p/8110143.html</a>  –控制<strong>linux</strong>的防火墙</li>
</ol>
<br>

<h4 id="使用nohup挂起frps进程"><a href="#使用nohup挂起frps进程" class="headerlink" title="使用nohup挂起frps进程"></a>使用nohup挂起frps进程</h4><p>目前关闭<strong>shell</strong>窗口之后，现在的<strong>frps</strong>进程就会结束<br>为了让<strong>frps</strong>和<strong>frpc</strong>两端一直穿透，需要把<strong>frps</strong>进程挂到后台<br>参考博客1，使用<strong>nohup</strong>命令把进程移动到后台:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure>

<p>同理，后面<strong>frpc</strong>端也要使用nohup挂起进程<br>参考的博客：</p>
<p>同理，后面frpc端也要使用nohup挂起进程<br>参考的博客：</p>
<ol>
<li><a href="https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/</a> –这篇博客还介绍了后台进程的关闭等事项</li>
</ol>
<br>

<h4 id="启动frpc-配置frpc端"><a href="#启动frpc-配置frpc端" class="headerlink" title="启动frpc(配置frpc端)"></a>启动frpc(配置frpc端)</h4><p>上面配置好了<strong>frps</strong>端，下面再配置<strong>frpc</strong>端之后就能实现穿透了！<br>这里我使用学校机房分发的一台虚拟机，作为<strong>frpc</strong>端，同样需要实现安装golang和<strong>frp</strong><br>下载完<strong>frp</strong>的安装包之后，和<strong>frps</strong>端类似，tar解压，然后删除f<strong>rps</strong>文件<br>使用vim命令修改frpc.ini:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure>

<p>文件的格式大致如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line">token = ******</span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = x.x.x.x</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 这里的<strong>local_port</strong>是指frpc机子上<strong>web</strong>进程使用的端口; custom_domains是<strong>frps</strong>端的<strong>ip地址</strong>或者域名，由于我还没买域名，所以这里就填了自己的ip<br>保存之后启动进程: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></table></figure>

<p>进程正常启动，和<strong>frps</strong>端类似，使用nohup把进程挂起，<strong>frpc</strong>端配置就完成了！</p>
<br>

<h4 id="编写一个最简单的web"><a href="#编写一个最简单的web" class="headerlink" title="编写一个最简单的web"></a>编写一个最简单的web</h4><p>现在<strong>frpc</strong>端已经配置完成，还需要写一个web测试一下，<strong>web</strong>服务能否被正常访问<br>远程控制学校分配的虚拟机，使用<strong>python</strong>的flask框架编写一个简单的应用</p>
<br>

<p>安装<strong>python3</strong>和<strong>pip3</strong><br>安装<strong>python3</strong>直接<strong>yum</strong>即可，安装<strong>pip3</strong>可以参照一下文章1<br>使用<strong>pip</strong>安装<strong>flask</strong>： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i [清华源] flask</span><br></pre></td></tr></table></figure>

<p>使用清华源安装<strong>flask</strong>快一点，详细参照文章2<br>完成上面的安装之后就可以开始编写<strong>web</strong>了！<br>参考文章：</p>
<ol>
<li><a href="https://blog.csdn.net/jamieblue1/article/details/89208151" target="_blank" rel="noopener">https://blog.csdn.net/jamieblue1/article/details/89208151</a>  –安装pip</li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a>  –清华</li>
</ol>
<br>

<h4 id="编写app-py"><a href="#编写app-py" class="headerlink" title="编写app.py"></a>编写app.py</h4><p>临时创建一个文件夹<strong>test_flask</strong>，存放app.py<br>根据<strong>flask</strong>的官方文档，文章1，编写一个只返回<strong>‘frp sucess!!!’</strong>的简单应用<br><strong>vim app.py:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'frp sucess!!!'</span></span><br></pre></td></tr></table></figure>

<p>然后保存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p>启动web:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=app.py</span><br><span class="line">python3 -m flask run</span><br></pre></td></tr></table></figure>

<p>然后使用自己的机子访问<strong>x.x.x.x:10080</strong>，显示<strong>‘frp sucess!!!’</strong>，说明内网穿透成功！</p>
<p>参考文章：</p>
<ol>
<li><a href="https://dormousehole.readthedocs.io/en/latest/quickstart.html#id2" target="_blank" rel="noopener">https://dormousehole.readthedocs.io/en/latest/quickstart.html#id2</a></li>
</ol>
<br>

<br>

<p>结语：<br>内网穿透技术可以很好地解决<strong>VPS</strong>配置不足的问题，由于学校机房分配了3台虚拟机，我才想借机利用一下，才学习了<strong>frp</strong>。但是在学习的中途我越发觉得这个技术对于学生来说，能够提供很大的便利，于是把学习的过程记录下来，希望能够帮助到其他人。<br>以后想学习一下<strong>nignx</strong>，尝试一下能否把多个域名映射到一台<strong>VPS</strong>的不同端口，进而穿透到不同的机子，提供多个服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/08/学习内网穿透/" data-id="cknzrced4001m5wujwv0jq3y0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其它/">其它</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程语言入门/">编程语言入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/课程作业/">课程作业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目/">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/其它/" style="font-size: 12.5px;">其它</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/后端/" style="font-size: 20px;">后端</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/编程语言入门/" style="font-size: 15px;">编程语言入门</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/课程作业/" style="font-size: 17.5px;">课程作业</a> <a href="/tags/项目/" style="font-size: 10px;">项目</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/27/使用js和后端模糊查询实现搜索提示功能/">使用js和后端模糊查询实现搜索提示功能</a>
          </li>
        
          <li>
            <a href="/2021/04/27/使用Docker部署jar包/">使用Docker部署jar包</a>
          </li>
        
          <li>
            <a href="/2021/04/15/毕节市可视化Java项目博客记录-日期格式的转换/">毕节市可视化Java项目博客记录----日期格式的转换</a>
          </li>
        
          <li>
            <a href="/2021/04/08/工作室技术分享会/">工作室技术分享会</a>
          </li>
        
          <li>
            <a href="/2020/12/18/阿里云《Serverless云开发从入门到实战》学习笔记/">阿里云《Serverless云开发从入门到实战》学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Miaopashi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>